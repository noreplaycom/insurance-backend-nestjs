
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Participant
 * 
 */
export type Participant = $Result.DefaultSelection<Prisma.$ParticipantPayload>
/**
 * Model ContactInfo
 * 
 */
export type ContactInfo = $Result.DefaultSelection<Prisma.$ContactInfoPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model Employment
 * 
 */
export type Employment = $Result.DefaultSelection<Prisma.$EmploymentPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ProgramParticipation
 * 
 */
export type ProgramParticipation = $Result.DefaultSelection<Prisma.$ProgramParticipationPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ClaimType
 * 
 */
export type ClaimType = $Result.DefaultSelection<Prisma.$ClaimTypePayload>
/**
 * Model ClaimFinancial
 * 
 */
export type ClaimFinancial = $Result.DefaultSelection<Prisma.$ClaimFinancialPayload>
/**
 * Model ClaimProcess
 * 
 */
export type ClaimProcess = $Result.DefaultSelection<Prisma.$ClaimProcessPayload>
/**
 * Model ClaimStatus
 * 
 */
export type ClaimStatus = $Result.DefaultSelection<Prisma.$ClaimStatusPayload>
/**
 * Model Disease
 * 
 */
export type Disease = $Result.DefaultSelection<Prisma.$DiseasePayload>
/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Permission: {
  CREATE_CLAIM: 'CREATE_CLAIM',
  UPDATE_CLAIM: 'UPDATE_CLAIM',
  UPDATE_CLAIM_STATUS: 'UPDATE_CLAIM_STATUS',
  UPDATE_STATUS_FINANCIAL: 'UPDATE_STATUS_FINANCIAL',
  RELEASE_CLAIM: 'RELEASE_CLAIM',
  DELETE_CLAIM_DOCUMENT: 'DELETE_CLAIM_DOCUMENT',
  CREATE_CLAIM_DOCUMENT: 'CREATE_CLAIM_DOCUMENT',
  IMPORT_CLAIM: 'IMPORT_CLAIM',
  EXPORT_CLAIM: 'EXPORT_CLAIM',
  CREATE_PARTICIPANT: 'CREATE_PARTICIPANT',
  UPDATE_PARTICIPANT: 'UPDATE_PARTICIPANT',
  IMPORT_PARTICIPANT: 'IMPORT_PARTICIPANT',
  EXPORT_PARTICIPANT: 'EXPORT_PARTICIPANT'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const Gender: {
  UNKNOWN: 'UNKNOWN',
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ParticipantStatus: {
  PENSIUNAN: 'PENSIUNAN',
  PASANGAN: 'PASANGAN',
  YATIM: 'YATIM',
  JANDADUDA6BULAN: 'JANDADUDA6BULAN'
};

export type ParticipantStatus = (typeof ParticipantStatus)[keyof typeof ParticipantStatus]


export const Position: {
  AMGR: 'AMGR',
  AVP: 'AVP',
  PGD: 'PGD',
  MGR: 'MGR',
  SASST: 'SASST',
  VP: 'VP',
  SAVP: 'SAVP',
  SMGR: 'SMGR',
  SAMGR: 'SAMGR',
  ASST: 'ASST'
};

export type Position = (typeof Position)[keyof typeof Position]


export const ApplicationType: {
  SANTUNAN_HARIAN_RAWAT_INAP: 'SANTUNAN_HARIAN_RAWAT_INAP',
  BANTUAN_BIAYA_CUCI_DARAH: 'BANTUAN_BIAYA_CUCI_DARAH',
  BANTUAN_KURSI_RODA: 'BANTUAN_KURSI_RODA',
  BANTUAN_WALKER: 'BANTUAN_WALKER',
  BANTUAN_IGD_UGD: 'BANTUAN_IGD_UGD',
  BANTUAN_RAWAT_INAP: 'BANTUAN_RAWAT_INAP'
};

export type ApplicationType = (typeof ApplicationType)[keyof typeof ApplicationType]


export const Class: {
  I: 'I',
  II: 'II',
  III: 'III'
};

export type Class = (typeof Class)[keyof typeof Class]


export const ClaimChannel: {
  REGULER: 'REGULER',
  WA: 'WA',
  EMAIL: 'EMAIL'
};

export type ClaimChannel = (typeof ClaimChannel)[keyof typeof ClaimChannel]


export const AdmedicaStatus: {
  NON_ADMEDICA: 'NON_ADMEDICA',
  ADMEDICA: 'ADMEDICA'
};

export type AdmedicaStatus = (typeof AdmedicaStatus)[keyof typeof AdmedicaStatus]


export const DocumentSource: {
  UPLOADED: 'UPLOADED',
  GENERATED: 'GENERATED'
};

export type DocumentSource = (typeof DocumentSource)[keyof typeof DocumentSource]


export const DocumentType: {
  INVOICE: 'INVOICE',
  CLAIM_FORM: 'CLAIM_FORM',
  REJECTION_LETTER: 'REJECTION_LETTER',
  GUARANTEE_LETTER: 'GUARANTEE_LETTER',
  RECAP: 'RECAP',
  EXPEDITION: 'EXPEDITION',
  TRANSFER: 'TRANSFER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const Color: {
  WHITE: 'WHITE',
  BLUE: 'BLUE',
  RED: 'RED',
  YELLOW: 'YELLOW',
  GREEN: 'GREEN'
};

export type Color = (typeof Color)[keyof typeof Color]


export const ClaimStatusType: {
  DOCUMENT: 'DOCUMENT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  RELEASE: 'RELEASE',
  PAID: 'PAID',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REOPEN: 'REOPEN'
};

export type ClaimStatusType = (typeof ClaimStatusType)[keyof typeof ClaimStatusType]


export const TransactionType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]

}

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ParticipantStatus = $Enums.ParticipantStatus

export const ParticipantStatus: typeof $Enums.ParticipantStatus

export type Position = $Enums.Position

export const Position: typeof $Enums.Position

export type ApplicationType = $Enums.ApplicationType

export const ApplicationType: typeof $Enums.ApplicationType

export type Class = $Enums.Class

export const Class: typeof $Enums.Class

export type ClaimChannel = $Enums.ClaimChannel

export const ClaimChannel: typeof $Enums.ClaimChannel

export type AdmedicaStatus = $Enums.AdmedicaStatus

export const AdmedicaStatus: typeof $Enums.AdmedicaStatus

export type DocumentSource = $Enums.DocumentSource

export const DocumentSource: typeof $Enums.DocumentSource

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type Color = $Enums.Color

export const Color: typeof $Enums.Color

export type ClaimStatusType = $Enums.ClaimStatusType

export const ClaimStatusType: typeof $Enums.ClaimStatusType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.participant`: Exposes CRUD operations for the **Participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participant.findMany()
    * ```
    */
  get participant(): Prisma.ParticipantDelegate<ExtArgs>;

  /**
   * `prisma.contactInfo`: Exposes CRUD operations for the **ContactInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInfos
    * const contactInfos = await prisma.contactInfo.findMany()
    * ```
    */
  get contactInfo(): Prisma.ContactInfoDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs>;

  /**
   * `prisma.employment`: Exposes CRUD operations for the **Employment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employments
    * const employments = await prisma.employment.findMany()
    * ```
    */
  get employment(): Prisma.EmploymentDelegate<ExtArgs>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.programParticipation`: Exposes CRUD operations for the **ProgramParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramParticipations
    * const programParticipations = await prisma.programParticipation.findMany()
    * ```
    */
  get programParticipation(): Prisma.ProgramParticipationDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.claimType`: Exposes CRUD operations for the **ClaimType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimTypes
    * const claimTypes = await prisma.claimType.findMany()
    * ```
    */
  get claimType(): Prisma.ClaimTypeDelegate<ExtArgs>;

  /**
   * `prisma.claimFinancial`: Exposes CRUD operations for the **ClaimFinancial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimFinancials
    * const claimFinancials = await prisma.claimFinancial.findMany()
    * ```
    */
  get claimFinancial(): Prisma.ClaimFinancialDelegate<ExtArgs>;

  /**
   * `prisma.claimProcess`: Exposes CRUD operations for the **ClaimProcess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimProcesses
    * const claimProcesses = await prisma.claimProcess.findMany()
    * ```
    */
  get claimProcess(): Prisma.ClaimProcessDelegate<ExtArgs>;

  /**
   * `prisma.claimStatus`: Exposes CRUD operations for the **ClaimStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimStatuses
    * const claimStatuses = await prisma.claimStatus.findMany()
    * ```
    */
  get claimStatus(): Prisma.ClaimStatusDelegate<ExtArgs>;

  /**
   * `prisma.disease`: Exposes CRUD operations for the **Disease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diseases
    * const diseases = await prisma.disease.findMany()
    * ```
    */
  get disease(): Prisma.DiseaseDelegate<ExtArgs>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    RolePermission: 'RolePermission',
    Participant: 'Participant',
    ContactInfo: 'ContactInfo',
    Address: 'Address',
    City: 'City',
    BankAccount: 'BankAccount',
    Employment: 'Employment',
    Branch: 'Branch',
    Group: 'Group',
    Region: 'Region',
    Announcement: 'Announcement',
    Notification: 'Notification',
    ProgramParticipation: 'ProgramParticipation',
    Program: 'Program',
    Claim: 'Claim',
    Document: 'Document',
    Tag: 'Tag',
    ClaimType: 'ClaimType',
    ClaimFinancial: 'ClaimFinancial',
    ClaimProcess: 'ClaimProcess',
    ClaimStatus: 'ClaimStatus',
    Disease: 'Disease',
    Clinic: 'Clinic',
    Account: 'Account',
    Transaction: 'Transaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'role' | 'rolePermission' | 'participant' | 'contactInfo' | 'address' | 'city' | 'bankAccount' | 'employment' | 'branch' | 'group' | 'region' | 'announcement' | 'notification' | 'programParticipation' | 'program' | 'claim' | 'document' | 'tag' | 'claimType' | 'claimFinancial' | 'claimProcess' | 'claimStatus' | 'disease' | 'clinic' | 'account' | 'transaction'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>,
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>,
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Participant: {
        payload: Prisma.$ParticipantPayload<ExtArgs>
        fields: Prisma.ParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipantFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipantFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findFirst: {
            args: Prisma.ParticipantFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipantFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findMany: {
            args: Prisma.ParticipantFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          create: {
            args: Prisma.ParticipantCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          createMany: {
            args: Prisma.ParticipantCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ParticipantDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          update: {
            args: Prisma.ParticipantUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ParticipantDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipantUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ParticipantUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          aggregate: {
            args: Prisma.ParticipantAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateParticipant>
          }
          groupBy: {
            args: Prisma.ParticipantGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipantCountArgs<ExtArgs>,
            result: $Utils.Optional<ParticipantCountAggregateOutputType> | number
          }
        }
      }
      ContactInfo: {
        payload: Prisma.$ContactInfoPayload<ExtArgs>
        fields: Prisma.ContactInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInfoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInfoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findFirst: {
            args: Prisma.ContactInfoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInfoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          findMany: {
            args: Prisma.ContactInfoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>[]
          }
          create: {
            args: Prisma.ContactInfoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          createMany: {
            args: Prisma.ContactInfoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactInfoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          update: {
            args: Prisma.ContactInfoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          deleteMany: {
            args: Prisma.ContactInfoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInfoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactInfoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactInfoPayload>
          }
          aggregate: {
            args: Prisma.ContactInfoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContactInfo>
          }
          groupBy: {
            args: Prisma.ContactInfoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactInfoCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactInfoCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>,
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>,
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      Employment: {
        payload: Prisma.$EmploymentPayload<ExtArgs>
        fields: Prisma.EmploymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          findFirst: {
            args: Prisma.EmploymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          findMany: {
            args: Prisma.EmploymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>[]
          }
          create: {
            args: Prisma.EmploymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          createMany: {
            args: Prisma.EmploymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmploymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          update: {
            args: Prisma.EmploymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          deleteMany: {
            args: Prisma.EmploymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmploymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmploymentPayload>
          }
          aggregate: {
            args: Prisma.EmploymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmployment>
          }
          groupBy: {
            args: Prisma.EmploymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmploymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentCountArgs<ExtArgs>,
            result: $Utils.Optional<EmploymentCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>,
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>,
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>,
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ProgramParticipation: {
        payload: Prisma.$ProgramParticipationPayload<ExtArgs>
        fields: Prisma.ProgramParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramParticipationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramParticipationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          findFirst: {
            args: Prisma.ProgramParticipationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramParticipationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          findMany: {
            args: Prisma.ProgramParticipationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>[]
          }
          create: {
            args: Prisma.ProgramParticipationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          createMany: {
            args: Prisma.ProgramParticipationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProgramParticipationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          update: {
            args: Prisma.ProgramParticipationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          deleteMany: {
            args: Prisma.ProgramParticipationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramParticipationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProgramParticipationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          aggregate: {
            args: Prisma.ProgramParticipationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProgramParticipation>
          }
          groupBy: {
            args: Prisma.ProgramParticipationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProgramParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramParticipationCountArgs<ExtArgs>,
            result: $Utils.Optional<ProgramParticipationCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>,
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ClaimType: {
        payload: Prisma.$ClaimTypePayload<ExtArgs>
        fields: Prisma.ClaimTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          findFirst: {
            args: Prisma.ClaimTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          findMany: {
            args: Prisma.ClaimTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>[]
          }
          create: {
            args: Prisma.ClaimTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          createMany: {
            args: Prisma.ClaimTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          update: {
            args: Prisma.ClaimTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          deleteMany: {
            args: Prisma.ClaimTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimTypePayload>
          }
          aggregate: {
            args: Prisma.ClaimTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaimType>
          }
          groupBy: {
            args: Prisma.ClaimTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimTypeCountAggregateOutputType> | number
          }
        }
      }
      ClaimFinancial: {
        payload: Prisma.$ClaimFinancialPayload<ExtArgs>
        fields: Prisma.ClaimFinancialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFinancialFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFinancialFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          findFirst: {
            args: Prisma.ClaimFinancialFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFinancialFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          findMany: {
            args: Prisma.ClaimFinancialFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>[]
          }
          create: {
            args: Prisma.ClaimFinancialCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          createMany: {
            args: Prisma.ClaimFinancialCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimFinancialDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          update: {
            args: Prisma.ClaimFinancialUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          deleteMany: {
            args: Prisma.ClaimFinancialDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimFinancialUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimFinancialUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimFinancialPayload>
          }
          aggregate: {
            args: Prisma.ClaimFinancialAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaimFinancial>
          }
          groupBy: {
            args: Prisma.ClaimFinancialGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimFinancialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimFinancialCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimFinancialCountAggregateOutputType> | number
          }
        }
      }
      ClaimProcess: {
        payload: Prisma.$ClaimProcessPayload<ExtArgs>
        fields: Prisma.ClaimProcessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimProcessFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimProcessFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          findFirst: {
            args: Prisma.ClaimProcessFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimProcessFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          findMany: {
            args: Prisma.ClaimProcessFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>[]
          }
          create: {
            args: Prisma.ClaimProcessCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          createMany: {
            args: Prisma.ClaimProcessCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimProcessDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          update: {
            args: Prisma.ClaimProcessUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          deleteMany: {
            args: Prisma.ClaimProcessDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimProcessUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimProcessUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimProcessPayload>
          }
          aggregate: {
            args: Prisma.ClaimProcessAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaimProcess>
          }
          groupBy: {
            args: Prisma.ClaimProcessGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimProcessGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimProcessCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimProcessCountAggregateOutputType> | number
          }
        }
      }
      ClaimStatus: {
        payload: Prisma.$ClaimStatusPayload<ExtArgs>
        fields: Prisma.ClaimStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          findFirst: {
            args: Prisma.ClaimStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          findMany: {
            args: Prisma.ClaimStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>[]
          }
          create: {
            args: Prisma.ClaimStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          createMany: {
            args: Prisma.ClaimStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClaimStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          update: {
            args: Prisma.ClaimStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          deleteMany: {
            args: Prisma.ClaimStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClaimStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClaimStatusPayload>
          }
          aggregate: {
            args: Prisma.ClaimStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClaimStatus>
          }
          groupBy: {
            args: Prisma.ClaimStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClaimStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<ClaimStatusCountAggregateOutputType> | number
          }
        }
      }
      Disease: {
        payload: Prisma.$DiseasePayload<ExtArgs>
        fields: Prisma.DiseaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiseaseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiseaseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          findFirst: {
            args: Prisma.DiseaseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiseaseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          findMany: {
            args: Prisma.DiseaseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>[]
          }
          create: {
            args: Prisma.DiseaseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          createMany: {
            args: Prisma.DiseaseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DiseaseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          update: {
            args: Prisma.DiseaseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          deleteMany: {
            args: Prisma.DiseaseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DiseaseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DiseaseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DiseasePayload>
          }
          aggregate: {
            args: Prisma.DiseaseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDisease>
          }
          groupBy: {
            args: Prisma.DiseaseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DiseaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiseaseCountArgs<ExtArgs>,
            result: $Utils.Optional<DiseaseCountAggregateOutputType> | number
          }
        }
      }
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>,
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>,
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    claimsInput: number
    claimActions: number
    announcementCreated: number
    notification: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimsInput?: boolean | UserCountOutputTypeCountClaimsInputArgs
    claimActions?: boolean | UserCountOutputTypeCountClaimActionsArgs
    announcementCreated?: boolean | UserCountOutputTypeCountAnnouncementCreatedArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimStatusWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }



  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolePermissions: number
    users: number
    lowerLevelThan: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    lowerLevelThan?: boolean | RoleCountOutputTypeCountLowerLevelThanArgs
  }

  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountLowerLevelThanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }



  /**
   * Count Type ParticipantCountOutputType
   */

  export type ParticipantCountOutputType = {
    claims: number
    employments: number
    contactInfos: number
    programParticipations: number
    balances: number
    Participant: number
  }

  export type ParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | ParticipantCountOutputTypeCountClaimsArgs
    employments?: boolean | ParticipantCountOutputTypeCountEmploymentsArgs
    contactInfos?: boolean | ParticipantCountOutputTypeCountContactInfosArgs
    programParticipations?: boolean | ParticipantCountOutputTypeCountProgramParticipationsArgs
    balances?: boolean | ParticipantCountOutputTypeCountBalancesArgs
    Participant?: boolean | ParticipantCountOutputTypeCountParticipantArgs
  }

  // Custom InputTypes

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantCountOutputType
     */
    select?: ParticipantCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountEmploymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentWhereInput
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountContactInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoWhereInput
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountProgramParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
  }



  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    ContactInfo: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ContactInfo?: boolean | AddressCountOutputTypeCountContactInfoArgs
  }

  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountContactInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoWhereInput
  }



  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    address: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | CityCountOutputTypeCountAddressArgs
  }

  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }



  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    employment: number
    claimFinancial: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | BranchCountOutputTypeCountEmploymentArgs
    claimFinancial?: boolean | BranchCountOutputTypeCountClaimFinancialArgs
  }

  // Custom InputTypes

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentWhereInput
  }


  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountClaimFinancialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimFinancialWhereInput
  }



  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    employment: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | GroupCountOutputTypeCountEmploymentArgs
  }

  // Custom InputTypes

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentWhereInput
  }



  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    employment: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | RegionCountOutputTypeCountEmploymentArgs
  }

  // Custom InputTypes

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountEmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentWhereInput
  }



  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    programParticipations: number
    claimType: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programParticipations?: boolean | ProgramCountOutputTypeCountProgramParticipationsArgs
    claimType?: boolean | ProgramCountOutputTypeCountClaimTypeArgs
  }

  // Custom InputTypes

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountProgramParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
  }


  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountClaimTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimTypeWhereInput
  }



  /**
   * Count Type ClaimCountOutputType
   */

  export type ClaimCountOutputType = {
    tags: number
    claimStatuses: number
  }

  export type ClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | ClaimCountOutputTypeCountTagsArgs
    claimStatuses?: boolean | ClaimCountOutputTypeCountClaimStatusesArgs
  }

  // Custom InputTypes

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimCountOutputType
     */
    select?: ClaimCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountClaimStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimStatusWhereInput
  }



  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    Claims: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Claims?: boolean | TagCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }



  /**
   * Count Type ClaimProcessCountOutputType
   */

  export type ClaimProcessCountOutputType = {
    documents: number
  }

  export type ClaimProcessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ClaimProcessCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * ClaimProcessCountOutputType without action
   */
  export type ClaimProcessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcessCountOutputType
     */
    select?: ClaimProcessCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClaimProcessCountOutputType without action
   */
  export type ClaimProcessCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type DiseaseCountOutputType
   */

  export type DiseaseCountOutputType = {
    claims: number
  }

  export type DiseaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | DiseaseCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes

  /**
   * DiseaseCountOutputType without action
   */
  export type DiseaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiseaseCountOutputType
     */
    select?: DiseaseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DiseaseCountOutputType without action
   */
  export type DiseaseCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }



  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    claims: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | ClinicCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }



  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    transactions: number
    programParticipation: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AccountCountOutputTypeCountTransactionsArgs
    programParticipation?: boolean | AccountCountOutputTypeCountProgramParticipationArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountProgramParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    roleId: number | null
    participantId: number | null
  }

  export type UserSumAggregateOutputType = {
    roleId: number | null
    participantId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    emailVerifiedAt: Date | null
    password: string | null
    profilePictureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    roleId: number | null
    participantId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    emailVerifiedAt: Date | null
    password: string | null
    profilePictureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    roleId: number | null
    participantId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    emailVerifiedAt: number
    password: number
    profilePictureUrl: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    roleId: number
    participantId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    roleId?: true
    participantId?: true
  }

  export type UserSumAggregateInputType = {
    roleId?: true
    participantId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    profilePictureUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    roleId?: true
    participantId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    profilePictureUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    roleId?: true
    participantId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    emailVerifiedAt?: true
    password?: true
    profilePictureUrl?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    roleId?: true
    participantId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    fullName: string
    email: string
    emailVerifiedAt: Date | null
    password: string
    profilePictureUrl: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    roleId: number
    participantId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    profilePictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    participantId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
    claimsInput?: boolean | User$claimsInputArgs<ExtArgs>
    claimActions?: boolean | User$claimActionsArgs<ExtArgs>
    announcementCreated?: boolean | User$announcementCreatedArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    profilePictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    roleId?: boolean
    participantId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    participant?: boolean | User$participantArgs<ExtArgs>
    claimsInput?: boolean | User$claimsInputArgs<ExtArgs>
    claimActions?: boolean | User$claimActionsArgs<ExtArgs>
    announcementCreated?: boolean | User$announcementCreatedArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs> | null
      claimsInput: Prisma.$ClaimPayload<ExtArgs>[]
      claimActions: Prisma.$ClaimStatusPayload<ExtArgs>[]
      announcementCreated: Prisma.$AnnouncementPayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Nama Lengkap
       */
      fullName: string
      email: string
      emailVerifiedAt: Date | null
      password: string
      profilePictureUrl: string | null
      /**
       * @HideField({ output: false, input: true })
       * Tgl.Masuk Peserta
       */
      createdAt: Date
      /**
       * @HideField({ output: false, input: true })
       */
      updatedAt: Date
      deletedAt: Date | null
      roleId: number
      participantId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    participant<T extends User$participantArgs<ExtArgs> = {}>(args?: Subset<T, User$participantArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claimsInput<T extends User$claimsInputArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsInputArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    claimActions<T extends User$claimActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$claimActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    announcementCreated<T extends User$announcementCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findMany'> | Null>;

    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly profilePictureUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly participantId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.participant
   */
  export type User$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }


  /**
   * User.claimsInput
   */
  export type User$claimsInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * User.claimActions
   */
  export type User$claimActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    cursor?: ClaimStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimStatusScalarFieldEnum | ClaimStatusScalarFieldEnum[]
  }


  /**
   * User.announcementCreated
   */
  export type User$announcementCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }


  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
    order: number | null
    higherLevelThanId: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
    order: number | null
    higherLevelThanId: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    order: number | null
    higherLevelThanId: number | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    order: number | null
    higherLevelThanId: number | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    higherLevelThanId: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
    order?: true
    higherLevelThanId?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
    order?: true
    higherLevelThanId?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    higherLevelThanId?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    higherLevelThanId?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    higherLevelThanId?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    order: number
    higherLevelThanId: number | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    higherLevelThanId?: boolean
    higherLevelThan?: boolean | Role$higherLevelThanArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    lowerLevelThan?: boolean | Role$lowerLevelThanArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    higherLevelThanId?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    higherLevelThan?: boolean | Role$higherLevelThanArgs<ExtArgs>
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    lowerLevelThan?: boolean | Role$lowerLevelThanArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      higherLevelThan: Prisma.$RolePayload<ExtArgs> | null
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      lowerLevelThan: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * E.g., 'superuser', 'analyst', 'group leader'
       */
      name: string
      description: string | null
      order: number
      higherLevelThanId: number | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }


  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    higherLevelThan<T extends Role$higherLevelThanArgs<ExtArgs> = {}>(args?: Subset<T, Role$higherLevelThanArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    lowerLevelThan<T extends Role$lowerLevelThanArgs<ExtArgs> = {}>(args?: Subset<T, Role$lowerLevelThanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly order: FieldRef<"Role", 'Int'>
    readonly higherLevelThanId: FieldRef<"Role", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.higherLevelThan
   */
  export type Role$higherLevelThanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }


  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }


  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Role.lowerLevelThan
   */
  export type Role$lowerLevelThanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }


  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude<ExtArgs> | null
  }



  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    roleId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    roleId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: number | null
    permission: $Enums.Permission | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: number | null
    permission: $Enums.Permission | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permission: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    roleId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    roleId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permission?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permission?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permission?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: number
    permission: $Enums.Permission
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permission?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permission?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }


  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permission: $Enums.Permission
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }


  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolePermissionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolePermissionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
    **/
    findMany<T extends RolePermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
    **/
    create<T extends RolePermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RolePermissions.
     *     @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     *     @example
     *     // Create many RolePermissions
     *     const rolePermission = await prisma.rolePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolePermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
    **/
    delete<T extends RolePermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolePermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolePermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolePermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
    **/
    upsert<T extends RolePermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>
    ): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permission: FieldRef<"RolePermission", 'Permission'>
  }
    

  // Custom InputTypes

  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }


  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }


  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }


  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }


  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }


  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }


  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }


  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }



  /**
   * Model Participant
   */

  export type AggregateParticipant = {
    _count: ParticipantCountAggregateOutputType | null
    _avg: ParticipantAvgAggregateOutputType | null
    _sum: ParticipantSumAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  export type ParticipantAvgAggregateOutputType = {
    bankAccountId: number | null
  }

  export type ParticipantSumAggregateOutputType = {
    bankAccountId: number | null
  }

  export type ParticipantMinAggregateOutputType = {
    gender: $Enums.Gender | null
    birthDate: Date | null
    isActive: boolean | null
    status: $Enums.ParticipantStatus | null
    userId: string | null
    relationId: string | null
    bankAccountId: number | null
  }

  export type ParticipantMaxAggregateOutputType = {
    gender: $Enums.Gender | null
    birthDate: Date | null
    isActive: boolean | null
    status: $Enums.ParticipantStatus | null
    userId: string | null
    relationId: string | null
    bankAccountId: number | null
  }

  export type ParticipantCountAggregateOutputType = {
    gender: number
    birthDate: number
    isActive: number
    status: number
    userId: number
    relationId: number
    bankAccountId: number
    _all: number
  }


  export type ParticipantAvgAggregateInputType = {
    bankAccountId?: true
  }

  export type ParticipantSumAggregateInputType = {
    bankAccountId?: true
  }

  export type ParticipantMinAggregateInputType = {
    gender?: true
    birthDate?: true
    isActive?: true
    status?: true
    userId?: true
    relationId?: true
    bankAccountId?: true
  }

  export type ParticipantMaxAggregateInputType = {
    gender?: true
    birthDate?: true
    isActive?: true
    status?: true
    userId?: true
    relationId?: true
    bankAccountId?: true
  }

  export type ParticipantCountAggregateInputType = {
    gender?: true
    birthDate?: true
    isActive?: true
    status?: true
    userId?: true
    relationId?: true
    bankAccountId?: true
    _all?: true
  }

  export type ParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participant to aggregate.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participants
    **/
    _count?: true | ParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantMaxAggregateInputType
  }

  export type GetParticipantAggregateType<T extends ParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipant[P]>
      : GetScalarType<T[P], AggregateParticipant[P]>
  }




  export type ParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithAggregationInput | ParticipantOrderByWithAggregationInput[]
    by: ParticipantScalarFieldEnum[] | ParticipantScalarFieldEnum
    having?: ParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantCountAggregateInputType | true
    _avg?: ParticipantAvgAggregateInputType
    _sum?: ParticipantSumAggregateInputType
    _min?: ParticipantMinAggregateInputType
    _max?: ParticipantMaxAggregateInputType
  }

  export type ParticipantGroupByOutputType = {
    gender: $Enums.Gender
    birthDate: Date
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId: string | null
    bankAccountId: number
    _count: ParticipantCountAggregateOutputType | null
    _avg: ParticipantAvgAggregateOutputType | null
    _sum: ParticipantSumAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  type GetParticipantGroupByPayload<T extends ParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gender?: boolean
    birthDate?: boolean
    isActive?: boolean
    status?: boolean
    userId?: boolean
    relationId?: boolean
    bankAccountId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relation?: boolean | Participant$relationArgs<ExtArgs>
    bankAccount?: boolean | Participant$bankAccountArgs<ExtArgs>
    claims?: boolean | Participant$claimsArgs<ExtArgs>
    employments?: boolean | Participant$employmentsArgs<ExtArgs>
    contactInfos?: boolean | Participant$contactInfosArgs<ExtArgs>
    programParticipations?: boolean | Participant$programParticipationsArgs<ExtArgs>
    balances?: boolean | Participant$balancesArgs<ExtArgs>
    Participant?: boolean | Participant$ParticipantArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectScalar = {
    gender?: boolean
    birthDate?: boolean
    isActive?: boolean
    status?: boolean
    userId?: boolean
    relationId?: boolean
    bankAccountId?: boolean
  }

  export type ParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relation?: boolean | Participant$relationArgs<ExtArgs>
    bankAccount?: boolean | Participant$bankAccountArgs<ExtArgs>
    claims?: boolean | Participant$claimsArgs<ExtArgs>
    employments?: boolean | Participant$employmentsArgs<ExtArgs>
    contactInfos?: boolean | Participant$contactInfosArgs<ExtArgs>
    programParticipations?: boolean | Participant$programParticipationsArgs<ExtArgs>
    balances?: boolean | Participant$balancesArgs<ExtArgs>
    Participant?: boolean | Participant$ParticipantArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Participant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      /**
       * Anggota keluarga dari
       */
      relation: Prisma.$ParticipantPayload<ExtArgs> | null
      bankAccount: Prisma.$BankAccountPayload<ExtArgs> | null
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      employments: Prisma.$EmploymentPayload<ExtArgs>[]
      contactInfos: Prisma.$ContactInfoPayload<ExtArgs>[]
      programParticipations: Prisma.$ProgramParticipationPayload<ExtArgs>[]
      balances: Prisma.$AccountPayload<ExtArgs>[]
      /**
       * Anggota keluarga dari
       */
      Participant: Prisma.$ParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Jenis Kelamin
       */
      gender: $Enums.Gender
      /**
       * Tanggal Lahir
       */
      birthDate: Date
      /**
       * Aktif/Non Aktif:	Status Kepesertaan Aktif/non aktif
       */
      isActive: boolean
      /**
       * Pensiunan,Pasangan, Yatim, Janda/duda 6 bulan
       */
      status: $Enums.ParticipantStatus
      userId: string
      relationId: string | null
      bankAccountId: number
    }, ExtArgs["result"]["participant"]>
    composites: {}
  }


  type ParticipantGetPayload<S extends boolean | null | undefined | ParticipantDefaultArgs> = $Result.GetResult<Prisma.$ParticipantPayload, S>

  type ParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParticipantFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ParticipantCountAggregateInputType | true
    }

  export interface ParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Participant'], meta: { name: 'Participant' } }
    /**
     * Find zero or one Participant that matches the filter.
     * @param {ParticipantFindUniqueArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParticipantFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantFindUniqueArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Participant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ParticipantFindUniqueOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ParticipantFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParticipantFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantFindFirstArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Participant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ParticipantFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participant.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participant.findMany({ take: 10 })
     * 
     * // Only select the `birthDate`
     * const participantWithBirthDateOnly = await prisma.participant.findMany({ select: { birthDate: true } })
     * 
    **/
    findMany<T extends ParticipantFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Participant.
     * @param {ParticipantCreateArgs} args - Arguments to create a Participant.
     * @example
     * // Create one Participant
     * const Participant = await prisma.participant.create({
     *   data: {
     *     // ... data to create a Participant
     *   }
     * })
     * 
    **/
    create<T extends ParticipantCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantCreateArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Participants.
     *     @param {ParticipantCreateManyArgs} args - Arguments to create many Participants.
     *     @example
     *     // Create many Participants
     *     const participant = await prisma.participant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParticipantCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Participant.
     * @param {ParticipantDeleteArgs} args - Arguments to delete one Participant.
     * @example
     * // Delete one Participant
     * const Participant = await prisma.participant.delete({
     *   where: {
     *     // ... filter to delete one Participant
     *   }
     * })
     * 
    **/
    delete<T extends ParticipantDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantDeleteArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Participant.
     * @param {ParticipantUpdateArgs} args - Arguments to update one Participant.
     * @example
     * // Update one Participant
     * const participant = await prisma.participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParticipantUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantUpdateArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Participants.
     * @param {ParticipantDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParticipantDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ParticipantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParticipantUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Participant.
     * @param {ParticipantUpsertArgs} args - Arguments to update or create a Participant.
     * @example
     * // Update or create a Participant
     * const participant = await prisma.participant.upsert({
     *   create: {
     *     // ... data to create a Participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participant we want to update
     *   }
     * })
    **/
    upsert<T extends ParticipantUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ParticipantUpsertArgs<ExtArgs>>
    ): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participant.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends ParticipantCountArgs>(
      args?: Subset<T, ParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantAggregateArgs>(args: Subset<T, ParticipantAggregateArgs>): Prisma.PrismaPromise<GetParticipantAggregateType<T>>

    /**
     * Group by Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Participant model
   */
  readonly fields: ParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    relation<T extends Participant$relationArgs<ExtArgs> = {}>(args?: Subset<T, Participant$relationArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bankAccount<T extends Participant$bankAccountArgs<ExtArgs> = {}>(args?: Subset<T, Participant$bankAccountArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claims<T extends Participant$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    employments<T extends Participant$employmentsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$employmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    contactInfos<T extends Participant$contactInfosArgs<ExtArgs> = {}>(args?: Subset<T, Participant$contactInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findMany'> | Null>;

    programParticipations<T extends Participant$programParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Participant$programParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findMany'> | Null>;

    balances<T extends Participant$balancesArgs<ExtArgs> = {}>(args?: Subset<T, Participant$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    Participant<T extends Participant$ParticipantArgs<ExtArgs> = {}>(args?: Subset<T, Participant$ParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Participant model
   */ 
  interface ParticipantFieldRefs {
    readonly gender: FieldRef<"Participant", 'Gender'>
    readonly birthDate: FieldRef<"Participant", 'DateTime'>
    readonly isActive: FieldRef<"Participant", 'Boolean'>
    readonly status: FieldRef<"Participant", 'ParticipantStatus'>
    readonly userId: FieldRef<"Participant", 'String'>
    readonly relationId: FieldRef<"Participant", 'String'>
    readonly bankAccountId: FieldRef<"Participant", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Participant findUnique
   */
  export type ParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant findUniqueOrThrow
   */
  export type ParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant findFirst
   */
  export type ParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }


  /**
   * Participant findFirstOrThrow
   */
  export type ParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }


  /**
   * Participant findMany
   */
  export type ParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participants to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }


  /**
   * Participant create
   */
  export type ParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a Participant.
     */
    data: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
  }


  /**
   * Participant createMany
   */
  export type ParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Participant update
   */
  export type ParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a Participant.
     */
    data: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
    /**
     * Choose, which Participant to update.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant updateMany
   */
  export type ParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
  }


  /**
   * Participant upsert
   */
  export type ParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the Participant to update in case it exists.
     */
    where: ParticipantWhereUniqueInput
    /**
     * In case the Participant found by the `where` argument doesn't exist, create a new Participant with this data.
     */
    create: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
    /**
     * In case the Participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
  }


  /**
   * Participant delete
   */
  export type ParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter which Participant to delete.
     */
    where: ParticipantWhereUniqueInput
  }


  /**
   * Participant deleteMany
   */
  export type ParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participants to delete
     */
    where?: ParticipantWhereInput
  }


  /**
   * Participant.relation
   */
  export type Participant$relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }


  /**
   * Participant.bankAccount
   */
  export type Participant$bankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    where?: BankAccountWhereInput
  }


  /**
   * Participant.claims
   */
  export type Participant$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Participant.employments
   */
  export type Participant$employmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    where?: EmploymentWhereInput
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    cursor?: EmploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Participant.contactInfos
   */
  export type Participant$contactInfosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    where?: ContactInfoWhereInput
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    cursor?: ContactInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }


  /**
   * Participant.programParticipations
   */
  export type Participant$programParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    cursor?: ProgramParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * Participant.balances
   */
  export type Participant$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Participant.Participant
   */
  export type Participant$ParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    cursor?: ParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }


  /**
   * Participant without action
   */
  export type ParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ParticipantInclude<ExtArgs> | null
  }



  /**
   * Model ContactInfo
   */

  export type AggregateContactInfo = {
    _count: ContactInfoCountAggregateOutputType | null
    _avg: ContactInfoAvgAggregateOutputType | null
    _sum: ContactInfoSumAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  export type ContactInfoAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type ContactInfoSumAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type ContactInfoMinAggregateOutputType = {
    id: number | null
    telp: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    participantId: string | null
    addressId: number | null
  }

  export type ContactInfoMaxAggregateOutputType = {
    id: number | null
    telp: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    participantId: string | null
    addressId: number | null
  }

  export type ContactInfoCountAggregateOutputType = {
    id: number
    telp: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    participantId: number
    addressId: number
    _all: number
  }


  export type ContactInfoAvgAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type ContactInfoSumAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type ContactInfoMinAggregateInputType = {
    id?: true
    telp?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    participantId?: true
    addressId?: true
  }

  export type ContactInfoMaxAggregateInputType = {
    id?: true
    telp?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    participantId?: true
    addressId?: true
  }

  export type ContactInfoCountAggregateInputType = {
    id?: true
    telp?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    participantId?: true
    addressId?: true
    _all?: true
  }

  export type ContactInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfo to aggregate.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInfos
    **/
    _count?: true | ContactInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInfoMaxAggregateInputType
  }

  export type GetContactInfoAggregateType<T extends ContactInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInfo[P]>
      : GetScalarType<T[P], AggregateContactInfo[P]>
  }




  export type ContactInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInfoWhereInput
    orderBy?: ContactInfoOrderByWithAggregationInput | ContactInfoOrderByWithAggregationInput[]
    by: ContactInfoScalarFieldEnum[] | ContactInfoScalarFieldEnum
    having?: ContactInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInfoCountAggregateInputType | true
    _avg?: ContactInfoAvgAggregateInputType
    _sum?: ContactInfoSumAggregateInputType
    _min?: ContactInfoMinAggregateInputType
    _max?: ContactInfoMaxAggregateInputType
  }

  export type ContactInfoGroupByOutputType = {
    id: number
    telp: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    participantId: string
    addressId: number
    _count: ContactInfoCountAggregateOutputType | null
    _avg: ContactInfoAvgAggregateOutputType | null
    _sum: ContactInfoSumAggregateOutputType | null
    _min: ContactInfoMinAggregateOutputType | null
    _max: ContactInfoMaxAggregateOutputType | null
  }

  type GetContactInfoGroupByPayload<T extends ContactInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInfoGroupByOutputType[P]>
        }
      >
    >


  export type ContactInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    participantId?: boolean
    addressId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactInfo"]>

  export type ContactInfoSelectScalar = {
    id?: boolean
    telp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    participantId?: boolean
    addressId?: boolean
  }

  export type ContactInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }


  export type $ContactInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInfo"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
      address: Prisma.$AddressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telp: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      participantId: string
      addressId: number
    }, ExtArgs["result"]["contactInfo"]>
    composites: {}
  }


  type ContactInfoGetPayload<S extends boolean | null | undefined | ContactInfoDefaultArgs> = $Result.GetResult<Prisma.$ContactInfoPayload, S>

  type ContactInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactInfoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ContactInfoCountAggregateInputType | true
    }

  export interface ContactInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInfo'], meta: { name: 'ContactInfo' } }
    /**
     * Find zero or one ContactInfo that matches the filter.
     * @param {ContactInfoFindUniqueArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactInfoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContactInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactInfoFindUniqueOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactInfoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContactInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactInfoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoFindFirstArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContactInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindFirstOrThrowArgs} args - Arguments to find a ContactInfo
     * @example
     * // Get one ContactInfo
     * const contactInfo = await prisma.contactInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactInfoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContactInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany()
     * 
     * // Get first 10 ContactInfos
     * const contactInfos = await prisma.contactInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInfoWithIdOnly = await prisma.contactInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactInfoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContactInfo.
     * @param {ContactInfoCreateArgs} args - Arguments to create a ContactInfo.
     * @example
     * // Create one ContactInfo
     * const ContactInfo = await prisma.contactInfo.create({
     *   data: {
     *     // ... data to create a ContactInfo
     *   }
     * })
     * 
    **/
    create<T extends ContactInfoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoCreateArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContactInfos.
     *     @param {ContactInfoCreateManyArgs} args - Arguments to create many ContactInfos.
     *     @example
     *     // Create many ContactInfos
     *     const contactInfo = await prisma.contactInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactInfoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactInfo.
     * @param {ContactInfoDeleteArgs} args - Arguments to delete one ContactInfo.
     * @example
     * // Delete one ContactInfo
     * const ContactInfo = await prisma.contactInfo.delete({
     *   where: {
     *     // ... filter to delete one ContactInfo
     *   }
     * })
     * 
    **/
    delete<T extends ContactInfoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoDeleteArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContactInfo.
     * @param {ContactInfoUpdateArgs} args - Arguments to update one ContactInfo.
     * @example
     * // Update one ContactInfo
     * const contactInfo = await prisma.contactInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactInfoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoUpdateArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContactInfos.
     * @param {ContactInfoDeleteManyArgs} args - Arguments to filter ContactInfos to delete.
     * @example
     * // Delete a few ContactInfos
     * const { count } = await prisma.contactInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactInfoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInfos
     * const contactInfo = await prisma.contactInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactInfoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactInfo.
     * @param {ContactInfoUpsertArgs} args - Arguments to update or create a ContactInfo.
     * @example
     * // Update or create a ContactInfo
     * const contactInfo = await prisma.contactInfo.upsert({
     *   create: {
     *     // ... data to create a ContactInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInfo we want to update
     *   }
     * })
    **/
    upsert<T extends ContactInfoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactInfoUpsertArgs<ExtArgs>>
    ): Prisma__ContactInfoClient<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContactInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoCountArgs} args - Arguments to filter ContactInfos to count.
     * @example
     * // Count the number of ContactInfos
     * const count = await prisma.contactInfo.count({
     *   where: {
     *     // ... the filter for the ContactInfos we want to count
     *   }
     * })
    **/
    count<T extends ContactInfoCountArgs>(
      args?: Subset<T, ContactInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInfoAggregateArgs>(args: Subset<T, ContactInfoAggregateArgs>): Prisma.PrismaPromise<GetContactInfoAggregateType<T>>

    /**
     * Group by ContactInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInfoGroupByArgs['orderBy'] }
        : { orderBy?: ContactInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInfo model
   */
  readonly fields: ContactInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ContactInfo model
   */ 
  interface ContactInfoFieldRefs {
    readonly id: FieldRef<"ContactInfo", 'Int'>
    readonly telp: FieldRef<"ContactInfo", 'String'>
    readonly createdAt: FieldRef<"ContactInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactInfo", 'DateTime'>
    readonly deletedAt: FieldRef<"ContactInfo", 'DateTime'>
    readonly participantId: FieldRef<"ContactInfo", 'String'>
    readonly addressId: FieldRef<"ContactInfo", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ContactInfo findUnique
   */
  export type ContactInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }


  /**
   * ContactInfo findUniqueOrThrow
   */
  export type ContactInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where: ContactInfoWhereUniqueInput
  }


  /**
   * ContactInfo findFirst
   */
  export type ContactInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }


  /**
   * ContactInfo findFirstOrThrow
   */
  export type ContactInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfo to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInfos.
     */
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }


  /**
   * ContactInfo findMany
   */
  export type ContactInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter, which ContactInfos to fetch.
     */
    where?: ContactInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInfos to fetch.
     */
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInfos.
     */
    cursor?: ContactInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInfos.
     */
    skip?: number
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }


  /**
   * ContactInfo create
   */
  export type ContactInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactInfo.
     */
    data: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
  }


  /**
   * ContactInfo createMany
   */
  export type ContactInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInfos.
     */
    data: ContactInfoCreateManyInput | ContactInfoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContactInfo update
   */
  export type ContactInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactInfo.
     */
    data: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
    /**
     * Choose, which ContactInfo to update.
     */
    where: ContactInfoWhereUniqueInput
  }


  /**
   * ContactInfo updateMany
   */
  export type ContactInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInfos.
     */
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyInput>
    /**
     * Filter which ContactInfos to update
     */
    where?: ContactInfoWhereInput
  }


  /**
   * ContactInfo upsert
   */
  export type ContactInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactInfo to update in case it exists.
     */
    where: ContactInfoWhereUniqueInput
    /**
     * In case the ContactInfo found by the `where` argument doesn't exist, create a new ContactInfo with this data.
     */
    create: XOR<ContactInfoCreateInput, ContactInfoUncheckedCreateInput>
    /**
     * In case the ContactInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInfoUpdateInput, ContactInfoUncheckedUpdateInput>
  }


  /**
   * ContactInfo delete
   */
  export type ContactInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    /**
     * Filter which ContactInfo to delete.
     */
    where: ContactInfoWhereUniqueInput
  }


  /**
   * ContactInfo deleteMany
   */
  export type ContactInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInfos to delete
     */
    where?: ContactInfoWhereInput
  }


  /**
   * ContactInfo without action
   */
  export type ContactInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
  }



  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    cityId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    address: string | null
    cityId: number | null
    postalCode: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    address: string | null
    cityId: number | null
    postalCode: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    address: number
    cityId: number
    postalCode: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    cityId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    postalCode?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    postalCode?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    address?: true
    cityId?: true
    postalCode?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    address: string
    cityId: number
    postalCode: string
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    cityId?: boolean
    postalCode?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    ContactInfo?: boolean | Address$ContactInfoArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    address?: boolean
    cityId?: boolean
    postalCode?: boolean
  }

  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    ContactInfo?: boolean | Address$ContactInfoArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      /**
       * Kota
       */
      city: Prisma.$CityPayload<ExtArgs>
      ContactInfo: Prisma.$ContactInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Alamat
       */
      address: string
      /**
       * Kota
       */
      cityId: number
      /**
       * Kode Pos
       */
      postalCode: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ContactInfo<T extends Address$ContactInfoArgs<ExtArgs> = {}>(args?: Subset<T, Address$ContactInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInfoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly address: FieldRef<"Address", 'String'>
    readonly cityId: FieldRef<"Address", 'Int'>
    readonly postalCode: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }


  /**
   * Address.ContactInfo
   */
  export type Address$ContactInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInfo
     */
    select?: ContactInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInfoInclude<ExtArgs> | null
    where?: ContactInfoWhereInput
    orderBy?: ContactInfoOrderByWithRelationInput | ContactInfoOrderByWithRelationInput[]
    cursor?: ContactInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactInfoScalarFieldEnum | ContactInfoScalarFieldEnum[]
  }


  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
  }



  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    address?: boolean | City$addressArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | City$addressArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Nama Kota
       */
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }


  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CityCreateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CityDeleteArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpsertArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends City$addressArgs<ExtArgs> = {}>(args?: Subset<T, City$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'Int'>
    readonly name: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }


  /**
   * City.address
   */
  export type City$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
  }



  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    id: number | null
    accountNumber: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    id: number | null
    accountNumber: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: number | null
    accountNumber: number | null
    accountName: string | null
    participantId: string | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: number | null
    accountNumber: number | null
    accountName: string | null
    participantId: string | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    accountNumber: number
    accountName: number
    participantId: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    id?: true
    accountNumber?: true
  }

  export type BankAccountSumAggregateInputType = {
    id?: true
    accountNumber?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    accountNumber?: true
    accountName?: true
    participantId?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    accountNumber?: true
    accountName?: true
    participantId?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    accountNumber?: true
    accountName?: true
    participantId?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: number
    accountNumber: number
    accountName: string
    participantId: string
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountNumber?: boolean
    accountName?: boolean
    participantId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    accountNumber?: boolean
    accountName?: boolean
    participantId?: boolean
  }

  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
  }


  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * No. Rekening	Nomer Rekening Penerimaan Manfaat Pensiun
       */
      accountNumber: number
      /**
       * Rekening a/n.	Nama pada rekening bank
       */
      accountName: string
      participantId: string
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }


  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankAccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BankAccount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankAccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankAccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
    **/
    create<T extends BankAccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BankAccounts.
     *     @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     *     @example
     *     // Create many BankAccounts
     *     const bankAccount = await prisma.bankAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankAccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
    **/
    delete<T extends BankAccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankAccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankAccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankAccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
    **/
    upsert<T extends BankAccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>
    ): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BankAccount model
   */ 
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'Int'>
    readonly accountNumber: FieldRef<"BankAccount", 'Float'>
    readonly accountName: FieldRef<"BankAccount", 'String'>
    readonly participantId: FieldRef<"BankAccount", 'String'>
  }
    

  // Custom InputTypes

  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }


  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }


  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }


  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }


  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }


  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }


  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
  }


  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankAccountInclude<ExtArgs> | null
  }



  /**
   * Model Employment
   */

  export type AggregateEmployment = {
    _count: EmploymentCountAggregateOutputType | null
    _avg: EmploymentAvgAggregateOutputType | null
    _sum: EmploymentSumAggregateOutputType | null
    _min: EmploymentMinAggregateOutputType | null
    _max: EmploymentMaxAggregateOutputType | null
  }

  export type EmploymentAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    groupId: number | null
    regionId: number | null
  }

  export type EmploymentSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    groupId: number | null
    regionId: number | null
  }

  export type EmploymentMinAggregateOutputType = {
    id: number | null
    employmentPosition: $Enums.Position | null
    participantId: string | null
    branchId: number | null
    groupId: number | null
    regionId: number | null
  }

  export type EmploymentMaxAggregateOutputType = {
    id: number | null
    employmentPosition: $Enums.Position | null
    participantId: string | null
    branchId: number | null
    groupId: number | null
    regionId: number | null
  }

  export type EmploymentCountAggregateOutputType = {
    id: number
    employmentPosition: number
    participantId: number
    branchId: number
    groupId: number
    regionId: number
    _all: number
  }


  export type EmploymentAvgAggregateInputType = {
    id?: true
    branchId?: true
    groupId?: true
    regionId?: true
  }

  export type EmploymentSumAggregateInputType = {
    id?: true
    branchId?: true
    groupId?: true
    regionId?: true
  }

  export type EmploymentMinAggregateInputType = {
    id?: true
    employmentPosition?: true
    participantId?: true
    branchId?: true
    groupId?: true
    regionId?: true
  }

  export type EmploymentMaxAggregateInputType = {
    id?: true
    employmentPosition?: true
    participantId?: true
    branchId?: true
    groupId?: true
    regionId?: true
  }

  export type EmploymentCountAggregateInputType = {
    id?: true
    employmentPosition?: true
    participantId?: true
    branchId?: true
    groupId?: true
    regionId?: true
    _all?: true
  }

  export type EmploymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employment to aggregate.
     */
    where?: EmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employments to fetch.
     */
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employments
    **/
    _count?: true | EmploymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentMaxAggregateInputType
  }

  export type GetEmploymentAggregateType<T extends EmploymentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployment[P]>
      : GetScalarType<T[P], AggregateEmployment[P]>
  }




  export type EmploymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentWhereInput
    orderBy?: EmploymentOrderByWithAggregationInput | EmploymentOrderByWithAggregationInput[]
    by: EmploymentScalarFieldEnum[] | EmploymentScalarFieldEnum
    having?: EmploymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentCountAggregateInputType | true
    _avg?: EmploymentAvgAggregateInputType
    _sum?: EmploymentSumAggregateInputType
    _min?: EmploymentMinAggregateInputType
    _max?: EmploymentMaxAggregateInputType
  }

  export type EmploymentGroupByOutputType = {
    id: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    groupId: number
    regionId: number
    _count: EmploymentCountAggregateOutputType | null
    _avg: EmploymentAvgAggregateOutputType | null
    _sum: EmploymentSumAggregateOutputType | null
    _min: EmploymentMinAggregateOutputType | null
    _max: EmploymentMaxAggregateOutputType | null
  }

  type GetEmploymentGroupByPayload<T extends EmploymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employmentPosition?: boolean
    participantId?: boolean
    branchId?: boolean
    groupId?: boolean
    regionId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    group?: boolean | Employment$groupArgs<ExtArgs>
    region?: boolean | Employment$regionArgs<ExtArgs>
  }, ExtArgs["result"]["employment"]>

  export type EmploymentSelectScalar = {
    id?: boolean
    employmentPosition?: boolean
    participantId?: boolean
    branchId?: boolean
    groupId?: boolean
    regionId?: boolean
  }

  export type EmploymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    group?: boolean | Employment$groupArgs<ExtArgs>
    region?: boolean | Employment$regionArgs<ExtArgs>
  }


  export type $EmploymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employment"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs> | null
      region: Prisma.$RegionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Jenjang Jabatan terakhir
       */
      employmentPosition: $Enums.Position
      participantId: string
      branchId: number
      groupId: number
      regionId: number
    }, ExtArgs["result"]["employment"]>
    composites: {}
  }


  type EmploymentGetPayload<S extends boolean | null | undefined | EmploymentDefaultArgs> = $Result.GetResult<Prisma.$EmploymentPayload, S>

  type EmploymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmploymentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmploymentCountAggregateInputType | true
    }

  export interface EmploymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employment'], meta: { name: 'Employment' } }
    /**
     * Find zero or one Employment that matches the filter.
     * @param {EmploymentFindUniqueArgs} args - Arguments to find a Employment
     * @example
     * // Get one Employment
     * const employment = await prisma.employment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmploymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentFindUniqueArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Employment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmploymentFindUniqueOrThrowArgs} args - Arguments to find a Employment
     * @example
     * // Get one Employment
     * const employment = await prisma.employment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmploymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Employment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentFindFirstArgs} args - Arguments to find a Employment
     * @example
     * // Get one Employment
     * const employment = await prisma.employment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmploymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentFindFirstArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Employment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentFindFirstOrThrowArgs} args - Arguments to find a Employment
     * @example
     * // Get one Employment
     * const employment = await prisma.employment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmploymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Employments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employments
     * const employments = await prisma.employment.findMany()
     * 
     * // Get first 10 Employments
     * const employments = await prisma.employment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmentWithIdOnly = await prisma.employment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmploymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Employment.
     * @param {EmploymentCreateArgs} args - Arguments to create a Employment.
     * @example
     * // Create one Employment
     * const Employment = await prisma.employment.create({
     *   data: {
     *     // ... data to create a Employment
     *   }
     * })
     * 
    **/
    create<T extends EmploymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentCreateArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Employments.
     *     @param {EmploymentCreateManyArgs} args - Arguments to create many Employments.
     *     @example
     *     // Create many Employments
     *     const employment = await prisma.employment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmploymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employment.
     * @param {EmploymentDeleteArgs} args - Arguments to delete one Employment.
     * @example
     * // Delete one Employment
     * const Employment = await prisma.employment.delete({
     *   where: {
     *     // ... filter to delete one Employment
     *   }
     * })
     * 
    **/
    delete<T extends EmploymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentDeleteArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Employment.
     * @param {EmploymentUpdateArgs} args - Arguments to update one Employment.
     * @example
     * // Update one Employment
     * const employment = await prisma.employment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmploymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentUpdateArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Employments.
     * @param {EmploymentDeleteManyArgs} args - Arguments to filter Employments to delete.
     * @example
     * // Delete a few Employments
     * const { count } = await prisma.employment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmploymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmploymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employments
     * const employment = await prisma.employment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmploymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employment.
     * @param {EmploymentUpsertArgs} args - Arguments to update or create a Employment.
     * @example
     * // Update or create a Employment
     * const employment = await prisma.employment.upsert({
     *   create: {
     *     // ... data to create a Employment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employment we want to update
     *   }
     * })
    **/
    upsert<T extends EmploymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmploymentUpsertArgs<ExtArgs>>
    ): Prisma__EmploymentClient<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Employments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentCountArgs} args - Arguments to filter Employments to count.
     * @example
     * // Count the number of Employments
     * const count = await prisma.employment.count({
     *   where: {
     *     // ... the filter for the Employments we want to count
     *   }
     * })
    **/
    count<T extends EmploymentCountArgs>(
      args?: Subset<T, EmploymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentAggregateArgs>(args: Subset<T, EmploymentAggregateArgs>): Prisma.PrismaPromise<GetEmploymentAggregateType<T>>

    /**
     * Group by Employment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employment model
   */
  readonly fields: EmploymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    group<T extends Employment$groupArgs<ExtArgs> = {}>(args?: Subset<T, Employment$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    region<T extends Employment$regionArgs<ExtArgs> = {}>(args?: Subset<T, Employment$regionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Employment model
   */ 
  interface EmploymentFieldRefs {
    readonly id: FieldRef<"Employment", 'Int'>
    readonly employmentPosition: FieldRef<"Employment", 'Position'>
    readonly participantId: FieldRef<"Employment", 'String'>
    readonly branchId: FieldRef<"Employment", 'Int'>
    readonly groupId: FieldRef<"Employment", 'Int'>
    readonly regionId: FieldRef<"Employment", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Employment findUnique
   */
  export type EmploymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter, which Employment to fetch.
     */
    where: EmploymentWhereUniqueInput
  }


  /**
   * Employment findUniqueOrThrow
   */
  export type EmploymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter, which Employment to fetch.
     */
    where: EmploymentWhereUniqueInput
  }


  /**
   * Employment findFirst
   */
  export type EmploymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter, which Employment to fetch.
     */
    where?: EmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employments to fetch.
     */
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employments.
     */
    cursor?: EmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employments.
     */
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Employment findFirstOrThrow
   */
  export type EmploymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter, which Employment to fetch.
     */
    where?: EmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employments to fetch.
     */
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employments.
     */
    cursor?: EmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employments.
     */
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Employment findMany
   */
  export type EmploymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter, which Employments to fetch.
     */
    where?: EmploymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employments to fetch.
     */
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employments.
     */
    cursor?: EmploymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employments.
     */
    skip?: number
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Employment create
   */
  export type EmploymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Employment.
     */
    data: XOR<EmploymentCreateInput, EmploymentUncheckedCreateInput>
  }


  /**
   * Employment createMany
   */
  export type EmploymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employments.
     */
    data: EmploymentCreateManyInput | EmploymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Employment update
   */
  export type EmploymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Employment.
     */
    data: XOR<EmploymentUpdateInput, EmploymentUncheckedUpdateInput>
    /**
     * Choose, which Employment to update.
     */
    where: EmploymentWhereUniqueInput
  }


  /**
   * Employment updateMany
   */
  export type EmploymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employments.
     */
    data: XOR<EmploymentUpdateManyMutationInput, EmploymentUncheckedUpdateManyInput>
    /**
     * Filter which Employments to update
     */
    where?: EmploymentWhereInput
  }


  /**
   * Employment upsert
   */
  export type EmploymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Employment to update in case it exists.
     */
    where: EmploymentWhereUniqueInput
    /**
     * In case the Employment found by the `where` argument doesn't exist, create a new Employment with this data.
     */
    create: XOR<EmploymentCreateInput, EmploymentUncheckedCreateInput>
    /**
     * In case the Employment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentUpdateInput, EmploymentUncheckedUpdateInput>
  }


  /**
   * Employment delete
   */
  export type EmploymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    /**
     * Filter which Employment to delete.
     */
    where: EmploymentWhereUniqueInput
  }


  /**
   * Employment deleteMany
   */
  export type EmploymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employments to delete
     */
    where?: EmploymentWhereInput
  }


  /**
   * Employment.group
   */
  export type Employment$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }


  /**
   * Employment.region
   */
  export type Employment$regionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }


  /**
   * Employment without action
   */
  export type EmploymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
  }



  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employment?: boolean | Branch$employmentArgs<ExtArgs>
    claimFinancial?: boolean | Branch$claimFinancialArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | Branch$employmentArgs<ExtArgs>
    claimFinancial?: boolean | Branch$claimFinancialArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      employment: Prisma.$EmploymentPayload<ExtArgs>[]
      claimFinancial: Prisma.$ClaimFinancialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Nama Cabang
       */
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }


  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BranchFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BranchFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BranchFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
    **/
    create<T extends BranchCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchCreateArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Branches.
     *     @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     *     @example
     *     // Create many Branches
     *     const branch = await prisma.branch.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BranchCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
    **/
    delete<T extends BranchDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BranchUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BranchDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BranchUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
    **/
    upsert<T extends BranchUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>
    ): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    employment<T extends Branch$employmentArgs<ExtArgs> = {}>(args?: Subset<T, Branch$employmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    claimFinancial<T extends Branch$claimFinancialArgs<ExtArgs> = {}>(args?: Subset<T, Branch$claimFinancialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }


  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }


  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }


  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }


  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }


  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }


  /**
   * Branch.employment
   */
  export type Branch$employmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    where?: EmploymentWhereInput
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    cursor?: EmploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Branch.claimFinancial
   */
  export type Branch$claimFinancialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    where?: ClaimFinancialWhereInput
    orderBy?: ClaimFinancialOrderByWithRelationInput | ClaimFinancialOrderByWithRelationInput[]
    cursor?: ClaimFinancialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimFinancialScalarFieldEnum | ClaimFinancialScalarFieldEnum[]
  }


  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BranchInclude<ExtArgs> | null
  }



  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employment?: boolean | Group$employmentArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | Group$employmentArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      employment: Prisma.$EmploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }


  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends GroupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupCreateArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups.
     *     @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends GroupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends GroupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>
    ): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    employment<T extends Group$employmentArgs<ExtArgs> = {}>(args?: Subset<T, Group$employmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly name: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }


  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }


  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }


  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }


  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }


  /**
   * Group.employment
   */
  export type Group$employmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    where?: EmploymentWhereInput
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    cursor?: EmploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GroupInclude<ExtArgs> | null
  }



  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employment?: boolean | Region$employmentArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employment?: boolean | Region$employmentArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      employment: Prisma.$EmploymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["region"]>
    composites: {}
  }


  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RegionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Region that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RegionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RegionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
    **/
    create<T extends RegionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionCreateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Regions.
     *     @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     *     @example
     *     // Create many Regions
     *     const region = await prisma.region.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RegionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
    **/
    delete<T extends RegionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RegionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RegionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RegionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
    **/
    upsert<T extends RegionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>
    ): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    employment<T extends Region$employmentArgs<ExtArgs> = {}>(args?: Subset<T, Region$employmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
    readonly createdAt: FieldRef<"Region", 'DateTime'>
    readonly updatedAt: FieldRef<"Region", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }


  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }


  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
  }


  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }


  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }


  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
  }


  /**
   * Region.employment
   */
  export type Region$employmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employment
     */
    select?: EmploymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmploymentInclude<ExtArgs> | null
    where?: EmploymentWhereInput
    orderBy?: EmploymentOrderByWithRelationInput | EmploymentOrderByWithRelationInput[]
    cursor?: EmploymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentScalarFieldEnum | EmploymentScalarFieldEnum[]
  }


  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RegionInclude<ExtArgs> | null
  }



  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementAvgAggregateOutputType = {
    id: number | null
  }

  export type AnnouncementSumAggregateOutputType = {
    id: number | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type AnnouncementAvgAggregateInputType = {
    id?: true
  }

  export type AnnouncementSumAggregateInputType = {
    id?: true
  }

  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _avg?: AnnouncementAvgAggregateInputType
    _sum?: AnnouncementSumAggregateInputType
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: number
    title: string
    content: string
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: AnnouncementCountAggregateOutputType | null
    _avg: AnnouncementAvgAggregateOutputType | null
    _sum: AnnouncementSumAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }


  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnnouncementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Announcement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnnouncementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnnouncementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
    **/
    create<T extends AnnouncementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Announcements.
     *     @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     *     @example
     *     // Create many Announcements
     *     const announcement = await prisma.announcement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnnouncementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
    **/
    delete<T extends AnnouncementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnnouncementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnnouncementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnnouncementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
    **/
    upsert<T extends AnnouncementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Announcement model
   */ 
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'Int'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly imageUrl: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
    readonly createdById: FieldRef<"Announcement", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }


  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }


  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }


  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }


  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }


  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }


  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }


  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
  }


  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }


  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }


  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
  }


  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }



  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    content: string | null
    createdAt: Date | null
    isRead: boolean | null
    isCleared: boolean | null
    deepLink: string | null
    fcmToken: string | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    content: string | null
    createdAt: Date | null
    isRead: boolean | null
    isCleared: boolean | null
    deepLink: string | null
    fcmToken: string | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    content: number
    createdAt: number
    isRead: number
    isCleared: number
    deepLink: number
    fcmToken: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    content?: true
    createdAt?: true
    isRead?: true
    isCleared?: true
    deepLink?: true
    fcmToken?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    content?: true
    createdAt?: true
    isRead?: true
    isCleared?: true
    deepLink?: true
    fcmToken?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    content?: true
    createdAt?: true
    isRead?: true
    isCleared?: true
    deepLink?: true
    fcmToken?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string
    subtitle: string
    content: string
    createdAt: Date
    isRead: boolean
    isCleared: boolean
    deepLink: string | null
    fcmToken: string | null
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    createdAt?: boolean
    isRead?: boolean
    isCleared?: boolean
    deepLink?: boolean
    fcmToken?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    createdAt?: boolean
    isRead?: boolean
    isCleared?: boolean
    deepLink?: boolean
    fcmToken?: boolean
    userId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * @Validator.IsNotEmpty()
       */
      title: string
      subtitle: string
      /**
       * @Validator.IsNotEmpty()
       */
      content: string
      createdAt: Date
      isRead: boolean
      isCleared: boolean
      deepLink: string | null
      fcmToken: string | null
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }


  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly subtitle: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly isCleared: FieldRef<"Notification", 'Boolean'>
    readonly deepLink: FieldRef<"Notification", 'String'>
    readonly fcmToken: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NotificationInclude<ExtArgs> | null
  }



  /**
   * Model ProgramParticipation
   */

  export type AggregateProgramParticipation = {
    _count: ProgramParticipationCountAggregateOutputType | null
    _avg: ProgramParticipationAvgAggregateOutputType | null
    _sum: ProgramParticipationSumAggregateOutputType | null
    _min: ProgramParticipationMinAggregateOutputType | null
    _max: ProgramParticipationMaxAggregateOutputType | null
  }

  export type ProgramParticipationAvgAggregateOutputType = {
    id: number | null
    fundingId: number | null
    programId: number | null
  }

  export type ProgramParticipationSumAggregateOutputType = {
    id: number | null
    fundingId: number | null
    programId: number | null
  }

  export type ProgramParticipationMinAggregateOutputType = {
    id: number | null
    bpjsNumber: string | null
    nonActiveReason: string | null
    effectiveDate: Date | null
    nonActiveDate: Date | null
    participantId: string | null
    fundingId: number | null
    programId: number | null
  }

  export type ProgramParticipationMaxAggregateOutputType = {
    id: number | null
    bpjsNumber: string | null
    nonActiveReason: string | null
    effectiveDate: Date | null
    nonActiveDate: Date | null
    participantId: string | null
    fundingId: number | null
    programId: number | null
  }

  export type ProgramParticipationCountAggregateOutputType = {
    id: number
    bpjsNumber: number
    nonActiveReason: number
    effectiveDate: number
    nonActiveDate: number
    participantId: number
    fundingId: number
    programId: number
    _all: number
  }


  export type ProgramParticipationAvgAggregateInputType = {
    id?: true
    fundingId?: true
    programId?: true
  }

  export type ProgramParticipationSumAggregateInputType = {
    id?: true
    fundingId?: true
    programId?: true
  }

  export type ProgramParticipationMinAggregateInputType = {
    id?: true
    bpjsNumber?: true
    nonActiveReason?: true
    effectiveDate?: true
    nonActiveDate?: true
    participantId?: true
    fundingId?: true
    programId?: true
  }

  export type ProgramParticipationMaxAggregateInputType = {
    id?: true
    bpjsNumber?: true
    nonActiveReason?: true
    effectiveDate?: true
    nonActiveDate?: true
    participantId?: true
    fundingId?: true
    programId?: true
  }

  export type ProgramParticipationCountAggregateInputType = {
    id?: true
    bpjsNumber?: true
    nonActiveReason?: true
    effectiveDate?: true
    nonActiveDate?: true
    participantId?: true
    fundingId?: true
    programId?: true
    _all?: true
  }

  export type ProgramParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramParticipation to aggregate.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramParticipations
    **/
    _count?: true | ProgramParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramParticipationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramParticipationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramParticipationMaxAggregateInputType
  }

  export type GetProgramParticipationAggregateType<T extends ProgramParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramParticipation[P]>
      : GetScalarType<T[P], AggregateProgramParticipation[P]>
  }




  export type ProgramParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithAggregationInput | ProgramParticipationOrderByWithAggregationInput[]
    by: ProgramParticipationScalarFieldEnum[] | ProgramParticipationScalarFieldEnum
    having?: ProgramParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramParticipationCountAggregateInputType | true
    _avg?: ProgramParticipationAvgAggregateInputType
    _sum?: ProgramParticipationSumAggregateInputType
    _min?: ProgramParticipationMinAggregateInputType
    _max?: ProgramParticipationMaxAggregateInputType
  }

  export type ProgramParticipationGroupByOutputType = {
    id: number
    bpjsNumber: string | null
    nonActiveReason: string | null
    effectiveDate: Date
    nonActiveDate: Date | null
    participantId: string
    fundingId: number
    programId: number | null
    _count: ProgramParticipationCountAggregateOutputType | null
    _avg: ProgramParticipationAvgAggregateOutputType | null
    _sum: ProgramParticipationSumAggregateOutputType | null
    _min: ProgramParticipationMinAggregateOutputType | null
    _max: ProgramParticipationMaxAggregateOutputType | null
  }

  type GetProgramParticipationGroupByPayload<T extends ProgramParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramParticipationGroupByOutputType[P]>
        }
      >
    >


  export type ProgramParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bpjsNumber?: boolean
    nonActiveReason?: boolean
    effectiveDate?: boolean
    nonActiveDate?: boolean
    participantId?: boolean
    fundingId?: boolean
    programId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    funding?: boolean | AccountDefaultArgs<ExtArgs>
    Program?: boolean | ProgramParticipation$ProgramArgs<ExtArgs>
  }, ExtArgs["result"]["programParticipation"]>

  export type ProgramParticipationSelectScalar = {
    id?: boolean
    bpjsNumber?: boolean
    nonActiveReason?: boolean
    effectiveDate?: boolean
    nonActiveDate?: boolean
    participantId?: boolean
    fundingId?: boolean
    programId?: boolean
  }

  export type ProgramParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    funding?: boolean | AccountDefaultArgs<ExtArgs>
    Program?: boolean | ProgramParticipation$ProgramArgs<ExtArgs>
  }


  export type $ProgramParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramParticipation"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
      /**
       * Dana
       */
      funding: Prisma.$AccountPayload<ExtArgs>
      Program: Prisma.$ProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Nopol:	Nomer Polish
       */
      id: number
      /**
       * No.BPJS/ASKES: Nomer kartu BPJS
       */
      bpjsNumber: string | null
      /**
       * Keterangan Non Aktif:	keterangan perihal penonaktifan
       */
      nonActiveReason: string | null
      /**
       * Tgl. Efektif: Tanggal mulai ikut program Fasilitas Kesehatan
       */
      effectiveDate: Date
      /**
       * Tgl Non Aktif:	tanggal penonaktifan peserta
       */
      nonActiveDate: Date | null
      participantId: string
      /**
       * Nomor Dana
       */
      fundingId: number
      programId: number | null
    }, ExtArgs["result"]["programParticipation"]>
    composites: {}
  }


  type ProgramParticipationGetPayload<S extends boolean | null | undefined | ProgramParticipationDefaultArgs> = $Result.GetResult<Prisma.$ProgramParticipationPayload, S>

  type ProgramParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramParticipationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProgramParticipationCountAggregateInputType | true
    }

  export interface ProgramParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramParticipation'], meta: { name: 'ProgramParticipation' } }
    /**
     * Find zero or one ProgramParticipation that matches the filter.
     * @param {ProgramParticipationFindUniqueArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgramParticipationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationFindUniqueArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProgramParticipation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProgramParticipationFindUniqueOrThrowArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProgramParticipationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProgramParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindFirstArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgramParticipationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationFindFirstArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProgramParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindFirstOrThrowArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProgramParticipationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProgramParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramParticipations
     * const programParticipations = await prisma.programParticipation.findMany()
     * 
     * // Get first 10 ProgramParticipations
     * const programParticipations = await prisma.programParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programParticipationWithIdOnly = await prisma.programParticipation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgramParticipationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProgramParticipation.
     * @param {ProgramParticipationCreateArgs} args - Arguments to create a ProgramParticipation.
     * @example
     * // Create one ProgramParticipation
     * const ProgramParticipation = await prisma.programParticipation.create({
     *   data: {
     *     // ... data to create a ProgramParticipation
     *   }
     * })
     * 
    **/
    create<T extends ProgramParticipationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationCreateArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProgramParticipations.
     *     @param {ProgramParticipationCreateManyArgs} args - Arguments to create many ProgramParticipations.
     *     @example
     *     // Create many ProgramParticipations
     *     const programParticipation = await prisma.programParticipation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgramParticipationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgramParticipation.
     * @param {ProgramParticipationDeleteArgs} args - Arguments to delete one ProgramParticipation.
     * @example
     * // Delete one ProgramParticipation
     * const ProgramParticipation = await prisma.programParticipation.delete({
     *   where: {
     *     // ... filter to delete one ProgramParticipation
     *   }
     * })
     * 
    **/
    delete<T extends ProgramParticipationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationDeleteArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProgramParticipation.
     * @param {ProgramParticipationUpdateArgs} args - Arguments to update one ProgramParticipation.
     * @example
     * // Update one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgramParticipationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationUpdateArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProgramParticipations.
     * @param {ProgramParticipationDeleteManyArgs} args - Arguments to filter ProgramParticipations to delete.
     * @example
     * // Delete a few ProgramParticipations
     * const { count } = await prisma.programParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgramParticipationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramParticipationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramParticipations
     * const programParticipation = await prisma.programParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgramParticipationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramParticipation.
     * @param {ProgramParticipationUpsertArgs} args - Arguments to update or create a ProgramParticipation.
     * @example
     * // Update or create a ProgramParticipation
     * const programParticipation = await prisma.programParticipation.upsert({
     *   create: {
     *     // ... data to create a ProgramParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramParticipation we want to update
     *   }
     * })
    **/
    upsert<T extends ProgramParticipationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramParticipationUpsertArgs<ExtArgs>>
    ): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProgramParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationCountArgs} args - Arguments to filter ProgramParticipations to count.
     * @example
     * // Count the number of ProgramParticipations
     * const count = await prisma.programParticipation.count({
     *   where: {
     *     // ... the filter for the ProgramParticipations we want to count
     *   }
     * })
    **/
    count<T extends ProgramParticipationCountArgs>(
      args?: Subset<T, ProgramParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramParticipationAggregateArgs>(args: Subset<T, ProgramParticipationAggregateArgs>): Prisma.PrismaPromise<GetProgramParticipationAggregateType<T>>

    /**
     * Group by ProgramParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramParticipationGroupByArgs['orderBy'] }
        : { orderBy?: ProgramParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramParticipation model
   */
  readonly fields: ProgramParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    funding<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Program<T extends ProgramParticipation$ProgramArgs<ExtArgs> = {}>(args?: Subset<T, ProgramParticipation$ProgramArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProgramParticipation model
   */ 
  interface ProgramParticipationFieldRefs {
    readonly id: FieldRef<"ProgramParticipation", 'Int'>
    readonly bpjsNumber: FieldRef<"ProgramParticipation", 'String'>
    readonly nonActiveReason: FieldRef<"ProgramParticipation", 'String'>
    readonly effectiveDate: FieldRef<"ProgramParticipation", 'DateTime'>
    readonly nonActiveDate: FieldRef<"ProgramParticipation", 'DateTime'>
    readonly participantId: FieldRef<"ProgramParticipation", 'String'>
    readonly fundingId: FieldRef<"ProgramParticipation", 'Int'>
    readonly programId: FieldRef<"ProgramParticipation", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ProgramParticipation findUnique
   */
  export type ProgramParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where: ProgramParticipationWhereUniqueInput
  }


  /**
   * ProgramParticipation findUniqueOrThrow
   */
  export type ProgramParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where: ProgramParticipationWhereUniqueInput
  }


  /**
   * ProgramParticipation findFirst
   */
  export type ProgramParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramParticipations.
     */
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * ProgramParticipation findFirstOrThrow
   */
  export type ProgramParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramParticipations.
     */
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * ProgramParticipation findMany
   */
  export type ProgramParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipations to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * ProgramParticipation create
   */
  export type ProgramParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramParticipation.
     */
    data: XOR<ProgramParticipationCreateInput, ProgramParticipationUncheckedCreateInput>
  }


  /**
   * ProgramParticipation createMany
   */
  export type ProgramParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramParticipations.
     */
    data: ProgramParticipationCreateManyInput | ProgramParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProgramParticipation update
   */
  export type ProgramParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramParticipation.
     */
    data: XOR<ProgramParticipationUpdateInput, ProgramParticipationUncheckedUpdateInput>
    /**
     * Choose, which ProgramParticipation to update.
     */
    where: ProgramParticipationWhereUniqueInput
  }


  /**
   * ProgramParticipation updateMany
   */
  export type ProgramParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramParticipations.
     */
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyInput>
    /**
     * Filter which ProgramParticipations to update
     */
    where?: ProgramParticipationWhereInput
  }


  /**
   * ProgramParticipation upsert
   */
  export type ProgramParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramParticipation to update in case it exists.
     */
    where: ProgramParticipationWhereUniqueInput
    /**
     * In case the ProgramParticipation found by the `where` argument doesn't exist, create a new ProgramParticipation with this data.
     */
    create: XOR<ProgramParticipationCreateInput, ProgramParticipationUncheckedCreateInput>
    /**
     * In case the ProgramParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramParticipationUpdateInput, ProgramParticipationUncheckedUpdateInput>
  }


  /**
   * ProgramParticipation delete
   */
  export type ProgramParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter which ProgramParticipation to delete.
     */
    where: ProgramParticipationWhereUniqueInput
  }


  /**
   * ProgramParticipation deleteMany
   */
  export type ProgramParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramParticipations to delete
     */
    where?: ProgramParticipationWhereInput
  }


  /**
   * ProgramParticipation.Program
   */
  export type ProgramParticipation$ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }


  /**
   * ProgramParticipation without action
   */
  export type ProgramParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
  }



  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    allowanceCeiling: number | null
    maxAllowance: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    allowanceCeiling: number | null
    maxAllowance: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    plan: $Enums.ApplicationType | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    allowanceCeiling: number | null
    class: $Enums.Class | null
    maxAllowance: number | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    plan: $Enums.ApplicationType | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    allowanceCeiling: number | null
    class: $Enums.Class | null
    maxAllowance: number | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    plan: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    allowanceCeiling: number
    class: number
    maxAllowance: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    allowanceCeiling?: true
    maxAllowance?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    allowanceCeiling?: true
    maxAllowance?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    allowanceCeiling?: true
    class?: true
    maxAllowance?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    allowanceCeiling?: true
    class?: true
    maxAllowance?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    plan?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    allowanceCeiling?: true
    class?: true
    maxAllowance?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: number
    plan: $Enums.ApplicationType
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    allowanceCeiling?: boolean
    class?: boolean
    maxAllowance?: boolean
    programParticipations?: boolean | Program$programParticipationsArgs<ExtArgs>
    claimType?: boolean | Program$claimTypeArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    plan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    allowanceCeiling?: boolean
    class?: boolean
    maxAllowance?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programParticipations?: boolean | Program$programParticipationsArgs<ExtArgs>
    claimType?: boolean | Program$claimTypeArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      programParticipations: Prisma.$ProgramParticipationPayload<ExtArgs>[]
      claimType: Prisma.$ClaimTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Nama Program
       * Plan	PlanType = jenis Rawat inap atau disingkat RI
       */
      plan: $Enums.ApplicationType
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      /**
       * Plafon Santunan:	Plafon Santnan Harian Rawat Inap
       */
      allowanceCeiling: number
      /**
       * KELAS: Kelas sesuai Jenjab I=Rp.1.250.000 II=Rp.1.000.000  III= Rp.750.000 
       */
      class: $Enums.Class
      /**
       * Maksimal biaya perawatan 
       */
      maxAllowance: number
    }, ExtArgs["result"]["program"]>
    composites: {}
  }


  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProgramFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProgramFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProgramFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
    **/
    create<T extends ProgramCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Programs.
     *     @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     *     @example
     *     // Create many Programs
     *     const program = await prisma.program.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProgramCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
    **/
    delete<T extends ProgramDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProgramUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProgramDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProgramUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
    **/
    upsert<T extends ProgramUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>
    ): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    programParticipations<T extends Program$programParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Program$programParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findMany'> | Null>;

    claimType<T extends Program$claimTypeArgs<ExtArgs> = {}>(args?: Subset<T, Program$claimTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'Int'>
    readonly plan: FieldRef<"Program", 'ApplicationType'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
    readonly deletedAt: FieldRef<"Program", 'DateTime'>
    readonly allowanceCeiling: FieldRef<"Program", 'Float'>
    readonly class: FieldRef<"Program", 'Class'>
    readonly maxAllowance: FieldRef<"Program", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }


  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }


  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }


  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }


  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }


  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }


  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }


  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }


  /**
   * Program.programParticipations
   */
  export type Program$programParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    cursor?: ProgramParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * Program.claimType
   */
  export type Program$claimTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    where?: ClaimTypeWhereInput
    orderBy?: ClaimTypeOrderByWithRelationInput | ClaimTypeOrderByWithRelationInput[]
    cursor?: ClaimTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimTypeScalarFieldEnum | ClaimTypeScalarFieldEnum[]
  }


  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramInclude<ExtArgs> | null
  }



  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    claimFinancialId: number | null
    claimProcessId: number | null
    diseaseId: number | null
    clinicId: number | null
    claimTypeId: number | null
  }

  export type ClaimSumAggregateOutputType = {
    claimFinancialId: number | null
    claimProcessId: number | null
    diseaseId: number | null
    clinicId: number | null
    claimTypeId: number | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    channel: $Enums.ClaimChannel | null
    admedicaStatus: $Enums.AdmedicaStatus | null
    company: string | null
    participantId: string | null
    claimFinancialId: number | null
    claimProcessId: number | null
    diseaseId: number | null
    clinicId: number | null
    inputedById: string | null
    claimTypeId: number | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    channel: $Enums.ClaimChannel | null
    admedicaStatus: $Enums.AdmedicaStatus | null
    company: string | null
    participantId: string | null
    claimFinancialId: number | null
    claimProcessId: number | null
    diseaseId: number | null
    clinicId: number | null
    inputedById: string | null
    claimTypeId: number | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    channel: number
    admedicaStatus: number
    company: number
    participantId: number
    claimFinancialId: number
    claimProcessId: number
    diseaseId: number
    clinicId: number
    inputedById: number
    claimTypeId: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    claimFinancialId?: true
    claimProcessId?: true
    diseaseId?: true
    clinicId?: true
    claimTypeId?: true
  }

  export type ClaimSumAggregateInputType = {
    claimFinancialId?: true
    claimProcessId?: true
    diseaseId?: true
    clinicId?: true
    claimTypeId?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    channel?: true
    admedicaStatus?: true
    company?: true
    participantId?: true
    claimFinancialId?: true
    claimProcessId?: true
    diseaseId?: true
    clinicId?: true
    inputedById?: true
    claimTypeId?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    channel?: true
    admedicaStatus?: true
    company?: true
    participantId?: true
    claimFinancialId?: true
    claimProcessId?: true
    diseaseId?: true
    clinicId?: true
    inputedById?: true
    claimTypeId?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    channel?: true
    admedicaStatus?: true
    company?: true
    participantId?: true
    claimFinancialId?: true
    claimProcessId?: true
    diseaseId?: true
    clinicId?: true
    inputedById?: true
    claimTypeId?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId: number | null
    clinicId: number
    inputedById: string | null
    claimTypeId: number
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean
    admedicaStatus?: boolean
    company?: boolean
    participantId?: boolean
    claimFinancialId?: boolean
    claimProcessId?: boolean
    diseaseId?: boolean
    clinicId?: boolean
    inputedById?: boolean
    claimTypeId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    claimFinancials?: boolean | ClaimFinancialDefaultArgs<ExtArgs>
    claimProcesses?: boolean | ClaimProcessDefaultArgs<ExtArgs>
    disease?: boolean | Claim$diseaseArgs<ExtArgs>
    clinics?: boolean | ClinicDefaultArgs<ExtArgs>
    inputedBy?: boolean | Claim$inputedByArgs<ExtArgs>
    claimTypes?: boolean | ClaimTypeDefaultArgs<ExtArgs>
    tags?: boolean | Claim$tagsArgs<ExtArgs>
    claimStatuses?: boolean | Claim$claimStatusesArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean
    admedicaStatus?: boolean
    company?: boolean
    participantId?: boolean
    claimFinancialId?: boolean
    claimProcessId?: boolean
    diseaseId?: boolean
    clinicId?: boolean
    inputedById?: boolean
    claimTypeId?: boolean
  }

  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    claimFinancials?: boolean | ClaimFinancialDefaultArgs<ExtArgs>
    claimProcesses?: boolean | ClaimProcessDefaultArgs<ExtArgs>
    disease?: boolean | Claim$diseaseArgs<ExtArgs>
    clinics?: boolean | ClinicDefaultArgs<ExtArgs>
    inputedBy?: boolean | Claim$inputedByArgs<ExtArgs>
    claimTypes?: boolean | ClaimTypeDefaultArgs<ExtArgs>
    tags?: boolean | Claim$tagsArgs<ExtArgs>
    claimStatuses?: boolean | Claim$claimStatusesArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
      claimFinancials: Prisma.$ClaimFinancialPayload<ExtArgs>
      claimProcesses: Prisma.$ClaimProcessPayload<ExtArgs>
      disease: Prisma.$DiseasePayload<ExtArgs> | null
      clinics: Prisma.$ClinicPayload<ExtArgs>
      inputedBy: Prisma.$UserPayload<ExtArgs> | null
      claimTypes: Prisma.$ClaimTypePayload<ExtArgs>
      tags: Prisma.$TagPayload<ExtArgs>[]
      claimStatuses: Prisma.$ClaimStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Nok:	Nomer Register Klaim
       * Nomor Sm	nomer register Surat masuk (Klaim melalui WA/Reguler/Exception/Email)
       */
      id: string
      /**
       * Tklaim:	Tanggal Klaim
       */
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      /**
       * Metode Klaim:	WA,E-mail,Reguler, Telepon
       */
      channel: $Enums.ClaimChannel
      /**
       * Stat. Admedika:	Status Admedika
       */
      admedicaStatus: $Enums.AdmedicaStatus
      /**
       * Prsh:	Perusahaan
       */
      company: string
      participantId: string
      claimFinancialId: number
      claimProcessId: number
      diseaseId: number | null
      clinicId: number
      inputedById: string | null
      claimTypeId: number
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }


  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Claim that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
    **/
    create<T extends ClaimCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Claims.
     *     @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     *     @example
     *     // Create many Claims
     *     const claim = await prisma.claim.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
    **/
    delete<T extends ClaimDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>
    ): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claimFinancials<T extends ClaimFinancialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimFinancialDefaultArgs<ExtArgs>>): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claimProcesses<T extends ClaimProcessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimProcessDefaultArgs<ExtArgs>>): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    disease<T extends Claim$diseaseArgs<ExtArgs> = {}>(args?: Subset<T, Claim$diseaseArgs<ExtArgs>>): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    clinics<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inputedBy<T extends Claim$inputedByArgs<ExtArgs> = {}>(args?: Subset<T, Claim$inputedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claimTypes<T extends ClaimTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimTypeDefaultArgs<ExtArgs>>): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    tags<T extends Claim$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'> | Null>;

    claimStatuses<T extends Claim$claimStatusesArgs<ExtArgs> = {}>(args?: Subset<T, Claim$claimStatusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Claim model
   */ 
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
    readonly deletedAt: FieldRef<"Claim", 'DateTime'>
    readonly channel: FieldRef<"Claim", 'ClaimChannel'>
    readonly admedicaStatus: FieldRef<"Claim", 'AdmedicaStatus'>
    readonly company: FieldRef<"Claim", 'String'>
    readonly participantId: FieldRef<"Claim", 'String'>
    readonly claimFinancialId: FieldRef<"Claim", 'Int'>
    readonly claimProcessId: FieldRef<"Claim", 'Int'>
    readonly diseaseId: FieldRef<"Claim", 'Int'>
    readonly clinicId: FieldRef<"Claim", 'Int'>
    readonly inputedById: FieldRef<"Claim", 'String'>
    readonly claimTypeId: FieldRef<"Claim", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }


  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }


  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }


  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
  }


  /**
   * Claim.disease
   */
  export type Claim$diseaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    where?: DiseaseWhereInput
  }


  /**
   * Claim.inputedBy
   */
  export type Claim$inputedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Claim.tags
   */
  export type Claim$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Claim.claimStatuses
   */
  export type Claim$claimStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    cursor?: ClaimStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimStatusScalarFieldEnum | ClaimStatusScalarFieldEnum[]
  }


  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
    printCount: number | null
    claimProcessId: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
    printCount: number | null
    claimProcessId: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: number | null
    printCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    source: $Enums.DocumentSource | null
    type: $Enums.DocumentType | null
    claimProcessId: number | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    path: string | null
    size: number | null
    printCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    source: $Enums.DocumentSource | null
    type: $Enums.DocumentType | null
    claimProcessId: number | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    name: number
    path: number
    size: number
    printCount: number
    createdAt: number
    updatedAt: number
    source: number
    type: number
    claimProcessId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
    printCount?: true
    claimProcessId?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
    printCount?: true
    claimProcessId?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    printCount?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    type?: true
    claimProcessId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    printCount?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    type?: true
    claimProcessId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    name?: true
    path?: true
    size?: true
    printCount?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    type?: true
    claimProcessId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt: Date
    updatedAt: Date
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId: number | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    printCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    type?: boolean
    claimProcessId?: boolean
    rejectionLetterOf?: boolean | Document$rejectionLetterOfArgs<ExtArgs>
    guaranteeLetterOf?: boolean | Document$guaranteeLetterOfArgs<ExtArgs>
    transactionLetterOf?: boolean | Document$transactionLetterOfArgs<ExtArgs>
    bookKeepingOrderOf?: boolean | Document$bookKeepingOrderOfArgs<ExtArgs>
    claimProcess?: boolean | Document$claimProcessArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    name?: boolean
    path?: boolean
    size?: boolean
    printCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    type?: boolean
    claimProcessId?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rejectionLetterOf?: boolean | Document$rejectionLetterOfArgs<ExtArgs>
    guaranteeLetterOf?: boolean | Document$guaranteeLetterOfArgs<ExtArgs>
    transactionLetterOf?: boolean | Document$transactionLetterOfArgs<ExtArgs>
    bookKeepingOrderOf?: boolean | Document$bookKeepingOrderOfArgs<ExtArgs>
    claimProcess?: boolean | Document$claimProcessArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      rejectionLetterOf: Prisma.$ClaimStatusPayload<ExtArgs> | null
      guaranteeLetterOf: Prisma.$ClaimStatusPayload<ExtArgs> | null
      /**
       * Surat transaksi
       */
      transactionLetterOf: Prisma.$ClaimStatusPayload<ExtArgs> | null
      /**
       * Perintah Pembukuan
       */
      bookKeepingOrderOf: Prisma.$ClaimStatusPayload<ExtArgs> | null
      claimProcess: Prisma.$ClaimProcessPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * Nodok:	Nomer Dokumen
       */
      id: string
      /**
       * Nama Dokumen
       */
      name: string
      /**
       * Path:	Path file dokumen
       */
      path: string
      /**
       * Ukuran:	Ukuran dokumen
       */
      size: number
      /**
       * Jumlah Cetak:	Jumlah cetak dokumen
       */
      printCount: number
      createdAt: Date
      updatedAt: Date
      source: $Enums.DocumentSource
      type: $Enums.DocumentType
      claimProcessId: number | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rejectionLetterOf<T extends Document$rejectionLetterOfArgs<ExtArgs> = {}>(args?: Subset<T, Document$rejectionLetterOfArgs<ExtArgs>>): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    guaranteeLetterOf<T extends Document$guaranteeLetterOfArgs<ExtArgs> = {}>(args?: Subset<T, Document$guaranteeLetterOfArgs<ExtArgs>>): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    transactionLetterOf<T extends Document$transactionLetterOfArgs<ExtArgs> = {}>(args?: Subset<T, Document$transactionLetterOfArgs<ExtArgs>>): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bookKeepingOrderOf<T extends Document$bookKeepingOrderOfArgs<ExtArgs> = {}>(args?: Subset<T, Document$bookKeepingOrderOfArgs<ExtArgs>>): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claimProcess<T extends Document$claimProcessArgs<ExtArgs> = {}>(args?: Subset<T, Document$claimProcessArgs<ExtArgs>>): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly path: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly printCount: FieldRef<"Document", 'Int'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly source: FieldRef<"Document", 'DocumentSource'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly claimProcessId: FieldRef<"Document", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.rejectionLetterOf
   */
  export type Document$rejectionLetterOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
  }


  /**
   * Document.guaranteeLetterOf
   */
  export type Document$guaranteeLetterOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
  }


  /**
   * Document.transactionLetterOf
   */
  export type Document$transactionLetterOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
  }


  /**
   * Document.bookKeepingOrderOf
   */
  export type Document$bookKeepingOrderOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    where?: ClaimStatusWhereInput
  }


  /**
   * Document.claimProcess
   */
  export type Document$claimProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    where?: ClaimProcessWhereInput
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: $Enums.Color | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: $Enums.Color | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    color: $Enums.Color
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Claims?: boolean | Tag$ClaimsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Claims?: boolean | Tag$ClaimsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      Claims: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: $Enums.Color
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Claims<T extends Tag$ClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$ClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'Color'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag.Claims
   */
  export type Tag$ClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model ClaimType
   */

  export type AggregateClaimType = {
    _count: ClaimTypeCountAggregateOutputType | null
    _avg: ClaimTypeAvgAggregateOutputType | null
    _sum: ClaimTypeSumAggregateOutputType | null
    _min: ClaimTypeMinAggregateOutputType | null
    _max: ClaimTypeMaxAggregateOutputType | null
  }

  export type ClaimTypeAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    claimId: number | null
  }

  export type ClaimTypeSumAggregateOutputType = {
    id: number | null
    programId: number | null
    claimId: number | null
  }

  export type ClaimTypeMinAggregateOutputType = {
    id: number | null
    jenis: string | null
    jenisRI: string | null
    plan: string | null
    programId: number | null
    claimId: number | null
  }

  export type ClaimTypeMaxAggregateOutputType = {
    id: number | null
    jenis: string | null
    jenisRI: string | null
    plan: string | null
    programId: number | null
    claimId: number | null
  }

  export type ClaimTypeCountAggregateOutputType = {
    id: number
    jenis: number
    jenisRI: number
    plan: number
    programId: number
    claimId: number
    _all: number
  }


  export type ClaimTypeAvgAggregateInputType = {
    id?: true
    programId?: true
    claimId?: true
  }

  export type ClaimTypeSumAggregateInputType = {
    id?: true
    programId?: true
    claimId?: true
  }

  export type ClaimTypeMinAggregateInputType = {
    id?: true
    jenis?: true
    jenisRI?: true
    plan?: true
    programId?: true
    claimId?: true
  }

  export type ClaimTypeMaxAggregateInputType = {
    id?: true
    jenis?: true
    jenisRI?: true
    plan?: true
    programId?: true
    claimId?: true
  }

  export type ClaimTypeCountAggregateInputType = {
    id?: true
    jenis?: true
    jenisRI?: true
    plan?: true
    programId?: true
    claimId?: true
    _all?: true
  }

  export type ClaimTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimType to aggregate.
     */
    where?: ClaimTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimTypes to fetch.
     */
    orderBy?: ClaimTypeOrderByWithRelationInput | ClaimTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimTypes
    **/
    _count?: true | ClaimTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimTypeMaxAggregateInputType
  }

  export type GetClaimTypeAggregateType<T extends ClaimTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimType[P]>
      : GetScalarType<T[P], AggregateClaimType[P]>
  }




  export type ClaimTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimTypeWhereInput
    orderBy?: ClaimTypeOrderByWithAggregationInput | ClaimTypeOrderByWithAggregationInput[]
    by: ClaimTypeScalarFieldEnum[] | ClaimTypeScalarFieldEnum
    having?: ClaimTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimTypeCountAggregateInputType | true
    _avg?: ClaimTypeAvgAggregateInputType
    _sum?: ClaimTypeSumAggregateInputType
    _min?: ClaimTypeMinAggregateInputType
    _max?: ClaimTypeMaxAggregateInputType
  }

  export type ClaimTypeGroupByOutputType = {
    id: number
    jenis: string
    jenisRI: string
    plan: string
    programId: number
    claimId: number
    _count: ClaimTypeCountAggregateOutputType | null
    _avg: ClaimTypeAvgAggregateOutputType | null
    _sum: ClaimTypeSumAggregateOutputType | null
    _min: ClaimTypeMinAggregateOutputType | null
    _max: ClaimTypeMaxAggregateOutputType | null
  }

  type GetClaimTypeGroupByPayload<T extends ClaimTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimTypeGroupByOutputType[P]>
        }
      >
    >


  export type ClaimTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jenis?: boolean
    jenisRI?: boolean
    plan?: boolean
    programId?: boolean
    claimId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    claims?: boolean | ClaimType$claimsArgs<ExtArgs>
  }, ExtArgs["result"]["claimType"]>

  export type ClaimTypeSelectScalar = {
    id?: boolean
    jenis?: boolean
    jenisRI?: boolean
    plan?: boolean
    programId?: boolean
    claimId?: boolean
  }

  export type ClaimTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    claims?: boolean | ClaimType$claimsArgs<ExtArgs>
  }


  export type $ClaimTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimType"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      claims: Prisma.$ClaimPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Jenis:	Jenis Produk Bantuan
       */
      jenis: string
      /**
       * Jenis RI:	Hospital Cash Plan
       */
      jenisRI: string
      /**
       * Plan	Plan = jenis Rawat inap atau disingkat RI
       */
      plan: string
      programId: number
      claimId: number
    }, ExtArgs["result"]["claimType"]>
    composites: {}
  }


  type ClaimTypeGetPayload<S extends boolean | null | undefined | ClaimTypeDefaultArgs> = $Result.GetResult<Prisma.$ClaimTypePayload, S>

  type ClaimTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimTypeFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimTypeCountAggregateInputType | true
    }

  export interface ClaimTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimType'], meta: { name: 'ClaimType' } }
    /**
     * Find zero or one ClaimType that matches the filter.
     * @param {ClaimTypeFindUniqueArgs} args - Arguments to find a ClaimType
     * @example
     * // Get one ClaimType
     * const claimType = await prisma.claimType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimTypeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClaimType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimTypeFindUniqueOrThrowArgs} args - Arguments to find a ClaimType
     * @example
     * // Get one ClaimType
     * const claimType = await prisma.claimType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClaimType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeFindFirstArgs} args - Arguments to find a ClaimType
     * @example
     * // Get one ClaimType
     * const claimType = await prisma.claimType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimTypeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClaimType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeFindFirstOrThrowArgs} args - Arguments to find a ClaimType
     * @example
     * // Get one ClaimType
     * const claimType = await prisma.claimType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClaimTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimTypes
     * const claimTypes = await prisma.claimType.findMany()
     * 
     * // Get first 10 ClaimTypes
     * const claimTypes = await prisma.claimType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimTypeWithIdOnly = await prisma.claimType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClaimType.
     * @param {ClaimTypeCreateArgs} args - Arguments to create a ClaimType.
     * @example
     * // Create one ClaimType
     * const ClaimType = await prisma.claimType.create({
     *   data: {
     *     // ... data to create a ClaimType
     *   }
     * })
     * 
    **/
    create<T extends ClaimTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeCreateArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClaimTypes.
     *     @param {ClaimTypeCreateManyArgs} args - Arguments to create many ClaimTypes.
     *     @example
     *     // Create many ClaimTypes
     *     const claimType = await prisma.claimType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClaimType.
     * @param {ClaimTypeDeleteArgs} args - Arguments to delete one ClaimType.
     * @example
     * // Delete one ClaimType
     * const ClaimType = await prisma.claimType.delete({
     *   where: {
     *     // ... filter to delete one ClaimType
     *   }
     * })
     * 
    **/
    delete<T extends ClaimTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeDeleteArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClaimType.
     * @param {ClaimTypeUpdateArgs} args - Arguments to update one ClaimType.
     * @example
     * // Update one ClaimType
     * const claimType = await prisma.claimType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeUpdateArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClaimTypes.
     * @param {ClaimTypeDeleteManyArgs} args - Arguments to filter ClaimTypes to delete.
     * @example
     * // Delete a few ClaimTypes
     * const { count } = await prisma.claimType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimTypes
     * const claimType = await prisma.claimType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimType.
     * @param {ClaimTypeUpsertArgs} args - Arguments to update or create a ClaimType.
     * @example
     * // Update or create a ClaimType
     * const claimType = await prisma.claimType.upsert({
     *   create: {
     *     // ... data to create a ClaimType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimType we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimTypeUpsertArgs<ExtArgs>>
    ): Prisma__ClaimTypeClient<$Result.GetResult<Prisma.$ClaimTypePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClaimTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeCountArgs} args - Arguments to filter ClaimTypes to count.
     * @example
     * // Count the number of ClaimTypes
     * const count = await prisma.claimType.count({
     *   where: {
     *     // ... the filter for the ClaimTypes we want to count
     *   }
     * })
    **/
    count<T extends ClaimTypeCountArgs>(
      args?: Subset<T, ClaimTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimTypeAggregateArgs>(args: Subset<T, ClaimTypeAggregateArgs>): Prisma.PrismaPromise<GetClaimTypeAggregateType<T>>

    /**
     * Group by ClaimType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimTypeGroupByArgs['orderBy'] }
        : { orderBy?: ClaimTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimType model
   */
  readonly fields: ClaimTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claims<T extends ClaimType$claimsArgs<ExtArgs> = {}>(args?: Subset<T, ClaimType$claimsArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClaimType model
   */ 
  interface ClaimTypeFieldRefs {
    readonly id: FieldRef<"ClaimType", 'Int'>
    readonly jenis: FieldRef<"ClaimType", 'String'>
    readonly jenisRI: FieldRef<"ClaimType", 'String'>
    readonly plan: FieldRef<"ClaimType", 'String'>
    readonly programId: FieldRef<"ClaimType", 'Int'>
    readonly claimId: FieldRef<"ClaimType", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ClaimType findUnique
   */
  export type ClaimTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClaimType to fetch.
     */
    where: ClaimTypeWhereUniqueInput
  }


  /**
   * ClaimType findUniqueOrThrow
   */
  export type ClaimTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClaimType to fetch.
     */
    where: ClaimTypeWhereUniqueInput
  }


  /**
   * ClaimType findFirst
   */
  export type ClaimTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClaimType to fetch.
     */
    where?: ClaimTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimTypes to fetch.
     */
    orderBy?: ClaimTypeOrderByWithRelationInput | ClaimTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimTypes.
     */
    cursor?: ClaimTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimTypes.
     */
    distinct?: ClaimTypeScalarFieldEnum | ClaimTypeScalarFieldEnum[]
  }


  /**
   * ClaimType findFirstOrThrow
   */
  export type ClaimTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClaimType to fetch.
     */
    where?: ClaimTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimTypes to fetch.
     */
    orderBy?: ClaimTypeOrderByWithRelationInput | ClaimTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimTypes.
     */
    cursor?: ClaimTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimTypes.
     */
    distinct?: ClaimTypeScalarFieldEnum | ClaimTypeScalarFieldEnum[]
  }


  /**
   * ClaimType findMany
   */
  export type ClaimTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter, which ClaimTypes to fetch.
     */
    where?: ClaimTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimTypes to fetch.
     */
    orderBy?: ClaimTypeOrderByWithRelationInput | ClaimTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimTypes.
     */
    cursor?: ClaimTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimTypes.
     */
    skip?: number
    distinct?: ClaimTypeScalarFieldEnum | ClaimTypeScalarFieldEnum[]
  }


  /**
   * ClaimType create
   */
  export type ClaimTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimType.
     */
    data: XOR<ClaimTypeCreateInput, ClaimTypeUncheckedCreateInput>
  }


  /**
   * ClaimType createMany
   */
  export type ClaimTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimTypes.
     */
    data: ClaimTypeCreateManyInput | ClaimTypeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClaimType update
   */
  export type ClaimTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimType.
     */
    data: XOR<ClaimTypeUpdateInput, ClaimTypeUncheckedUpdateInput>
    /**
     * Choose, which ClaimType to update.
     */
    where: ClaimTypeWhereUniqueInput
  }


  /**
   * ClaimType updateMany
   */
  export type ClaimTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimTypes.
     */
    data: XOR<ClaimTypeUpdateManyMutationInput, ClaimTypeUncheckedUpdateManyInput>
    /**
     * Filter which ClaimTypes to update
     */
    where?: ClaimTypeWhereInput
  }


  /**
   * ClaimType upsert
   */
  export type ClaimTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimType to update in case it exists.
     */
    where: ClaimTypeWhereUniqueInput
    /**
     * In case the ClaimType found by the `where` argument doesn't exist, create a new ClaimType with this data.
     */
    create: XOR<ClaimTypeCreateInput, ClaimTypeUncheckedCreateInput>
    /**
     * In case the ClaimType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimTypeUpdateInput, ClaimTypeUncheckedUpdateInput>
  }


  /**
   * ClaimType delete
   */
  export type ClaimTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
    /**
     * Filter which ClaimType to delete.
     */
    where: ClaimTypeWhereUniqueInput
  }


  /**
   * ClaimType deleteMany
   */
  export type ClaimTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimTypes to delete
     */
    where?: ClaimTypeWhereInput
  }


  /**
   * ClaimType.claims
   */
  export type ClaimType$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }


  /**
   * ClaimType without action
   */
  export type ClaimTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimType
     */
    select?: ClaimTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimTypeInclude<ExtArgs> | null
  }



  /**
   * Model ClaimFinancial
   */

  export type AggregateClaimFinancial = {
    _count: ClaimFinancialCountAggregateOutputType | null
    _avg: ClaimFinancialAvgAggregateOutputType | null
    _sum: ClaimFinancialSumAggregateOutputType | null
    _min: ClaimFinancialMinAggregateOutputType | null
    _max: ClaimFinancialMaxAggregateOutputType | null
  }

  export type ClaimFinancialAvgAggregateOutputType = {
    id: number | null
    requestedAmount: number | null
    paidAmount: number | null
    rejectedAmount: number | null
    branchId: number | null
    claimStatusId: number | null
  }

  export type ClaimFinancialSumAggregateOutputType = {
    id: number | null
    requestedAmount: number | null
    paidAmount: number | null
    rejectedAmount: number | null
    branchId: number | null
    claimStatusId: number | null
  }

  export type ClaimFinancialMinAggregateOutputType = {
    id: number | null
    requestedAmount: number | null
    paidAmount: number | null
    rejectedAmount: number | null
    transactionProcessDate: Date | null
    transferDate: Date | null
    claimId: string | null
    branchId: number | null
    claimStatusId: number | null
  }

  export type ClaimFinancialMaxAggregateOutputType = {
    id: number | null
    requestedAmount: number | null
    paidAmount: number | null
    rejectedAmount: number | null
    transactionProcessDate: Date | null
    transferDate: Date | null
    claimId: string | null
    branchId: number | null
    claimStatusId: number | null
  }

  export type ClaimFinancialCountAggregateOutputType = {
    id: number
    requestedAmount: number
    paidAmount: number
    rejectedAmount: number
    transactionProcessDate: number
    transferDate: number
    claimId: number
    branchId: number
    claimStatusId: number
    _all: number
  }


  export type ClaimFinancialAvgAggregateInputType = {
    id?: true
    requestedAmount?: true
    paidAmount?: true
    rejectedAmount?: true
    branchId?: true
    claimStatusId?: true
  }

  export type ClaimFinancialSumAggregateInputType = {
    id?: true
    requestedAmount?: true
    paidAmount?: true
    rejectedAmount?: true
    branchId?: true
    claimStatusId?: true
  }

  export type ClaimFinancialMinAggregateInputType = {
    id?: true
    requestedAmount?: true
    paidAmount?: true
    rejectedAmount?: true
    transactionProcessDate?: true
    transferDate?: true
    claimId?: true
    branchId?: true
    claimStatusId?: true
  }

  export type ClaimFinancialMaxAggregateInputType = {
    id?: true
    requestedAmount?: true
    paidAmount?: true
    rejectedAmount?: true
    transactionProcessDate?: true
    transferDate?: true
    claimId?: true
    branchId?: true
    claimStatusId?: true
  }

  export type ClaimFinancialCountAggregateInputType = {
    id?: true
    requestedAmount?: true
    paidAmount?: true
    rejectedAmount?: true
    transactionProcessDate?: true
    transferDate?: true
    claimId?: true
    branchId?: true
    claimStatusId?: true
    _all?: true
  }

  export type ClaimFinancialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimFinancial to aggregate.
     */
    where?: ClaimFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimFinancials to fetch.
     */
    orderBy?: ClaimFinancialOrderByWithRelationInput | ClaimFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimFinancials
    **/
    _count?: true | ClaimFinancialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimFinancialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimFinancialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimFinancialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimFinancialMaxAggregateInputType
  }

  export type GetClaimFinancialAggregateType<T extends ClaimFinancialAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimFinancial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimFinancial[P]>
      : GetScalarType<T[P], AggregateClaimFinancial[P]>
  }




  export type ClaimFinancialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimFinancialWhereInput
    orderBy?: ClaimFinancialOrderByWithAggregationInput | ClaimFinancialOrderByWithAggregationInput[]
    by: ClaimFinancialScalarFieldEnum[] | ClaimFinancialScalarFieldEnum
    having?: ClaimFinancialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimFinancialCountAggregateInputType | true
    _avg?: ClaimFinancialAvgAggregateInputType
    _sum?: ClaimFinancialSumAggregateInputType
    _min?: ClaimFinancialMinAggregateInputType
    _max?: ClaimFinancialMaxAggregateInputType
  }

  export type ClaimFinancialGroupByOutputType = {
    id: number
    requestedAmount: number
    paidAmount: number | null
    rejectedAmount: number | null
    transactionProcessDate: Date | null
    transferDate: Date | null
    claimId: string
    branchId: number
    claimStatusId: number
    _count: ClaimFinancialCountAggregateOutputType | null
    _avg: ClaimFinancialAvgAggregateOutputType | null
    _sum: ClaimFinancialSumAggregateOutputType | null
    _min: ClaimFinancialMinAggregateOutputType | null
    _max: ClaimFinancialMaxAggregateOutputType | null
  }

  type GetClaimFinancialGroupByPayload<T extends ClaimFinancialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimFinancialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimFinancialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimFinancialGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimFinancialGroupByOutputType[P]>
        }
      >
    >


  export type ClaimFinancialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestedAmount?: boolean
    paidAmount?: boolean
    rejectedAmount?: boolean
    transactionProcessDate?: boolean
    transferDate?: boolean
    claimId?: boolean
    branchId?: boolean
    claimStatusId?: boolean
    branchPayee?: boolean | BranchDefaultArgs<ExtArgs>
    claim?: boolean | ClaimFinancial$claimArgs<ExtArgs>
    claimStatus?: boolean | ClaimStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimFinancial"]>

  export type ClaimFinancialSelectScalar = {
    id?: boolean
    requestedAmount?: boolean
    paidAmount?: boolean
    rejectedAmount?: boolean
    transactionProcessDate?: boolean
    transferDate?: boolean
    claimId?: boolean
    branchId?: boolean
    claimStatusId?: boolean
  }

  export type ClaimFinancialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branchPayee?: boolean | BranchDefaultArgs<ExtArgs>
    claim?: boolean | ClaimFinancial$claimArgs<ExtArgs>
    claimStatus?: boolean | ClaimStatusDefaultArgs<ExtArgs>
  }


  export type $ClaimFinancialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimFinancial"
    objects: {
      /**
       * Cabang: Cabang Pembayar Pensiun
       */
      branchPayee: Prisma.$BranchPayload<ExtArgs>
      claim: Prisma.$ClaimPayload<ExtArgs> | null
      claimStatus: Prisma.$ClaimStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Aju:	Jumlah nominal klaim diajukan
       */
      requestedAmount: number
      /**
       * Bayar:	Jumlah nominal klaim dibayar
       */
      paidAmount: number | null
      /**
       * Tolak:	Jumlah Nominal Klaim ditolak
       */
      rejectedAmount: number | null
      /**
       * TProses Transaksi:	Tanggal Proses Transaksi
       */
      transactionProcessDate: Date | null
      /**
       * Transfer:	Tanggal Transfer
       */
      transferDate: Date | null
      claimId: string
      /**
       * Cabang: Cabang Pembayar Pensiun
       */
      branchId: number
      claimStatusId: number
    }, ExtArgs["result"]["claimFinancial"]>
    composites: {}
  }


  type ClaimFinancialGetPayload<S extends boolean | null | undefined | ClaimFinancialDefaultArgs> = $Result.GetResult<Prisma.$ClaimFinancialPayload, S>

  type ClaimFinancialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimFinancialFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimFinancialCountAggregateInputType | true
    }

  export interface ClaimFinancialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimFinancial'], meta: { name: 'ClaimFinancial' } }
    /**
     * Find zero or one ClaimFinancial that matches the filter.
     * @param {ClaimFinancialFindUniqueArgs} args - Arguments to find a ClaimFinancial
     * @example
     * // Get one ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimFinancialFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClaimFinancial that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimFinancialFindUniqueOrThrowArgs} args - Arguments to find a ClaimFinancial
     * @example
     * // Get one ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimFinancialFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClaimFinancial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialFindFirstArgs} args - Arguments to find a ClaimFinancial
     * @example
     * // Get one ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimFinancialFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClaimFinancial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialFindFirstOrThrowArgs} args - Arguments to find a ClaimFinancial
     * @example
     * // Get one ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimFinancialFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClaimFinancials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimFinancials
     * const claimFinancials = await prisma.claimFinancial.findMany()
     * 
     * // Get first 10 ClaimFinancials
     * const claimFinancials = await prisma.claimFinancial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimFinancialWithIdOnly = await prisma.claimFinancial.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimFinancialFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClaimFinancial.
     * @param {ClaimFinancialCreateArgs} args - Arguments to create a ClaimFinancial.
     * @example
     * // Create one ClaimFinancial
     * const ClaimFinancial = await prisma.claimFinancial.create({
     *   data: {
     *     // ... data to create a ClaimFinancial
     *   }
     * })
     * 
    **/
    create<T extends ClaimFinancialCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialCreateArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClaimFinancials.
     *     @param {ClaimFinancialCreateManyArgs} args - Arguments to create many ClaimFinancials.
     *     @example
     *     // Create many ClaimFinancials
     *     const claimFinancial = await prisma.claimFinancial.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimFinancialCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClaimFinancial.
     * @param {ClaimFinancialDeleteArgs} args - Arguments to delete one ClaimFinancial.
     * @example
     * // Delete one ClaimFinancial
     * const ClaimFinancial = await prisma.claimFinancial.delete({
     *   where: {
     *     // ... filter to delete one ClaimFinancial
     *   }
     * })
     * 
    **/
    delete<T extends ClaimFinancialDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialDeleteArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClaimFinancial.
     * @param {ClaimFinancialUpdateArgs} args - Arguments to update one ClaimFinancial.
     * @example
     * // Update one ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimFinancialUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialUpdateArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClaimFinancials.
     * @param {ClaimFinancialDeleteManyArgs} args - Arguments to filter ClaimFinancials to delete.
     * @example
     * // Delete a few ClaimFinancials
     * const { count } = await prisma.claimFinancial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimFinancialDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimFinancialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimFinancials
     * const claimFinancial = await prisma.claimFinancial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimFinancialUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimFinancial.
     * @param {ClaimFinancialUpsertArgs} args - Arguments to update or create a ClaimFinancial.
     * @example
     * // Update or create a ClaimFinancial
     * const claimFinancial = await prisma.claimFinancial.upsert({
     *   create: {
     *     // ... data to create a ClaimFinancial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimFinancial we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimFinancialUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimFinancialUpsertArgs<ExtArgs>>
    ): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClaimFinancials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialCountArgs} args - Arguments to filter ClaimFinancials to count.
     * @example
     * // Count the number of ClaimFinancials
     * const count = await prisma.claimFinancial.count({
     *   where: {
     *     // ... the filter for the ClaimFinancials we want to count
     *   }
     * })
    **/
    count<T extends ClaimFinancialCountArgs>(
      args?: Subset<T, ClaimFinancialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimFinancialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimFinancialAggregateArgs>(args: Subset<T, ClaimFinancialAggregateArgs>): Prisma.PrismaPromise<GetClaimFinancialAggregateType<T>>

    /**
     * Group by ClaimFinancial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFinancialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimFinancialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimFinancialGroupByArgs['orderBy'] }
        : { orderBy?: ClaimFinancialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimFinancialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimFinancialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimFinancial model
   */
  readonly fields: ClaimFinancialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimFinancial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimFinancialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    branchPayee<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claim<T extends ClaimFinancial$claimArgs<ExtArgs> = {}>(args?: Subset<T, ClaimFinancial$claimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claimStatus<T extends ClaimStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatusDefaultArgs<ExtArgs>>): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClaimFinancial model
   */ 
  interface ClaimFinancialFieldRefs {
    readonly id: FieldRef<"ClaimFinancial", 'Int'>
    readonly requestedAmount: FieldRef<"ClaimFinancial", 'Float'>
    readonly paidAmount: FieldRef<"ClaimFinancial", 'Float'>
    readonly rejectedAmount: FieldRef<"ClaimFinancial", 'Float'>
    readonly transactionProcessDate: FieldRef<"ClaimFinancial", 'DateTime'>
    readonly transferDate: FieldRef<"ClaimFinancial", 'DateTime'>
    readonly claimId: FieldRef<"ClaimFinancial", 'String'>
    readonly branchId: FieldRef<"ClaimFinancial", 'Int'>
    readonly claimStatusId: FieldRef<"ClaimFinancial", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * ClaimFinancial findUnique
   */
  export type ClaimFinancialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter, which ClaimFinancial to fetch.
     */
    where: ClaimFinancialWhereUniqueInput
  }


  /**
   * ClaimFinancial findUniqueOrThrow
   */
  export type ClaimFinancialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter, which ClaimFinancial to fetch.
     */
    where: ClaimFinancialWhereUniqueInput
  }


  /**
   * ClaimFinancial findFirst
   */
  export type ClaimFinancialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter, which ClaimFinancial to fetch.
     */
    where?: ClaimFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimFinancials to fetch.
     */
    orderBy?: ClaimFinancialOrderByWithRelationInput | ClaimFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimFinancials.
     */
    cursor?: ClaimFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimFinancials.
     */
    distinct?: ClaimFinancialScalarFieldEnum | ClaimFinancialScalarFieldEnum[]
  }


  /**
   * ClaimFinancial findFirstOrThrow
   */
  export type ClaimFinancialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter, which ClaimFinancial to fetch.
     */
    where?: ClaimFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimFinancials to fetch.
     */
    orderBy?: ClaimFinancialOrderByWithRelationInput | ClaimFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimFinancials.
     */
    cursor?: ClaimFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimFinancials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimFinancials.
     */
    distinct?: ClaimFinancialScalarFieldEnum | ClaimFinancialScalarFieldEnum[]
  }


  /**
   * ClaimFinancial findMany
   */
  export type ClaimFinancialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter, which ClaimFinancials to fetch.
     */
    where?: ClaimFinancialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimFinancials to fetch.
     */
    orderBy?: ClaimFinancialOrderByWithRelationInput | ClaimFinancialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimFinancials.
     */
    cursor?: ClaimFinancialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimFinancials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimFinancials.
     */
    skip?: number
    distinct?: ClaimFinancialScalarFieldEnum | ClaimFinancialScalarFieldEnum[]
  }


  /**
   * ClaimFinancial create
   */
  export type ClaimFinancialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimFinancial.
     */
    data: XOR<ClaimFinancialCreateInput, ClaimFinancialUncheckedCreateInput>
  }


  /**
   * ClaimFinancial createMany
   */
  export type ClaimFinancialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimFinancials.
     */
    data: ClaimFinancialCreateManyInput | ClaimFinancialCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClaimFinancial update
   */
  export type ClaimFinancialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimFinancial.
     */
    data: XOR<ClaimFinancialUpdateInput, ClaimFinancialUncheckedUpdateInput>
    /**
     * Choose, which ClaimFinancial to update.
     */
    where: ClaimFinancialWhereUniqueInput
  }


  /**
   * ClaimFinancial updateMany
   */
  export type ClaimFinancialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimFinancials.
     */
    data: XOR<ClaimFinancialUpdateManyMutationInput, ClaimFinancialUncheckedUpdateManyInput>
    /**
     * Filter which ClaimFinancials to update
     */
    where?: ClaimFinancialWhereInput
  }


  /**
   * ClaimFinancial upsert
   */
  export type ClaimFinancialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimFinancial to update in case it exists.
     */
    where: ClaimFinancialWhereUniqueInput
    /**
     * In case the ClaimFinancial found by the `where` argument doesn't exist, create a new ClaimFinancial with this data.
     */
    create: XOR<ClaimFinancialCreateInput, ClaimFinancialUncheckedCreateInput>
    /**
     * In case the ClaimFinancial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimFinancialUpdateInput, ClaimFinancialUncheckedUpdateInput>
  }


  /**
   * ClaimFinancial delete
   */
  export type ClaimFinancialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    /**
     * Filter which ClaimFinancial to delete.
     */
    where: ClaimFinancialWhereUniqueInput
  }


  /**
   * ClaimFinancial deleteMany
   */
  export type ClaimFinancialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimFinancials to delete
     */
    where?: ClaimFinancialWhereInput
  }


  /**
   * ClaimFinancial.claim
   */
  export type ClaimFinancial$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }


  /**
   * ClaimFinancial without action
   */
  export type ClaimFinancialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
  }



  /**
   * Model ClaimProcess
   */

  export type AggregateClaimProcess = {
    _count: ClaimProcessCountAggregateOutputType | null
    _avg: ClaimProcessAvgAggregateOutputType | null
    _sum: ClaimProcessSumAggregateOutputType | null
    _min: ClaimProcessMinAggregateOutputType | null
    _max: ClaimProcessMaxAggregateOutputType | null
  }

  export type ClaimProcessAvgAggregateOutputType = {
    id: number | null
  }

  export type ClaimProcessSumAggregateOutputType = {
    id: number | null
  }

  export type ClaimProcessMinAggregateOutputType = {
    id: number | null
    startTreatment: Date | null
    endTreatment: Date | null
    expeditionDate: Date | null
    reclaim: string | null
    processDate: Date | null
    submissionNote: string | null
    description: string | null
    additionalNote: string | null
    claimId: string | null
  }

  export type ClaimProcessMaxAggregateOutputType = {
    id: number | null
    startTreatment: Date | null
    endTreatment: Date | null
    expeditionDate: Date | null
    reclaim: string | null
    processDate: Date | null
    submissionNote: string | null
    description: string | null
    additionalNote: string | null
    claimId: string | null
  }

  export type ClaimProcessCountAggregateOutputType = {
    id: number
    startTreatment: number
    endTreatment: number
    expeditionDate: number
    reclaim: number
    processDate: number
    submissionNote: number
    description: number
    additionalNote: number
    claimId: number
    _all: number
  }


  export type ClaimProcessAvgAggregateInputType = {
    id?: true
  }

  export type ClaimProcessSumAggregateInputType = {
    id?: true
  }

  export type ClaimProcessMinAggregateInputType = {
    id?: true
    startTreatment?: true
    endTreatment?: true
    expeditionDate?: true
    reclaim?: true
    processDate?: true
    submissionNote?: true
    description?: true
    additionalNote?: true
    claimId?: true
  }

  export type ClaimProcessMaxAggregateInputType = {
    id?: true
    startTreatment?: true
    endTreatment?: true
    expeditionDate?: true
    reclaim?: true
    processDate?: true
    submissionNote?: true
    description?: true
    additionalNote?: true
    claimId?: true
  }

  export type ClaimProcessCountAggregateInputType = {
    id?: true
    startTreatment?: true
    endTreatment?: true
    expeditionDate?: true
    reclaim?: true
    processDate?: true
    submissionNote?: true
    description?: true
    additionalNote?: true
    claimId?: true
    _all?: true
  }

  export type ClaimProcessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimProcess to aggregate.
     */
    where?: ClaimProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimProcesses to fetch.
     */
    orderBy?: ClaimProcessOrderByWithRelationInput | ClaimProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimProcesses
    **/
    _count?: true | ClaimProcessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimProcessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimProcessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimProcessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimProcessMaxAggregateInputType
  }

  export type GetClaimProcessAggregateType<T extends ClaimProcessAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimProcess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimProcess[P]>
      : GetScalarType<T[P], AggregateClaimProcess[P]>
  }




  export type ClaimProcessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimProcessWhereInput
    orderBy?: ClaimProcessOrderByWithAggregationInput | ClaimProcessOrderByWithAggregationInput[]
    by: ClaimProcessScalarFieldEnum[] | ClaimProcessScalarFieldEnum
    having?: ClaimProcessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimProcessCountAggregateInputType | true
    _avg?: ClaimProcessAvgAggregateInputType
    _sum?: ClaimProcessSumAggregateInputType
    _min?: ClaimProcessMinAggregateInputType
    _max?: ClaimProcessMaxAggregateInputType
  }

  export type ClaimProcessGroupByOutputType = {
    id: number
    startTreatment: Date | null
    endTreatment: Date | null
    expeditionDate: Date | null
    reclaim: string | null
    processDate: Date | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    _count: ClaimProcessCountAggregateOutputType | null
    _avg: ClaimProcessAvgAggregateOutputType | null
    _sum: ClaimProcessSumAggregateOutputType | null
    _min: ClaimProcessMinAggregateOutputType | null
    _max: ClaimProcessMaxAggregateOutputType | null
  }

  type GetClaimProcessGroupByPayload<T extends ClaimProcessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimProcessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimProcessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimProcessGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimProcessGroupByOutputType[P]>
        }
      >
    >


  export type ClaimProcessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTreatment?: boolean
    endTreatment?: boolean
    expeditionDate?: boolean
    reclaim?: boolean
    processDate?: boolean
    submissionNote?: boolean
    description?: boolean
    additionalNote?: boolean
    claimId?: boolean
    claim?: boolean | ClaimProcess$claimArgs<ExtArgs>
    documents?: boolean | ClaimProcess$documentsArgs<ExtArgs>
    _count?: boolean | ClaimProcessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimProcess"]>

  export type ClaimProcessSelectScalar = {
    id?: boolean
    startTreatment?: boolean
    endTreatment?: boolean
    expeditionDate?: boolean
    reclaim?: boolean
    processDate?: boolean
    submissionNote?: boolean
    description?: boolean
    additionalNote?: boolean
    claimId?: boolean
  }

  export type ClaimProcessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimProcess$claimArgs<ExtArgs>
    documents?: boolean | ClaimProcess$documentsArgs<ExtArgs>
    _count?: boolean | ClaimProcessCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClaimProcessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimProcess"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs> | null
      /**
       * Kwitansi, data, dll: Bukti Pembayaran/Invoice Rumah Sakit oleh Peserta
       */
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Tmulairawat	Tanggal mulai Rawat
       */
      startTreatment: Date | null
      /**
       * Takhirrawat	Tanggal akhir rawat
       */
      endTreatment: Date | null
      /**
       * Tekspedisi	Tanggal ekspedisi
       */
      expeditionDate: Date | null
      /**
       * Reklaim:	Keterangan untuk klaim ulang
       */
      reclaim: string | null
      /**
       * TProses Pengajuan:	Tanggal Proses pengajuan
       */
      processDate: Date | null
      /**
       * Ket.Pengajuan:	Keterangan konfirmasi
       */
      submissionNote: string
      /**
       * Keterangan:	isi keterangan 
       */
      description: string
      /**
       * Ket.Tambahan	keterangan tambahan
       */
      additionalNote: string
      claimId: string
    }, ExtArgs["result"]["claimProcess"]>
    composites: {}
  }


  type ClaimProcessGetPayload<S extends boolean | null | undefined | ClaimProcessDefaultArgs> = $Result.GetResult<Prisma.$ClaimProcessPayload, S>

  type ClaimProcessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimProcessFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimProcessCountAggregateInputType | true
    }

  export interface ClaimProcessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimProcess'], meta: { name: 'ClaimProcess' } }
    /**
     * Find zero or one ClaimProcess that matches the filter.
     * @param {ClaimProcessFindUniqueArgs} args - Arguments to find a ClaimProcess
     * @example
     * // Get one ClaimProcess
     * const claimProcess = await prisma.claimProcess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimProcessFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClaimProcess that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimProcessFindUniqueOrThrowArgs} args - Arguments to find a ClaimProcess
     * @example
     * // Get one ClaimProcess
     * const claimProcess = await prisma.claimProcess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimProcessFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClaimProcess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessFindFirstArgs} args - Arguments to find a ClaimProcess
     * @example
     * // Get one ClaimProcess
     * const claimProcess = await prisma.claimProcess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimProcessFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClaimProcess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessFindFirstOrThrowArgs} args - Arguments to find a ClaimProcess
     * @example
     * // Get one ClaimProcess
     * const claimProcess = await prisma.claimProcess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimProcessFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClaimProcesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimProcesses
     * const claimProcesses = await prisma.claimProcess.findMany()
     * 
     * // Get first 10 ClaimProcesses
     * const claimProcesses = await prisma.claimProcess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimProcessWithIdOnly = await prisma.claimProcess.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimProcessFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClaimProcess.
     * @param {ClaimProcessCreateArgs} args - Arguments to create a ClaimProcess.
     * @example
     * // Create one ClaimProcess
     * const ClaimProcess = await prisma.claimProcess.create({
     *   data: {
     *     // ... data to create a ClaimProcess
     *   }
     * })
     * 
    **/
    create<T extends ClaimProcessCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessCreateArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClaimProcesses.
     *     @param {ClaimProcessCreateManyArgs} args - Arguments to create many ClaimProcesses.
     *     @example
     *     // Create many ClaimProcesses
     *     const claimProcess = await prisma.claimProcess.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimProcessCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClaimProcess.
     * @param {ClaimProcessDeleteArgs} args - Arguments to delete one ClaimProcess.
     * @example
     * // Delete one ClaimProcess
     * const ClaimProcess = await prisma.claimProcess.delete({
     *   where: {
     *     // ... filter to delete one ClaimProcess
     *   }
     * })
     * 
    **/
    delete<T extends ClaimProcessDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessDeleteArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClaimProcess.
     * @param {ClaimProcessUpdateArgs} args - Arguments to update one ClaimProcess.
     * @example
     * // Update one ClaimProcess
     * const claimProcess = await prisma.claimProcess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimProcessUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessUpdateArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClaimProcesses.
     * @param {ClaimProcessDeleteManyArgs} args - Arguments to filter ClaimProcesses to delete.
     * @example
     * // Delete a few ClaimProcesses
     * const { count } = await prisma.claimProcess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimProcessDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimProcessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimProcesses
     * const claimProcess = await prisma.claimProcess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimProcessUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimProcess.
     * @param {ClaimProcessUpsertArgs} args - Arguments to update or create a ClaimProcess.
     * @example
     * // Update or create a ClaimProcess
     * const claimProcess = await prisma.claimProcess.upsert({
     *   create: {
     *     // ... data to create a ClaimProcess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimProcess we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimProcessUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimProcessUpsertArgs<ExtArgs>>
    ): Prisma__ClaimProcessClient<$Result.GetResult<Prisma.$ClaimProcessPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClaimProcesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessCountArgs} args - Arguments to filter ClaimProcesses to count.
     * @example
     * // Count the number of ClaimProcesses
     * const count = await prisma.claimProcess.count({
     *   where: {
     *     // ... the filter for the ClaimProcesses we want to count
     *   }
     * })
    **/
    count<T extends ClaimProcessCountArgs>(
      args?: Subset<T, ClaimProcessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimProcessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimProcessAggregateArgs>(args: Subset<T, ClaimProcessAggregateArgs>): Prisma.PrismaPromise<GetClaimProcessAggregateType<T>>

    /**
     * Group by ClaimProcess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimProcessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimProcessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimProcessGroupByArgs['orderBy'] }
        : { orderBy?: ClaimProcessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimProcessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimProcessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimProcess model
   */
  readonly fields: ClaimProcessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimProcess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimProcessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    claim<T extends ClaimProcess$claimArgs<ExtArgs> = {}>(args?: Subset<T, ClaimProcess$claimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    documents<T extends ClaimProcess$documentsArgs<ExtArgs> = {}>(args?: Subset<T, ClaimProcess$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClaimProcess model
   */ 
  interface ClaimProcessFieldRefs {
    readonly id: FieldRef<"ClaimProcess", 'Int'>
    readonly startTreatment: FieldRef<"ClaimProcess", 'DateTime'>
    readonly endTreatment: FieldRef<"ClaimProcess", 'DateTime'>
    readonly expeditionDate: FieldRef<"ClaimProcess", 'DateTime'>
    readonly reclaim: FieldRef<"ClaimProcess", 'String'>
    readonly processDate: FieldRef<"ClaimProcess", 'DateTime'>
    readonly submissionNote: FieldRef<"ClaimProcess", 'String'>
    readonly description: FieldRef<"ClaimProcess", 'String'>
    readonly additionalNote: FieldRef<"ClaimProcess", 'String'>
    readonly claimId: FieldRef<"ClaimProcess", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ClaimProcess findUnique
   */
  export type ClaimProcessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter, which ClaimProcess to fetch.
     */
    where: ClaimProcessWhereUniqueInput
  }


  /**
   * ClaimProcess findUniqueOrThrow
   */
  export type ClaimProcessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter, which ClaimProcess to fetch.
     */
    where: ClaimProcessWhereUniqueInput
  }


  /**
   * ClaimProcess findFirst
   */
  export type ClaimProcessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter, which ClaimProcess to fetch.
     */
    where?: ClaimProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimProcesses to fetch.
     */
    orderBy?: ClaimProcessOrderByWithRelationInput | ClaimProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimProcesses.
     */
    cursor?: ClaimProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimProcesses.
     */
    distinct?: ClaimProcessScalarFieldEnum | ClaimProcessScalarFieldEnum[]
  }


  /**
   * ClaimProcess findFirstOrThrow
   */
  export type ClaimProcessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter, which ClaimProcess to fetch.
     */
    where?: ClaimProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimProcesses to fetch.
     */
    orderBy?: ClaimProcessOrderByWithRelationInput | ClaimProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimProcesses.
     */
    cursor?: ClaimProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimProcesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimProcesses.
     */
    distinct?: ClaimProcessScalarFieldEnum | ClaimProcessScalarFieldEnum[]
  }


  /**
   * ClaimProcess findMany
   */
  export type ClaimProcessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter, which ClaimProcesses to fetch.
     */
    where?: ClaimProcessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimProcesses to fetch.
     */
    orderBy?: ClaimProcessOrderByWithRelationInput | ClaimProcessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimProcesses.
     */
    cursor?: ClaimProcessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimProcesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimProcesses.
     */
    skip?: number
    distinct?: ClaimProcessScalarFieldEnum | ClaimProcessScalarFieldEnum[]
  }


  /**
   * ClaimProcess create
   */
  export type ClaimProcessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimProcess.
     */
    data: XOR<ClaimProcessCreateInput, ClaimProcessUncheckedCreateInput>
  }


  /**
   * ClaimProcess createMany
   */
  export type ClaimProcessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimProcesses.
     */
    data: ClaimProcessCreateManyInput | ClaimProcessCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClaimProcess update
   */
  export type ClaimProcessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimProcess.
     */
    data: XOR<ClaimProcessUpdateInput, ClaimProcessUncheckedUpdateInput>
    /**
     * Choose, which ClaimProcess to update.
     */
    where: ClaimProcessWhereUniqueInput
  }


  /**
   * ClaimProcess updateMany
   */
  export type ClaimProcessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimProcesses.
     */
    data: XOR<ClaimProcessUpdateManyMutationInput, ClaimProcessUncheckedUpdateManyInput>
    /**
     * Filter which ClaimProcesses to update
     */
    where?: ClaimProcessWhereInput
  }


  /**
   * ClaimProcess upsert
   */
  export type ClaimProcessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimProcess to update in case it exists.
     */
    where: ClaimProcessWhereUniqueInput
    /**
     * In case the ClaimProcess found by the `where` argument doesn't exist, create a new ClaimProcess with this data.
     */
    create: XOR<ClaimProcessCreateInput, ClaimProcessUncheckedCreateInput>
    /**
     * In case the ClaimProcess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimProcessUpdateInput, ClaimProcessUncheckedUpdateInput>
  }


  /**
   * ClaimProcess delete
   */
  export type ClaimProcessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
    /**
     * Filter which ClaimProcess to delete.
     */
    where: ClaimProcessWhereUniqueInput
  }


  /**
   * ClaimProcess deleteMany
   */
  export type ClaimProcessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimProcesses to delete
     */
    where?: ClaimProcessWhereInput
  }


  /**
   * ClaimProcess.claim
   */
  export type ClaimProcess$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }


  /**
   * ClaimProcess.documents
   */
  export type ClaimProcess$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * ClaimProcess without action
   */
  export type ClaimProcessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimProcess
     */
    select?: ClaimProcessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimProcessInclude<ExtArgs> | null
  }



  /**
   * Model ClaimStatus
   */

  export type AggregateClaimStatus = {
    _count: ClaimStatusCountAggregateOutputType | null
    _avg: ClaimStatusAvgAggregateOutputType | null
    _sum: ClaimStatusSumAggregateOutputType | null
    _min: ClaimStatusMinAggregateOutputType | null
    _max: ClaimStatusMaxAggregateOutputType | null
  }

  export type ClaimStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type ClaimStatusSumAggregateOutputType = {
    id: number | null
  }

  export type ClaimStatusMinAggregateOutputType = {
    id: number | null
    description: string | null
    rejectionReason: string | null
    createdAt: Date | null
    status: $Enums.ClaimStatusType | null
    createById: string | null
    claimId: string | null
    rejectionLetterId: string | null
    guaranteeLetterId: string | null
    transactionLetterId: string | null
    bookKeepingOrderId: string | null
  }

  export type ClaimStatusMaxAggregateOutputType = {
    id: number | null
    description: string | null
    rejectionReason: string | null
    createdAt: Date | null
    status: $Enums.ClaimStatusType | null
    createById: string | null
    claimId: string | null
    rejectionLetterId: string | null
    guaranteeLetterId: string | null
    transactionLetterId: string | null
    bookKeepingOrderId: string | null
  }

  export type ClaimStatusCountAggregateOutputType = {
    id: number
    description: number
    rejectionReason: number
    createdAt: number
    status: number
    createById: number
    claimId: number
    rejectionLetterId: number
    guaranteeLetterId: number
    transactionLetterId: number
    bookKeepingOrderId: number
    _all: number
  }


  export type ClaimStatusAvgAggregateInputType = {
    id?: true
  }

  export type ClaimStatusSumAggregateInputType = {
    id?: true
  }

  export type ClaimStatusMinAggregateInputType = {
    id?: true
    description?: true
    rejectionReason?: true
    createdAt?: true
    status?: true
    createById?: true
    claimId?: true
    rejectionLetterId?: true
    guaranteeLetterId?: true
    transactionLetterId?: true
    bookKeepingOrderId?: true
  }

  export type ClaimStatusMaxAggregateInputType = {
    id?: true
    description?: true
    rejectionReason?: true
    createdAt?: true
    status?: true
    createById?: true
    claimId?: true
    rejectionLetterId?: true
    guaranteeLetterId?: true
    transactionLetterId?: true
    bookKeepingOrderId?: true
  }

  export type ClaimStatusCountAggregateInputType = {
    id?: true
    description?: true
    rejectionReason?: true
    createdAt?: true
    status?: true
    createById?: true
    claimId?: true
    rejectionLetterId?: true
    guaranteeLetterId?: true
    transactionLetterId?: true
    bookKeepingOrderId?: true
    _all?: true
  }

  export type ClaimStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimStatus to aggregate.
     */
    where?: ClaimStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimStatuses to fetch.
     */
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimStatuses
    **/
    _count?: true | ClaimStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimStatusMaxAggregateInputType
  }

  export type GetClaimStatusAggregateType<T extends ClaimStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimStatus[P]>
      : GetScalarType<T[P], AggregateClaimStatus[P]>
  }




  export type ClaimStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimStatusWhereInput
    orderBy?: ClaimStatusOrderByWithAggregationInput | ClaimStatusOrderByWithAggregationInput[]
    by: ClaimStatusScalarFieldEnum[] | ClaimStatusScalarFieldEnum
    having?: ClaimStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimStatusCountAggregateInputType | true
    _avg?: ClaimStatusAvgAggregateInputType
    _sum?: ClaimStatusSumAggregateInputType
    _min?: ClaimStatusMinAggregateInputType
    _max?: ClaimStatusMaxAggregateInputType
  }

  export type ClaimStatusGroupByOutputType = {
    id: number
    description: string | null
    rejectionReason: string | null
    createdAt: Date
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId: string | null
    guaranteeLetterId: string | null
    transactionLetterId: string | null
    bookKeepingOrderId: string | null
    _count: ClaimStatusCountAggregateOutputType | null
    _avg: ClaimStatusAvgAggregateOutputType | null
    _sum: ClaimStatusSumAggregateOutputType | null
    _min: ClaimStatusMinAggregateOutputType | null
    _max: ClaimStatusMaxAggregateOutputType | null
  }

  type GetClaimStatusGroupByPayload<T extends ClaimStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimStatusGroupByOutputType[P]>
        }
      >
    >


  export type ClaimStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    status?: boolean
    createById?: boolean
    claimId?: boolean
    rejectionLetterId?: boolean
    guaranteeLetterId?: boolean
    transactionLetterId?: boolean
    bookKeepingOrderId?: boolean
    createBy?: boolean | UserDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    rejectionLetter?: boolean | ClaimStatus$rejectionLetterArgs<ExtArgs>
    guaranteeLetter?: boolean | ClaimStatus$guaranteeLetterArgs<ExtArgs>
    transactionLetter?: boolean | ClaimStatus$transactionLetterArgs<ExtArgs>
    bookKeepingOrder?: boolean | ClaimStatus$bookKeepingOrderArgs<ExtArgs>
    claimFinancial?: boolean | ClaimStatus$claimFinancialArgs<ExtArgs>
  }, ExtArgs["result"]["claimStatus"]>

  export type ClaimStatusSelectScalar = {
    id?: boolean
    description?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    status?: boolean
    createById?: boolean
    claimId?: boolean
    rejectionLetterId?: boolean
    guaranteeLetterId?: boolean
    transactionLetterId?: boolean
    bookKeepingOrderId?: boolean
  }

  export type ClaimStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createBy?: boolean | UserDefaultArgs<ExtArgs>
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    rejectionLetter?: boolean | ClaimStatus$rejectionLetterArgs<ExtArgs>
    guaranteeLetter?: boolean | ClaimStatus$guaranteeLetterArgs<ExtArgs>
    transactionLetter?: boolean | ClaimStatus$transactionLetterArgs<ExtArgs>
    bookKeepingOrder?: boolean | ClaimStatus$bookKeepingOrderArgs<ExtArgs>
    claimFinancial?: boolean | ClaimStatus$claimFinancialArgs<ExtArgs>
  }


  export type $ClaimStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimStatus"
    objects: {
      createBy: Prisma.$UserPayload<ExtArgs>
      claim: Prisma.$ClaimPayload<ExtArgs>
      /**
       * Nomor surat tolak
       * Tanggal surat tolak
       */
      rejectionLetter: Prisma.$DocumentPayload<ExtArgs> | null
      /**
       * No SurJam:	Nomer Surat jaminan
       */
      guaranteeLetter: Prisma.$DocumentPayload<ExtArgs> | null
      transactionLetter: Prisma.$DocumentPayload<ExtArgs> | null
      bookKeepingOrder: Prisma.$DocumentPayload<ExtArgs> | null
      claimFinancial: Prisma.$ClaimFinancialPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string | null
      rejectionReason: string | null
      createdAt: Date
      status: $Enums.ClaimStatusType
      createById: string
      claimId: string
      /**
       * Nomor surat tolak
       * Tanggal surat tolak
       */
      rejectionLetterId: string | null
      /**
       * No SurJam:	Nomer Surat jaminan
       */
      guaranteeLetterId: string | null
      transactionLetterId: string | null
      bookKeepingOrderId: string | null
    }, ExtArgs["result"]["claimStatus"]>
    composites: {}
  }


  type ClaimStatusGetPayload<S extends boolean | null | undefined | ClaimStatusDefaultArgs> = $Result.GetResult<Prisma.$ClaimStatusPayload, S>

  type ClaimStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClaimStatusFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClaimStatusCountAggregateInputType | true
    }

  export interface ClaimStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimStatus'], meta: { name: 'ClaimStatus' } }
    /**
     * Find zero or one ClaimStatus that matches the filter.
     * @param {ClaimStatusFindUniqueArgs} args - Arguments to find a ClaimStatus
     * @example
     * // Get one ClaimStatus
     * const claimStatus = await prisma.claimStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClaimStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ClaimStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClaimStatusFindUniqueOrThrowArgs} args - Arguments to find a ClaimStatus
     * @example
     * // Get one ClaimStatus
     * const claimStatus = await prisma.claimStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClaimStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ClaimStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusFindFirstArgs} args - Arguments to find a ClaimStatus
     * @example
     * // Get one ClaimStatus
     * const claimStatus = await prisma.claimStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClaimStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusFindFirstArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ClaimStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusFindFirstOrThrowArgs} args - Arguments to find a ClaimStatus
     * @example
     * // Get one ClaimStatus
     * const claimStatus = await prisma.claimStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClaimStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ClaimStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimStatuses
     * const claimStatuses = await prisma.claimStatus.findMany()
     * 
     * // Get first 10 ClaimStatuses
     * const claimStatuses = await prisma.claimStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimStatusWithIdOnly = await prisma.claimStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClaimStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ClaimStatus.
     * @param {ClaimStatusCreateArgs} args - Arguments to create a ClaimStatus.
     * @example
     * // Create one ClaimStatus
     * const ClaimStatus = await prisma.claimStatus.create({
     *   data: {
     *     // ... data to create a ClaimStatus
     *   }
     * })
     * 
    **/
    create<T extends ClaimStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusCreateArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ClaimStatuses.
     *     @param {ClaimStatusCreateManyArgs} args - Arguments to create many ClaimStatuses.
     *     @example
     *     // Create many ClaimStatuses
     *     const claimStatus = await prisma.claimStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClaimStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClaimStatus.
     * @param {ClaimStatusDeleteArgs} args - Arguments to delete one ClaimStatus.
     * @example
     * // Delete one ClaimStatus
     * const ClaimStatus = await prisma.claimStatus.delete({
     *   where: {
     *     // ... filter to delete one ClaimStatus
     *   }
     * })
     * 
    **/
    delete<T extends ClaimStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusDeleteArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ClaimStatus.
     * @param {ClaimStatusUpdateArgs} args - Arguments to update one ClaimStatus.
     * @example
     * // Update one ClaimStatus
     * const claimStatus = await prisma.claimStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClaimStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusUpdateArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ClaimStatuses.
     * @param {ClaimStatusDeleteManyArgs} args - Arguments to filter ClaimStatuses to delete.
     * @example
     * // Delete a few ClaimStatuses
     * const { count } = await prisma.claimStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClaimStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClaimStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimStatuses
     * const claimStatus = await prisma.claimStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClaimStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClaimStatus.
     * @param {ClaimStatusUpsertArgs} args - Arguments to update or create a ClaimStatus.
     * @example
     * // Update or create a ClaimStatus
     * const claimStatus = await prisma.claimStatus.upsert({
     *   create: {
     *     // ... data to create a ClaimStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimStatus we want to update
     *   }
     * })
    **/
    upsert<T extends ClaimStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClaimStatusUpsertArgs<ExtArgs>>
    ): Prisma__ClaimStatusClient<$Result.GetResult<Prisma.$ClaimStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ClaimStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusCountArgs} args - Arguments to filter ClaimStatuses to count.
     * @example
     * // Count the number of ClaimStatuses
     * const count = await prisma.claimStatus.count({
     *   where: {
     *     // ... the filter for the ClaimStatuses we want to count
     *   }
     * })
    **/
    count<T extends ClaimStatusCountArgs>(
      args?: Subset<T, ClaimStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimStatusAggregateArgs>(args: Subset<T, ClaimStatusAggregateArgs>): Prisma.PrismaPromise<GetClaimStatusAggregateType<T>>

    /**
     * Group by ClaimStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimStatusGroupByArgs['orderBy'] }
        : { orderBy?: ClaimStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimStatus model
   */
  readonly fields: ClaimStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    createBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rejectionLetter<T extends ClaimStatus$rejectionLetterArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatus$rejectionLetterArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    guaranteeLetter<T extends ClaimStatus$guaranteeLetterArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatus$guaranteeLetterArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    transactionLetter<T extends ClaimStatus$transactionLetterArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatus$transactionLetterArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    bookKeepingOrder<T extends ClaimStatus$bookKeepingOrderArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatus$bookKeepingOrderArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    claimFinancial<T extends ClaimStatus$claimFinancialArgs<ExtArgs> = {}>(args?: Subset<T, ClaimStatus$claimFinancialArgs<ExtArgs>>): Prisma__ClaimFinancialClient<$Result.GetResult<Prisma.$ClaimFinancialPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ClaimStatus model
   */ 
  interface ClaimStatusFieldRefs {
    readonly id: FieldRef<"ClaimStatus", 'Int'>
    readonly description: FieldRef<"ClaimStatus", 'String'>
    readonly rejectionReason: FieldRef<"ClaimStatus", 'String'>
    readonly createdAt: FieldRef<"ClaimStatus", 'DateTime'>
    readonly status: FieldRef<"ClaimStatus", 'ClaimStatusType'>
    readonly createById: FieldRef<"ClaimStatus", 'String'>
    readonly claimId: FieldRef<"ClaimStatus", 'String'>
    readonly rejectionLetterId: FieldRef<"ClaimStatus", 'String'>
    readonly guaranteeLetterId: FieldRef<"ClaimStatus", 'String'>
    readonly transactionLetterId: FieldRef<"ClaimStatus", 'String'>
    readonly bookKeepingOrderId: FieldRef<"ClaimStatus", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ClaimStatus findUnique
   */
  export type ClaimStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter, which ClaimStatus to fetch.
     */
    where: ClaimStatusWhereUniqueInput
  }


  /**
   * ClaimStatus findUniqueOrThrow
   */
  export type ClaimStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter, which ClaimStatus to fetch.
     */
    where: ClaimStatusWhereUniqueInput
  }


  /**
   * ClaimStatus findFirst
   */
  export type ClaimStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter, which ClaimStatus to fetch.
     */
    where?: ClaimStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimStatuses to fetch.
     */
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimStatuses.
     */
    cursor?: ClaimStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimStatuses.
     */
    distinct?: ClaimStatusScalarFieldEnum | ClaimStatusScalarFieldEnum[]
  }


  /**
   * ClaimStatus findFirstOrThrow
   */
  export type ClaimStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter, which ClaimStatus to fetch.
     */
    where?: ClaimStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimStatuses to fetch.
     */
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimStatuses.
     */
    cursor?: ClaimStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimStatuses.
     */
    distinct?: ClaimStatusScalarFieldEnum | ClaimStatusScalarFieldEnum[]
  }


  /**
   * ClaimStatus findMany
   */
  export type ClaimStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter, which ClaimStatuses to fetch.
     */
    where?: ClaimStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimStatuses to fetch.
     */
    orderBy?: ClaimStatusOrderByWithRelationInput | ClaimStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimStatuses.
     */
    cursor?: ClaimStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimStatuses.
     */
    skip?: number
    distinct?: ClaimStatusScalarFieldEnum | ClaimStatusScalarFieldEnum[]
  }


  /**
   * ClaimStatus create
   */
  export type ClaimStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimStatus.
     */
    data: XOR<ClaimStatusCreateInput, ClaimStatusUncheckedCreateInput>
  }


  /**
   * ClaimStatus createMany
   */
  export type ClaimStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimStatuses.
     */
    data: ClaimStatusCreateManyInput | ClaimStatusCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ClaimStatus update
   */
  export type ClaimStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimStatus.
     */
    data: XOR<ClaimStatusUpdateInput, ClaimStatusUncheckedUpdateInput>
    /**
     * Choose, which ClaimStatus to update.
     */
    where: ClaimStatusWhereUniqueInput
  }


  /**
   * ClaimStatus updateMany
   */
  export type ClaimStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimStatuses.
     */
    data: XOR<ClaimStatusUpdateManyMutationInput, ClaimStatusUncheckedUpdateManyInput>
    /**
     * Filter which ClaimStatuses to update
     */
    where?: ClaimStatusWhereInput
  }


  /**
   * ClaimStatus upsert
   */
  export type ClaimStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimStatus to update in case it exists.
     */
    where: ClaimStatusWhereUniqueInput
    /**
     * In case the ClaimStatus found by the `where` argument doesn't exist, create a new ClaimStatus with this data.
     */
    create: XOR<ClaimStatusCreateInput, ClaimStatusUncheckedCreateInput>
    /**
     * In case the ClaimStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimStatusUpdateInput, ClaimStatusUncheckedUpdateInput>
  }


  /**
   * ClaimStatus delete
   */
  export type ClaimStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
    /**
     * Filter which ClaimStatus to delete.
     */
    where: ClaimStatusWhereUniqueInput
  }


  /**
   * ClaimStatus deleteMany
   */
  export type ClaimStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimStatuses to delete
     */
    where?: ClaimStatusWhereInput
  }


  /**
   * ClaimStatus.rejectionLetter
   */
  export type ClaimStatus$rejectionLetterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }


  /**
   * ClaimStatus.guaranteeLetter
   */
  export type ClaimStatus$guaranteeLetterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }


  /**
   * ClaimStatus.transactionLetter
   */
  export type ClaimStatus$transactionLetterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }


  /**
   * ClaimStatus.bookKeepingOrder
   */
  export type ClaimStatus$bookKeepingOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }


  /**
   * ClaimStatus.claimFinancial
   */
  export type ClaimStatus$claimFinancialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimFinancial
     */
    select?: ClaimFinancialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimFinancialInclude<ExtArgs> | null
    where?: ClaimFinancialWhereInput
  }


  /**
   * ClaimStatus without action
   */
  export type ClaimStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimStatus
     */
    select?: ClaimStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimStatusInclude<ExtArgs> | null
  }



  /**
   * Model Disease
   */

  export type AggregateDisease = {
    _count: DiseaseCountAggregateOutputType | null
    _avg: DiseaseAvgAggregateOutputType | null
    _sum: DiseaseSumAggregateOutputType | null
    _min: DiseaseMinAggregateOutputType | null
    _max: DiseaseMaxAggregateOutputType | null
  }

  export type DiseaseAvgAggregateOutputType = {
    id: number | null
  }

  export type DiseaseSumAggregateOutputType = {
    id: number | null
  }

  export type DiseaseMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiseaseMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiseaseCountAggregateOutputType = {
    id: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiseaseAvgAggregateInputType = {
    id?: true
  }

  export type DiseaseSumAggregateInputType = {
    id?: true
  }

  export type DiseaseMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiseaseMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiseaseCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiseaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disease to aggregate.
     */
    where?: DiseaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diseases to fetch.
     */
    orderBy?: DiseaseOrderByWithRelationInput | DiseaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiseaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diseases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diseases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diseases
    **/
    _count?: true | DiseaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiseaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiseaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiseaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiseaseMaxAggregateInputType
  }

  export type GetDiseaseAggregateType<T extends DiseaseAggregateArgs> = {
        [P in keyof T & keyof AggregateDisease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisease[P]>
      : GetScalarType<T[P], AggregateDisease[P]>
  }




  export type DiseaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiseaseWhereInput
    orderBy?: DiseaseOrderByWithAggregationInput | DiseaseOrderByWithAggregationInput[]
    by: DiseaseScalarFieldEnum[] | DiseaseScalarFieldEnum
    having?: DiseaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiseaseCountAggregateInputType | true
    _avg?: DiseaseAvgAggregateInputType
    _sum?: DiseaseSumAggregateInputType
    _min?: DiseaseMinAggregateInputType
    _max?: DiseaseMaxAggregateInputType
  }

  export type DiseaseGroupByOutputType = {
    id: number
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: DiseaseCountAggregateOutputType | null
    _avg: DiseaseAvgAggregateOutputType | null
    _sum: DiseaseSumAggregateOutputType | null
    _min: DiseaseMinAggregateOutputType | null
    _max: DiseaseMaxAggregateOutputType | null
  }

  type GetDiseaseGroupByPayload<T extends DiseaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiseaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiseaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiseaseGroupByOutputType[P]>
            : GetScalarType<T[P], DiseaseGroupByOutputType[P]>
        }
      >
    >


  export type DiseaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claims?: boolean | Disease$claimsArgs<ExtArgs>
    _count?: boolean | DiseaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disease"]>

  export type DiseaseSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiseaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Disease$claimsArgs<ExtArgs>
    _count?: boolean | DiseaseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DiseasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Disease"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * KodePenyakit: kode jenis penyakit
       */
      code: string
      /**
       * NamaPenyakit: nama penyakit
       */
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["disease"]>
    composites: {}
  }


  type DiseaseGetPayload<S extends boolean | null | undefined | DiseaseDefaultArgs> = $Result.GetResult<Prisma.$DiseasePayload, S>

  type DiseaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiseaseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: DiseaseCountAggregateInputType | true
    }

  export interface DiseaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Disease'], meta: { name: 'Disease' } }
    /**
     * Find zero or one Disease that matches the filter.
     * @param {DiseaseFindUniqueArgs} args - Arguments to find a Disease
     * @example
     * // Get one Disease
     * const disease = await prisma.disease.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DiseaseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseFindUniqueArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Disease that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DiseaseFindUniqueOrThrowArgs} args - Arguments to find a Disease
     * @example
     * // Get one Disease
     * const disease = await prisma.disease.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DiseaseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Disease that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseFindFirstArgs} args - Arguments to find a Disease
     * @example
     * // Get one Disease
     * const disease = await prisma.disease.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DiseaseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseFindFirstArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Disease that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseFindFirstOrThrowArgs} args - Arguments to find a Disease
     * @example
     * // Get one Disease
     * const disease = await prisma.disease.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DiseaseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Diseases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diseases
     * const diseases = await prisma.disease.findMany()
     * 
     * // Get first 10 Diseases
     * const diseases = await prisma.disease.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diseaseWithIdOnly = await prisma.disease.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DiseaseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Disease.
     * @param {DiseaseCreateArgs} args - Arguments to create a Disease.
     * @example
     * // Create one Disease
     * const Disease = await prisma.disease.create({
     *   data: {
     *     // ... data to create a Disease
     *   }
     * })
     * 
    **/
    create<T extends DiseaseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseCreateArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Diseases.
     *     @param {DiseaseCreateManyArgs} args - Arguments to create many Diseases.
     *     @example
     *     // Create many Diseases
     *     const disease = await prisma.disease.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DiseaseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Disease.
     * @param {DiseaseDeleteArgs} args - Arguments to delete one Disease.
     * @example
     * // Delete one Disease
     * const Disease = await prisma.disease.delete({
     *   where: {
     *     // ... filter to delete one Disease
     *   }
     * })
     * 
    **/
    delete<T extends DiseaseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseDeleteArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Disease.
     * @param {DiseaseUpdateArgs} args - Arguments to update one Disease.
     * @example
     * // Update one Disease
     * const disease = await prisma.disease.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DiseaseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseUpdateArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Diseases.
     * @param {DiseaseDeleteManyArgs} args - Arguments to filter Diseases to delete.
     * @example
     * // Delete a few Diseases
     * const { count } = await prisma.disease.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DiseaseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DiseaseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diseases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diseases
     * const disease = await prisma.disease.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DiseaseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Disease.
     * @param {DiseaseUpsertArgs} args - Arguments to update or create a Disease.
     * @example
     * // Update or create a Disease
     * const disease = await prisma.disease.upsert({
     *   create: {
     *     // ... data to create a Disease
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disease we want to update
     *   }
     * })
    **/
    upsert<T extends DiseaseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DiseaseUpsertArgs<ExtArgs>>
    ): Prisma__DiseaseClient<$Result.GetResult<Prisma.$DiseasePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Diseases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseCountArgs} args - Arguments to filter Diseases to count.
     * @example
     * // Count the number of Diseases
     * const count = await prisma.disease.count({
     *   where: {
     *     // ... the filter for the Diseases we want to count
     *   }
     * })
    **/
    count<T extends DiseaseCountArgs>(
      args?: Subset<T, DiseaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiseaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiseaseAggregateArgs>(args: Subset<T, DiseaseAggregateArgs>): Prisma.PrismaPromise<GetDiseaseAggregateType<T>>

    /**
     * Group by Disease.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiseaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiseaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiseaseGroupByArgs['orderBy'] }
        : { orderBy?: DiseaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiseaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiseaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Disease model
   */
  readonly fields: DiseaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Disease.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiseaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    claims<T extends Disease$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Disease$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Disease model
   */ 
  interface DiseaseFieldRefs {
    readonly id: FieldRef<"Disease", 'Int'>
    readonly code: FieldRef<"Disease", 'String'>
    readonly name: FieldRef<"Disease", 'String'>
    readonly createdAt: FieldRef<"Disease", 'DateTime'>
    readonly updatedAt: FieldRef<"Disease", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Disease findUnique
   */
  export type DiseaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter, which Disease to fetch.
     */
    where: DiseaseWhereUniqueInput
  }


  /**
   * Disease findUniqueOrThrow
   */
  export type DiseaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter, which Disease to fetch.
     */
    where: DiseaseWhereUniqueInput
  }


  /**
   * Disease findFirst
   */
  export type DiseaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter, which Disease to fetch.
     */
    where?: DiseaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diseases to fetch.
     */
    orderBy?: DiseaseOrderByWithRelationInput | DiseaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diseases.
     */
    cursor?: DiseaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diseases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diseases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diseases.
     */
    distinct?: DiseaseScalarFieldEnum | DiseaseScalarFieldEnum[]
  }


  /**
   * Disease findFirstOrThrow
   */
  export type DiseaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter, which Disease to fetch.
     */
    where?: DiseaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diseases to fetch.
     */
    orderBy?: DiseaseOrderByWithRelationInput | DiseaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diseases.
     */
    cursor?: DiseaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diseases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diseases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diseases.
     */
    distinct?: DiseaseScalarFieldEnum | DiseaseScalarFieldEnum[]
  }


  /**
   * Disease findMany
   */
  export type DiseaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter, which Diseases to fetch.
     */
    where?: DiseaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diseases to fetch.
     */
    orderBy?: DiseaseOrderByWithRelationInput | DiseaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diseases.
     */
    cursor?: DiseaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diseases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diseases.
     */
    skip?: number
    distinct?: DiseaseScalarFieldEnum | DiseaseScalarFieldEnum[]
  }


  /**
   * Disease create
   */
  export type DiseaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Disease.
     */
    data: XOR<DiseaseCreateInput, DiseaseUncheckedCreateInput>
  }


  /**
   * Disease createMany
   */
  export type DiseaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diseases.
     */
    data: DiseaseCreateManyInput | DiseaseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Disease update
   */
  export type DiseaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Disease.
     */
    data: XOR<DiseaseUpdateInput, DiseaseUncheckedUpdateInput>
    /**
     * Choose, which Disease to update.
     */
    where: DiseaseWhereUniqueInput
  }


  /**
   * Disease updateMany
   */
  export type DiseaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diseases.
     */
    data: XOR<DiseaseUpdateManyMutationInput, DiseaseUncheckedUpdateManyInput>
    /**
     * Filter which Diseases to update
     */
    where?: DiseaseWhereInput
  }


  /**
   * Disease upsert
   */
  export type DiseaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Disease to update in case it exists.
     */
    where: DiseaseWhereUniqueInput
    /**
     * In case the Disease found by the `where` argument doesn't exist, create a new Disease with this data.
     */
    create: XOR<DiseaseCreateInput, DiseaseUncheckedCreateInput>
    /**
     * In case the Disease was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiseaseUpdateInput, DiseaseUncheckedUpdateInput>
  }


  /**
   * Disease delete
   */
  export type DiseaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
    /**
     * Filter which Disease to delete.
     */
    where: DiseaseWhereUniqueInput
  }


  /**
   * Disease deleteMany
   */
  export type DiseaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diseases to delete
     */
    where?: DiseaseWhereInput
  }


  /**
   * Disease.claims
   */
  export type Disease$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Disease without action
   */
  export type DiseaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Disease
     */
    select?: DiseaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DiseaseInclude<ExtArgs> | null
  }



  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicAvgAggregateOutputType = {
    id: number | null
  }

  export type ClinicSumAggregateOutputType = {
    id: number | null
  }

  export type ClinicMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    code: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicAvgAggregateInputType = {
    id?: true
  }

  export type ClinicSumAggregateInputType = {
    id?: true
  }

  export type ClinicMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _avg?: ClinicAvgAggregateInputType
    _sum?: ClinicSumAggregateInputType
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: number
    code: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claims?: boolean | Clinic$claimsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | Clinic$claimsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      claims: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }


  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClinicFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Clinic that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClinicFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClinicFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
    **/
    create<T extends ClinicCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clinics.
     *     @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     *     @example
     *     // Create many Clinics
     *     const clinic = await prisma.clinic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClinicCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
    **/
    delete<T extends ClinicDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClinicUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClinicDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClinicUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
    **/
    upsert<T extends ClinicUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>
    ): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    claims<T extends Clinic$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Clinic model
   */ 
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'Int'>
    readonly code: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }


  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }


  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }


  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }


  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }


  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }


  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }


  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
  }


  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }


  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }


  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
  }


  /**
   * Clinic.claims
   */
  export type Clinic$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }


  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClinicInclude<ExtArgs> | null
  }



  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    currentBalance: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    currentBalance: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    currentBalance: number | null
    currentBalanceLastUpdate: Date | null
    participantId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    currentBalance: number | null
    currentBalanceLastUpdate: Date | null
    participantId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    currentBalance: number
    currentBalanceLastUpdate: number
    participantId: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    currentBalance?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    currentBalance?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    currentBalance?: true
    currentBalanceLastUpdate?: true
    participantId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    currentBalance?: true
    currentBalanceLastUpdate?: true
    participantId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    currentBalance?: true
    currentBalanceLastUpdate?: true
    participantId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    currentBalance: number
    currentBalanceLastUpdate: Date | null
    participantId: string
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentBalance?: boolean
    currentBalanceLastUpdate?: boolean
    participantId?: boolean
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    programParticipation?: boolean | Account$programParticipationArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    currentBalance?: boolean
    currentBalanceLastUpdate?: boolean
    participantId?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ParticipantDefaultArgs<ExtArgs>
    transactions?: boolean | Account$transactionsArgs<ExtArgs>
    programParticipation?: boolean | Account$programParticipationArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      participant: Prisma.$ParticipantPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      programParticipation: Prisma.$ProgramParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Sisa Plafon:	Sisa Plafon Santunan Harian Rawat Inap
       */
      currentBalance: number
      currentBalanceLastUpdate: Date | null
      participantId: string
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    participant<T extends ParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipantDefaultArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    transactions<T extends Account$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findMany'> | Null>;

    programParticipation<T extends Account$programParticipationArgs<ExtArgs> = {}>(args?: Subset<T, Account$programParticipationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly currentBalance: FieldRef<"Account", 'Float'>
    readonly currentBalanceLastUpdate: FieldRef<"Account", 'DateTime'>
    readonly participantId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account.transactions
   */
  export type Account$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Account.programParticipation
   */
  export type Account$programParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    cursor?: ProgramParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    accountId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    amount: number | null
    accountId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    amount: number | null
    transactionType: $Enums.TransactionType | null
    description: string | null
    createdAt: Date | null
    accountId: number | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    transactionType: $Enums.TransactionType | null
    description: string | null
    createdAt: Date | null
    accountId: number | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    amount: number
    transactionType: number
    description: number
    createdAt: number
    accountId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    amount?: true
    accountId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    amount?: true
    accountId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    amount?: true
    transactionType?: true
    description?: true
    createdAt?: true
    accountId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    amount?: true
    transactionType?: true
    description?: true
    createdAt?: true
    accountId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    amount?: true
    transactionType?: true
    description?: true
    createdAt?: true
    accountId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    amount: number
    transactionType: $Enums.TransactionType
    description: string | null
    createdAt: Date
    accountId: number
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionType?: boolean
    description?: boolean
    createdAt?: boolean
    accountId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    amount?: boolean
    transactionType?: boolean
    description?: boolean
    createdAt?: boolean
    accountId?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      transactionType: $Enums.TransactionType
      description: string | null
      createdAt: Date
      accountId: number
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }


  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>
    ): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly transactionType: FieldRef<"Transaction", 'TransactionType'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly accountId: FieldRef<"Transaction", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    password: 'password',
    profilePictureUrl: 'profilePictureUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    roleId: 'roleId',
    participantId: 'participantId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    higherLevelThanId: 'higherLevelThanId'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permission: 'permission'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const ParticipantScalarFieldEnum: {
    gender: 'gender',
    birthDate: 'birthDate',
    isActive: 'isActive',
    status: 'status',
    userId: 'userId',
    relationId: 'relationId',
    bankAccountId: 'bankAccountId'
  };

  export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


  export const ContactInfoScalarFieldEnum: {
    id: 'id',
    telp: 'telp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    participantId: 'participantId',
    addressId: 'addressId'
  };

  export type ContactInfoScalarFieldEnum = (typeof ContactInfoScalarFieldEnum)[keyof typeof ContactInfoScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    address: 'address',
    cityId: 'cityId',
    postalCode: 'postalCode'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    participantId: 'participantId'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const EmploymentScalarFieldEnum: {
    id: 'id',
    employmentPosition: 'employmentPosition',
    participantId: 'participantId',
    branchId: 'branchId',
    groupId: 'groupId',
    regionId: 'regionId'
  };

  export type EmploymentScalarFieldEnum = (typeof EmploymentScalarFieldEnum)[keyof typeof EmploymentScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    content: 'content',
    createdAt: 'createdAt',
    isRead: 'isRead',
    isCleared: 'isCleared',
    deepLink: 'deepLink',
    fcmToken: 'fcmToken',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ProgramParticipationScalarFieldEnum: {
    id: 'id',
    bpjsNumber: 'bpjsNumber',
    nonActiveReason: 'nonActiveReason',
    effectiveDate: 'effectiveDate',
    nonActiveDate: 'nonActiveDate',
    participantId: 'participantId',
    fundingId: 'fundingId',
    programId: 'programId'
  };

  export type ProgramParticipationScalarFieldEnum = (typeof ProgramParticipationScalarFieldEnum)[keyof typeof ProgramParticipationScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    plan: 'plan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    allowanceCeiling: 'allowanceCeiling',
    class: 'class',
    maxAllowance: 'maxAllowance'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    channel: 'channel',
    admedicaStatus: 'admedicaStatus',
    company: 'company',
    participantId: 'participantId',
    claimFinancialId: 'claimFinancialId',
    claimProcessId: 'claimProcessId',
    diseaseId: 'diseaseId',
    clinicId: 'clinicId',
    inputedById: 'inputedById',
    claimTypeId: 'claimTypeId'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    path: 'path',
    size: 'size',
    printCount: 'printCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    source: 'source',
    type: 'type',
    claimProcessId: 'claimProcessId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ClaimTypeScalarFieldEnum: {
    id: 'id',
    jenis: 'jenis',
    jenisRI: 'jenisRI',
    plan: 'plan',
    programId: 'programId',
    claimId: 'claimId'
  };

  export type ClaimTypeScalarFieldEnum = (typeof ClaimTypeScalarFieldEnum)[keyof typeof ClaimTypeScalarFieldEnum]


  export const ClaimFinancialScalarFieldEnum: {
    id: 'id',
    requestedAmount: 'requestedAmount',
    paidAmount: 'paidAmount',
    rejectedAmount: 'rejectedAmount',
    transactionProcessDate: 'transactionProcessDate',
    transferDate: 'transferDate',
    claimId: 'claimId',
    branchId: 'branchId',
    claimStatusId: 'claimStatusId'
  };

  export type ClaimFinancialScalarFieldEnum = (typeof ClaimFinancialScalarFieldEnum)[keyof typeof ClaimFinancialScalarFieldEnum]


  export const ClaimProcessScalarFieldEnum: {
    id: 'id',
    startTreatment: 'startTreatment',
    endTreatment: 'endTreatment',
    expeditionDate: 'expeditionDate',
    reclaim: 'reclaim',
    processDate: 'processDate',
    submissionNote: 'submissionNote',
    description: 'description',
    additionalNote: 'additionalNote',
    claimId: 'claimId'
  };

  export type ClaimProcessScalarFieldEnum = (typeof ClaimProcessScalarFieldEnum)[keyof typeof ClaimProcessScalarFieldEnum]


  export const ClaimStatusScalarFieldEnum: {
    id: 'id',
    description: 'description',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    status: 'status',
    createById: 'createById',
    claimId: 'claimId',
    rejectionLetterId: 'rejectionLetterId',
    guaranteeLetterId: 'guaranteeLetterId',
    transactionLetterId: 'transactionLetterId',
    bookKeepingOrderId: 'bookKeepingOrderId'
  };

  export type ClaimStatusScalarFieldEnum = (typeof ClaimStatusScalarFieldEnum)[keyof typeof ClaimStatusScalarFieldEnum]


  export const DiseaseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiseaseScalarFieldEnum = (typeof DiseaseScalarFieldEnum)[keyof typeof DiseaseScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    currentBalance: 'currentBalance',
    currentBalanceLastUpdate: 'currentBalanceLastUpdate',
    participantId: 'participantId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    transactionType: 'transactionType',
    description: 'description',
    createdAt: 'createdAt',
    accountId: 'accountId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ParticipantStatus'
   */
  export type EnumParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantStatus'>
    


  /**
   * Reference to a field of type 'ParticipantStatus[]'
   */
  export type ListEnumParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Position'
   */
  export type EnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position'>
    


  /**
   * Reference to a field of type 'Position[]'
   */
  export type ListEnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position[]'>
    


  /**
   * Reference to a field of type 'ApplicationType'
   */
  export type EnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType'>
    


  /**
   * Reference to a field of type 'ApplicationType[]'
   */
  export type ListEnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType[]'>
    


  /**
   * Reference to a field of type 'Class'
   */
  export type EnumClassFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Class'>
    


  /**
   * Reference to a field of type 'Class[]'
   */
  export type ListEnumClassFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Class[]'>
    


  /**
   * Reference to a field of type 'ClaimChannel'
   */
  export type EnumClaimChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimChannel'>
    


  /**
   * Reference to a field of type 'ClaimChannel[]'
   */
  export type ListEnumClaimChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimChannel[]'>
    


  /**
   * Reference to a field of type 'AdmedicaStatus'
   */
  export type EnumAdmedicaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmedicaStatus'>
    


  /**
   * Reference to a field of type 'AdmedicaStatus[]'
   */
  export type ListEnumAdmedicaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmedicaStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentSource'
   */
  export type EnumDocumentSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSource'>
    


  /**
   * Reference to a field of type 'DocumentSource[]'
   */
  export type ListEnumDocumentSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentSource[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Color'
   */
  export type EnumColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Color'>
    


  /**
   * Reference to a field of type 'Color[]'
   */
  export type ListEnumColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Color[]'>
    


  /**
   * Reference to a field of type 'ClaimStatusType'
   */
  export type EnumClaimStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatusType'>
    


  /**
   * Reference to a field of type 'ClaimStatusType[]'
   */
  export type ListEnumClaimStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatusType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    roleId?: IntFilter<"User"> | number
    participantId?: IntNullableFilter<"User"> | number | null
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    participant?: XOR<ParticipantNullableRelationFilter, ParticipantWhereInput> | null
    claimsInput?: ClaimListRelationFilter
    claimActions?: ClaimStatusListRelationFilter
    announcementCreated?: AnnouncementListRelationFilter
    notification?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
    claimsInput?: ClaimOrderByRelationAggregateInput
    claimActions?: ClaimStatusOrderByRelationAggregateInput
    announcementCreated?: AnnouncementOrderByRelationAggregateInput
    notification?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    roleId?: IntFilter<"User"> | number
    participantId?: IntNullableFilter<"User"> | number | null
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    participant?: XOR<ParticipantNullableRelationFilter, ParticipantWhereInput> | null
    claimsInput?: ClaimListRelationFilter
    claimActions?: ClaimStatusListRelationFilter
    announcementCreated?: AnnouncementListRelationFilter
    notification?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    roleId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    profilePictureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    roleId?: IntWithAggregatesFilter<"User"> | number
    participantId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    order?: IntFilter<"Role"> | number
    higherLevelThanId?: IntNullableFilter<"Role"> | number | null
    higherLevelThan?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    rolePermissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
    lowerLevelThan?: RoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrderInput | SortOrder
    higherLevelThan?: RoleOrderByWithRelationInput
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    lowerLevelThan?: RoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    order?: IntFilter<"Role"> | number
    higherLevelThanId?: IntNullableFilter<"Role"> | number | null
    higherLevelThan?: XOR<RoleNullableRelationFilter, RoleWhereInput> | null
    rolePermissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
    lowerLevelThan?: RoleListRelationFilter
  }, "id">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    order?: IntWithAggregatesFilter<"Role"> | number
    higherLevelThanId?: IntNullableWithAggregatesFilter<"Role"> | number | null
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permission?: EnumPermissionFilter<"RolePermission"> | $Enums.Permission
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permission?: SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permission?: RolePermissionRoleIdPermissionCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permission?: EnumPermissionFilter<"RolePermission"> | $Enums.Permission
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "roleId_permission">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permission?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permission?: EnumPermissionWithAggregatesFilter<"RolePermission"> | $Enums.Permission
  }

  export type ParticipantWhereInput = {
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    gender?: EnumGenderFilter<"Participant"> | $Enums.Gender
    birthDate?: DateTimeFilter<"Participant"> | Date | string
    isActive?: BoolFilter<"Participant"> | boolean
    status?: EnumParticipantStatusFilter<"Participant"> | $Enums.ParticipantStatus
    userId?: StringFilter<"Participant"> | string
    relationId?: StringNullableFilter<"Participant"> | string | null
    bankAccountId?: IntFilter<"Participant"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    relation?: XOR<ParticipantNullableRelationFilter, ParticipantWhereInput> | null
    bankAccount?: XOR<BankAccountNullableRelationFilter, BankAccountWhereInput> | null
    claims?: ClaimListRelationFilter
    employments?: EmploymentListRelationFilter
    contactInfos?: ContactInfoListRelationFilter
    programParticipations?: ProgramParticipationListRelationFilter
    balances?: AccountListRelationFilter
    Participant?: ParticipantListRelationFilter
  }

  export type ParticipantOrderByWithRelationInput = {
    gender?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    relationId?: SortOrderInput | SortOrder
    bankAccountId?: SortOrder
    user?: UserOrderByWithRelationInput
    relation?: ParticipantOrderByWithRelationInput
    bankAccount?: BankAccountOrderByWithRelationInput
    claims?: ClaimOrderByRelationAggregateInput
    employments?: EmploymentOrderByRelationAggregateInput
    contactInfos?: ContactInfoOrderByRelationAggregateInput
    programParticipations?: ProgramParticipationOrderByRelationAggregateInput
    balances?: AccountOrderByRelationAggregateInput
    Participant?: ParticipantOrderByRelationAggregateInput
  }

  export type ParticipantWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    gender?: EnumGenderFilter<"Participant"> | $Enums.Gender
    birthDate?: DateTimeFilter<"Participant"> | Date | string
    isActive?: BoolFilter<"Participant"> | boolean
    status?: EnumParticipantStatusFilter<"Participant"> | $Enums.ParticipantStatus
    relationId?: StringNullableFilter<"Participant"> | string | null
    bankAccountId?: IntFilter<"Participant"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    relation?: XOR<ParticipantNullableRelationFilter, ParticipantWhereInput> | null
    bankAccount?: XOR<BankAccountNullableRelationFilter, BankAccountWhereInput> | null
    claims?: ClaimListRelationFilter
    employments?: EmploymentListRelationFilter
    contactInfos?: ContactInfoListRelationFilter
    programParticipations?: ProgramParticipationListRelationFilter
    balances?: AccountListRelationFilter
    Participant?: ParticipantListRelationFilter
  }, "userId">

  export type ParticipantOrderByWithAggregationInput = {
    gender?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    relationId?: SortOrderInput | SortOrder
    bankAccountId?: SortOrder
    _count?: ParticipantCountOrderByAggregateInput
    _avg?: ParticipantAvgOrderByAggregateInput
    _max?: ParticipantMaxOrderByAggregateInput
    _min?: ParticipantMinOrderByAggregateInput
    _sum?: ParticipantSumOrderByAggregateInput
  }

  export type ParticipantScalarWhereWithAggregatesInput = {
    AND?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    OR?: ParticipantScalarWhereWithAggregatesInput[]
    NOT?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    gender?: EnumGenderWithAggregatesFilter<"Participant"> | $Enums.Gender
    birthDate?: DateTimeWithAggregatesFilter<"Participant"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Participant"> | boolean
    status?: EnumParticipantStatusWithAggregatesFilter<"Participant"> | $Enums.ParticipantStatus
    userId?: StringWithAggregatesFilter<"Participant"> | string
    relationId?: StringNullableWithAggregatesFilter<"Participant"> | string | null
    bankAccountId?: IntWithAggregatesFilter<"Participant"> | number
  }

  export type ContactInfoWhereInput = {
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    id?: IntFilter<"ContactInfo"> | number
    telp?: StringFilter<"ContactInfo"> | string
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContactInfo"> | Date | string | null
    participantId?: StringFilter<"ContactInfo"> | string
    addressId?: IntFilter<"ContactInfo"> | number
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    address?: XOR<AddressRelationFilter, AddressWhereInput>
  }

  export type ContactInfoOrderByWithRelationInput = {
    id?: SortOrder
    telp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    participantId?: SortOrder
    addressId?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
  }

  export type ContactInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactInfoWhereInput | ContactInfoWhereInput[]
    OR?: ContactInfoWhereInput[]
    NOT?: ContactInfoWhereInput | ContactInfoWhereInput[]
    telp?: StringFilter<"ContactInfo"> | string
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContactInfo"> | Date | string | null
    participantId?: StringFilter<"ContactInfo"> | string
    addressId?: IntFilter<"ContactInfo"> | number
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    address?: XOR<AddressRelationFilter, AddressWhereInput>
  }, "id">

  export type ContactInfoOrderByWithAggregationInput = {
    id?: SortOrder
    telp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    participantId?: SortOrder
    addressId?: SortOrder
    _count?: ContactInfoCountOrderByAggregateInput
    _avg?: ContactInfoAvgOrderByAggregateInput
    _max?: ContactInfoMaxOrderByAggregateInput
    _min?: ContactInfoMinOrderByAggregateInput
    _sum?: ContactInfoSumOrderByAggregateInput
  }

  export type ContactInfoScalarWhereWithAggregatesInput = {
    AND?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    OR?: ContactInfoScalarWhereWithAggregatesInput[]
    NOT?: ContactInfoScalarWhereWithAggregatesInput | ContactInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactInfo"> | number
    telp?: StringWithAggregatesFilter<"ContactInfo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactInfo"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ContactInfo"> | Date | string | null
    participantId?: StringWithAggregatesFilter<"ContactInfo"> | string
    addressId?: IntWithAggregatesFilter<"ContactInfo"> | number
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    address?: StringFilter<"Address"> | string
    cityId?: IntFilter<"Address"> | number
    postalCode?: StringFilter<"Address"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    ContactInfo?: ContactInfoListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
    city?: CityOrderByWithRelationInput
    ContactInfo?: ContactInfoOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    address?: StringFilter<"Address"> | string
    cityId?: IntFilter<"Address"> | number
    postalCode?: StringFilter<"Address"> | string
    city?: XOR<CityRelationFilter, CityWhereInput>
    ContactInfo?: ContactInfoListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    address?: StringWithAggregatesFilter<"Address"> | string
    cityId?: IntWithAggregatesFilter<"Address"> | number
    postalCode?: StringWithAggregatesFilter<"Address"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: IntFilter<"City"> | number
    name?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    address?: AddressListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    address?: AddressOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    name?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    address?: AddressListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"City"> | number
    name?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: IntFilter<"BankAccount"> | number
    accountNumber?: FloatFilter<"BankAccount"> | number
    accountName?: StringFilter<"BankAccount"> | string
    participantId?: StringFilter<"BankAccount"> | string
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    participantId?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    participantId?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    accountNumber?: FloatFilter<"BankAccount"> | number
    accountName?: StringFilter<"BankAccount"> | string
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
  }, "id" | "participantId">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    participantId?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BankAccount"> | number
    accountNumber?: FloatWithAggregatesFilter<"BankAccount"> | number
    accountName?: StringWithAggregatesFilter<"BankAccount"> | string
    participantId?: StringWithAggregatesFilter<"BankAccount"> | string
  }

  export type EmploymentWhereInput = {
    AND?: EmploymentWhereInput | EmploymentWhereInput[]
    OR?: EmploymentWhereInput[]
    NOT?: EmploymentWhereInput | EmploymentWhereInput[]
    id?: IntFilter<"Employment"> | number
    employmentPosition?: EnumPositionFilter<"Employment"> | $Enums.Position
    participantId?: StringFilter<"Employment"> | string
    branchId?: IntFilter<"Employment"> | number
    groupId?: IntFilter<"Employment"> | number
    regionId?: IntFilter<"Employment"> | number
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
  }

  export type EmploymentOrderByWithRelationInput = {
    id?: SortOrder
    employmentPosition?: SortOrder
    participantId?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    region?: RegionOrderByWithRelationInput
  }

  export type EmploymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmploymentWhereInput | EmploymentWhereInput[]
    OR?: EmploymentWhereInput[]
    NOT?: EmploymentWhereInput | EmploymentWhereInput[]
    employmentPosition?: EnumPositionFilter<"Employment"> | $Enums.Position
    participantId?: StringFilter<"Employment"> | string
    branchId?: IntFilter<"Employment"> | number
    groupId?: IntFilter<"Employment"> | number
    regionId?: IntFilter<"Employment"> | number
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    region?: XOR<RegionNullableRelationFilter, RegionWhereInput> | null
  }, "id">

  export type EmploymentOrderByWithAggregationInput = {
    id?: SortOrder
    employmentPosition?: SortOrder
    participantId?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
    _count?: EmploymentCountOrderByAggregateInput
    _avg?: EmploymentAvgOrderByAggregateInput
    _max?: EmploymentMaxOrderByAggregateInput
    _min?: EmploymentMinOrderByAggregateInput
    _sum?: EmploymentSumOrderByAggregateInput
  }

  export type EmploymentScalarWhereWithAggregatesInput = {
    AND?: EmploymentScalarWhereWithAggregatesInput | EmploymentScalarWhereWithAggregatesInput[]
    OR?: EmploymentScalarWhereWithAggregatesInput[]
    NOT?: EmploymentScalarWhereWithAggregatesInput | EmploymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employment"> | number
    employmentPosition?: EnumPositionWithAggregatesFilter<"Employment"> | $Enums.Position
    participantId?: StringWithAggregatesFilter<"Employment"> | string
    branchId?: IntWithAggregatesFilter<"Employment"> | number
    groupId?: IntWithAggregatesFilter<"Employment"> | number
    regionId?: IntWithAggregatesFilter<"Employment"> | number
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    employment?: EmploymentListRelationFilter
    claimFinancial?: ClaimFinancialListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employment?: EmploymentOrderByRelationAggregateInput
    claimFinancial?: ClaimFinancialOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    employment?: EmploymentListRelationFilter
    claimFinancial?: ClaimFinancialListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    employment?: EmploymentListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employment?: EmploymentOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    employment?: EmploymentListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    name?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    employment?: EmploymentListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employment?: EmploymentOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    createdAt?: DateTimeFilter<"Region"> | Date | string
    updatedAt?: DateTimeFilter<"Region"> | Date | string
    employment?: EmploymentListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdById?: StringFilter<"Announcement"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdById?: StringFilter<"Announcement"> | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _avg?: AnnouncementAvgOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
    _sum?: AnnouncementSumOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Announcement"> | number
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    createdById?: StringWithAggregatesFilter<"Announcement"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    subtitle?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    isCleared?: BoolFilter<"Notification"> | boolean
    deepLink?: StringNullableFilter<"Notification"> | string | null
    fcmToken?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    isCleared?: SortOrder
    deepLink?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    subtitle?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    isCleared?: BoolFilter<"Notification"> | boolean
    deepLink?: StringNullableFilter<"Notification"> | string | null
    fcmToken?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    isCleared?: SortOrder
    deepLink?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    subtitle?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    isCleared?: BoolWithAggregatesFilter<"Notification"> | boolean
    deepLink?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    fcmToken?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type ProgramParticipationWhereInput = {
    AND?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    OR?: ProgramParticipationWhereInput[]
    NOT?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    id?: IntFilter<"ProgramParticipation"> | number
    bpjsNumber?: StringNullableFilter<"ProgramParticipation"> | string | null
    nonActiveReason?: StringNullableFilter<"ProgramParticipation"> | string | null
    effectiveDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    nonActiveDate?: DateTimeNullableFilter<"ProgramParticipation"> | Date | string | null
    participantId?: StringFilter<"ProgramParticipation"> | string
    fundingId?: IntFilter<"ProgramParticipation"> | number
    programId?: IntNullableFilter<"ProgramParticipation"> | number | null
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    funding?: XOR<AccountRelationFilter, AccountWhereInput>
    Program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
  }

  export type ProgramParticipationOrderByWithRelationInput = {
    id?: SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    nonActiveReason?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    nonActiveDate?: SortOrderInput | SortOrder
    participantId?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrderInput | SortOrder
    participant?: ParticipantOrderByWithRelationInput
    funding?: AccountOrderByWithRelationInput
    Program?: ProgramOrderByWithRelationInput
  }

  export type ProgramParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    OR?: ProgramParticipationWhereInput[]
    NOT?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    bpjsNumber?: StringNullableFilter<"ProgramParticipation"> | string | null
    nonActiveReason?: StringNullableFilter<"ProgramParticipation"> | string | null
    effectiveDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    nonActiveDate?: DateTimeNullableFilter<"ProgramParticipation"> | Date | string | null
    participantId?: StringFilter<"ProgramParticipation"> | string
    fundingId?: IntFilter<"ProgramParticipation"> | number
    programId?: IntNullableFilter<"ProgramParticipation"> | number | null
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    funding?: XOR<AccountRelationFilter, AccountWhereInput>
    Program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
  }, "id">

  export type ProgramParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    bpjsNumber?: SortOrderInput | SortOrder
    nonActiveReason?: SortOrderInput | SortOrder
    effectiveDate?: SortOrder
    nonActiveDate?: SortOrderInput | SortOrder
    participantId?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrderInput | SortOrder
    _count?: ProgramParticipationCountOrderByAggregateInput
    _avg?: ProgramParticipationAvgOrderByAggregateInput
    _max?: ProgramParticipationMaxOrderByAggregateInput
    _min?: ProgramParticipationMinOrderByAggregateInput
    _sum?: ProgramParticipationSumOrderByAggregateInput
  }

  export type ProgramParticipationScalarWhereWithAggregatesInput = {
    AND?: ProgramParticipationScalarWhereWithAggregatesInput | ProgramParticipationScalarWhereWithAggregatesInput[]
    OR?: ProgramParticipationScalarWhereWithAggregatesInput[]
    NOT?: ProgramParticipationScalarWhereWithAggregatesInput | ProgramParticipationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramParticipation"> | number
    bpjsNumber?: StringNullableWithAggregatesFilter<"ProgramParticipation"> | string | null
    nonActiveReason?: StringNullableWithAggregatesFilter<"ProgramParticipation"> | string | null
    effectiveDate?: DateTimeWithAggregatesFilter<"ProgramParticipation"> | Date | string
    nonActiveDate?: DateTimeNullableWithAggregatesFilter<"ProgramParticipation"> | Date | string | null
    participantId?: StringWithAggregatesFilter<"ProgramParticipation"> | string
    fundingId?: IntWithAggregatesFilter<"ProgramParticipation"> | number
    programId?: IntNullableWithAggregatesFilter<"ProgramParticipation"> | number | null
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: IntFilter<"Program"> | number
    plan?: EnumApplicationTypeFilter<"Program"> | $Enums.ApplicationType
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    allowanceCeiling?: FloatFilter<"Program"> | number
    class?: EnumClassFilter<"Program"> | $Enums.Class
    maxAllowance?: FloatFilter<"Program"> | number
    programParticipations?: ProgramParticipationListRelationFilter
    claimType?: ClaimTypeListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    allowanceCeiling?: SortOrder
    class?: SortOrder
    maxAllowance?: SortOrder
    programParticipations?: ProgramParticipationOrderByRelationAggregateInput
    claimType?: ClaimTypeOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    plan?: EnumApplicationTypeFilter<"Program"> | $Enums.ApplicationType
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    allowanceCeiling?: FloatFilter<"Program"> | number
    class?: EnumClassFilter<"Program"> | $Enums.Class
    maxAllowance?: FloatFilter<"Program"> | number
    programParticipations?: ProgramParticipationListRelationFilter
    claimType?: ClaimTypeListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    allowanceCeiling?: SortOrder
    class?: SortOrder
    maxAllowance?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Program"> | number
    plan?: EnumApplicationTypeWithAggregatesFilter<"Program"> | $Enums.ApplicationType
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    allowanceCeiling?: FloatWithAggregatesFilter<"Program"> | number
    class?: EnumClassWithAggregatesFilter<"Program"> | $Enums.Class
    maxAllowance?: FloatWithAggregatesFilter<"Program"> | number
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    channel?: EnumClaimChannelFilter<"Claim"> | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFilter<"Claim"> | $Enums.AdmedicaStatus
    company?: StringFilter<"Claim"> | string
    participantId?: StringFilter<"Claim"> | string
    claimFinancialId?: IntFilter<"Claim"> | number
    claimProcessId?: IntFilter<"Claim"> | number
    diseaseId?: IntNullableFilter<"Claim"> | number | null
    clinicId?: IntFilter<"Claim"> | number
    inputedById?: StringNullableFilter<"Claim"> | string | null
    claimTypeId?: IntFilter<"Claim"> | number
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    claimFinancials?: XOR<ClaimFinancialRelationFilter, ClaimFinancialWhereInput>
    claimProcesses?: XOR<ClaimProcessRelationFilter, ClaimProcessWhereInput>
    disease?: XOR<DiseaseNullableRelationFilter, DiseaseWhereInput> | null
    clinics?: XOR<ClinicRelationFilter, ClinicWhereInput>
    inputedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    claimTypes?: XOR<ClaimTypeRelationFilter, ClaimTypeWhereInput>
    tags?: TagListRelationFilter
    claimStatuses?: ClaimStatusListRelationFilter
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    channel?: SortOrder
    admedicaStatus?: SortOrder
    company?: SortOrder
    participantId?: SortOrder
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    inputedById?: SortOrderInput | SortOrder
    claimTypeId?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
    claimFinancials?: ClaimFinancialOrderByWithRelationInput
    claimProcesses?: ClaimProcessOrderByWithRelationInput
    disease?: DiseaseOrderByWithRelationInput
    clinics?: ClinicOrderByWithRelationInput
    inputedBy?: UserOrderByWithRelationInput
    claimTypes?: ClaimTypeOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    claimStatuses?: ClaimStatusOrderByRelationAggregateInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimFinancialId?: number
    claimProcessId?: number
    claimTypeId?: number
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    channel?: EnumClaimChannelFilter<"Claim"> | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFilter<"Claim"> | $Enums.AdmedicaStatus
    company?: StringFilter<"Claim"> | string
    participantId?: StringFilter<"Claim"> | string
    diseaseId?: IntNullableFilter<"Claim"> | number | null
    clinicId?: IntFilter<"Claim"> | number
    inputedById?: StringNullableFilter<"Claim"> | string | null
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    claimFinancials?: XOR<ClaimFinancialRelationFilter, ClaimFinancialWhereInput>
    claimProcesses?: XOR<ClaimProcessRelationFilter, ClaimProcessWhereInput>
    disease?: XOR<DiseaseNullableRelationFilter, DiseaseWhereInput> | null
    clinics?: XOR<ClinicRelationFilter, ClinicWhereInput>
    inputedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    claimTypes?: XOR<ClaimTypeRelationFilter, ClaimTypeWhereInput>
    tags?: TagListRelationFilter
    claimStatuses?: ClaimStatusListRelationFilter
  }, "id" | "claimFinancialId" | "claimProcessId" | "claimTypeId">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    channel?: SortOrder
    admedicaStatus?: SortOrder
    company?: SortOrder
    participantId?: SortOrder
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrderInput | SortOrder
    clinicId?: SortOrder
    inputedById?: SortOrderInput | SortOrder
    claimTypeId?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    channel?: EnumClaimChannelWithAggregatesFilter<"Claim"> | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusWithAggregatesFilter<"Claim"> | $Enums.AdmedicaStatus
    company?: StringWithAggregatesFilter<"Claim"> | string
    participantId?: StringWithAggregatesFilter<"Claim"> | string
    claimFinancialId?: IntWithAggregatesFilter<"Claim"> | number
    claimProcessId?: IntWithAggregatesFilter<"Claim"> | number
    diseaseId?: IntNullableWithAggregatesFilter<"Claim"> | number | null
    clinicId?: IntWithAggregatesFilter<"Claim"> | number
    inputedById?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    claimTypeId?: IntWithAggregatesFilter<"Claim"> | number
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    printCount?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    source?: EnumDocumentSourceFilter<"Document"> | $Enums.DocumentSource
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    claimProcessId?: IntNullableFilter<"Document"> | number | null
    rejectionLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    guaranteeLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    transactionLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    bookKeepingOrderOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    claimProcess?: XOR<ClaimProcessNullableRelationFilter, ClaimProcessWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    printCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    type?: SortOrder
    claimProcessId?: SortOrderInput | SortOrder
    rejectionLetterOf?: ClaimStatusOrderByWithRelationInput
    guaranteeLetterOf?: ClaimStatusOrderByWithRelationInput
    transactionLetterOf?: ClaimStatusOrderByWithRelationInput
    bookKeepingOrderOf?: ClaimStatusOrderByWithRelationInput
    claimProcess?: ClaimProcessOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    name?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    printCount?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    source?: EnumDocumentSourceFilter<"Document"> | $Enums.DocumentSource
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    claimProcessId?: IntNullableFilter<"Document"> | number | null
    rejectionLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    guaranteeLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    transactionLetterOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    bookKeepingOrderOf?: XOR<ClaimStatusNullableRelationFilter, ClaimStatusWhereInput> | null
    claimProcess?: XOR<ClaimProcessNullableRelationFilter, ClaimProcessWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    printCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    type?: SortOrder
    claimProcessId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    name?: StringWithAggregatesFilter<"Document"> | string
    path?: StringWithAggregatesFilter<"Document"> | string
    size?: IntWithAggregatesFilter<"Document"> | number
    printCount?: IntWithAggregatesFilter<"Document"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    source?: EnumDocumentSourceWithAggregatesFilter<"Document"> | $Enums.DocumentSource
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    claimProcessId?: IntNullableWithAggregatesFilter<"Document"> | number | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: EnumColorFilter<"Tag"> | $Enums.Color
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    Claims?: ClaimListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Claims?: ClaimOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    color?: EnumColorFilter<"Tag"> | $Enums.Color
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    Claims?: ClaimListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: EnumColorWithAggregatesFilter<"Tag"> | $Enums.Color
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ClaimTypeWhereInput = {
    AND?: ClaimTypeWhereInput | ClaimTypeWhereInput[]
    OR?: ClaimTypeWhereInput[]
    NOT?: ClaimTypeWhereInput | ClaimTypeWhereInput[]
    id?: IntFilter<"ClaimType"> | number
    jenis?: StringFilter<"ClaimType"> | string
    jenisRI?: StringFilter<"ClaimType"> | string
    plan?: StringFilter<"ClaimType"> | string
    programId?: IntFilter<"ClaimType"> | number
    claimId?: IntFilter<"ClaimType"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    claims?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }

  export type ClaimTypeOrderByWithRelationInput = {
    id?: SortOrder
    jenis?: SortOrder
    jenisRI?: SortOrder
    plan?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
    program?: ProgramOrderByWithRelationInput
    claims?: ClaimOrderByWithRelationInput
  }

  export type ClaimTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    claimId?: number
    AND?: ClaimTypeWhereInput | ClaimTypeWhereInput[]
    OR?: ClaimTypeWhereInput[]
    NOT?: ClaimTypeWhereInput | ClaimTypeWhereInput[]
    jenis?: StringFilter<"ClaimType"> | string
    jenisRI?: StringFilter<"ClaimType"> | string
    plan?: StringFilter<"ClaimType"> | string
    programId?: IntFilter<"ClaimType"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    claims?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
  }, "id" | "claimId">

  export type ClaimTypeOrderByWithAggregationInput = {
    id?: SortOrder
    jenis?: SortOrder
    jenisRI?: SortOrder
    plan?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
    _count?: ClaimTypeCountOrderByAggregateInput
    _avg?: ClaimTypeAvgOrderByAggregateInput
    _max?: ClaimTypeMaxOrderByAggregateInput
    _min?: ClaimTypeMinOrderByAggregateInput
    _sum?: ClaimTypeSumOrderByAggregateInput
  }

  export type ClaimTypeScalarWhereWithAggregatesInput = {
    AND?: ClaimTypeScalarWhereWithAggregatesInput | ClaimTypeScalarWhereWithAggregatesInput[]
    OR?: ClaimTypeScalarWhereWithAggregatesInput[]
    NOT?: ClaimTypeScalarWhereWithAggregatesInput | ClaimTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClaimType"> | number
    jenis?: StringWithAggregatesFilter<"ClaimType"> | string
    jenisRI?: StringWithAggregatesFilter<"ClaimType"> | string
    plan?: StringWithAggregatesFilter<"ClaimType"> | string
    programId?: IntWithAggregatesFilter<"ClaimType"> | number
    claimId?: IntWithAggregatesFilter<"ClaimType"> | number
  }

  export type ClaimFinancialWhereInput = {
    AND?: ClaimFinancialWhereInput | ClaimFinancialWhereInput[]
    OR?: ClaimFinancialWhereInput[]
    NOT?: ClaimFinancialWhereInput | ClaimFinancialWhereInput[]
    id?: IntFilter<"ClaimFinancial"> | number
    requestedAmount?: FloatFilter<"ClaimFinancial"> | number
    paidAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    rejectedAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    transactionProcessDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    transferDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    claimId?: StringFilter<"ClaimFinancial"> | string
    branchId?: IntFilter<"ClaimFinancial"> | number
    claimStatusId?: IntFilter<"ClaimFinancial"> | number
    branchPayee?: XOR<BranchRelationFilter, BranchWhereInput>
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
    claimStatus?: XOR<ClaimStatusRelationFilter, ClaimStatusWhereInput>
  }

  export type ClaimFinancialOrderByWithRelationInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    rejectedAmount?: SortOrderInput | SortOrder
    transactionProcessDate?: SortOrderInput | SortOrder
    transferDate?: SortOrderInput | SortOrder
    claimId?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
    branchPayee?: BranchOrderByWithRelationInput
    claim?: ClaimOrderByWithRelationInput
    claimStatus?: ClaimStatusOrderByWithRelationInput
  }

  export type ClaimFinancialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    claimId?: string
    claimStatusId?: number
    AND?: ClaimFinancialWhereInput | ClaimFinancialWhereInput[]
    OR?: ClaimFinancialWhereInput[]
    NOT?: ClaimFinancialWhereInput | ClaimFinancialWhereInput[]
    requestedAmount?: FloatFilter<"ClaimFinancial"> | number
    paidAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    rejectedAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    transactionProcessDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    transferDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    branchId?: IntFilter<"ClaimFinancial"> | number
    branchPayee?: XOR<BranchRelationFilter, BranchWhereInput>
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
    claimStatus?: XOR<ClaimStatusRelationFilter, ClaimStatusWhereInput>
  }, "id" | "claimId" | "claimStatusId">

  export type ClaimFinancialOrderByWithAggregationInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    rejectedAmount?: SortOrderInput | SortOrder
    transactionProcessDate?: SortOrderInput | SortOrder
    transferDate?: SortOrderInput | SortOrder
    claimId?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
    _count?: ClaimFinancialCountOrderByAggregateInput
    _avg?: ClaimFinancialAvgOrderByAggregateInput
    _max?: ClaimFinancialMaxOrderByAggregateInput
    _min?: ClaimFinancialMinOrderByAggregateInput
    _sum?: ClaimFinancialSumOrderByAggregateInput
  }

  export type ClaimFinancialScalarWhereWithAggregatesInput = {
    AND?: ClaimFinancialScalarWhereWithAggregatesInput | ClaimFinancialScalarWhereWithAggregatesInput[]
    OR?: ClaimFinancialScalarWhereWithAggregatesInput[]
    NOT?: ClaimFinancialScalarWhereWithAggregatesInput | ClaimFinancialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClaimFinancial"> | number
    requestedAmount?: FloatWithAggregatesFilter<"ClaimFinancial"> | number
    paidAmount?: FloatNullableWithAggregatesFilter<"ClaimFinancial"> | number | null
    rejectedAmount?: FloatNullableWithAggregatesFilter<"ClaimFinancial"> | number | null
    transactionProcessDate?: DateTimeNullableWithAggregatesFilter<"ClaimFinancial"> | Date | string | null
    transferDate?: DateTimeNullableWithAggregatesFilter<"ClaimFinancial"> | Date | string | null
    claimId?: StringWithAggregatesFilter<"ClaimFinancial"> | string
    branchId?: IntWithAggregatesFilter<"ClaimFinancial"> | number
    claimStatusId?: IntWithAggregatesFilter<"ClaimFinancial"> | number
  }

  export type ClaimProcessWhereInput = {
    AND?: ClaimProcessWhereInput | ClaimProcessWhereInput[]
    OR?: ClaimProcessWhereInput[]
    NOT?: ClaimProcessWhereInput | ClaimProcessWhereInput[]
    id?: IntFilter<"ClaimProcess"> | number
    startTreatment?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    endTreatment?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    expeditionDate?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    reclaim?: StringNullableFilter<"ClaimProcess"> | string | null
    processDate?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    submissionNote?: StringFilter<"ClaimProcess"> | string
    description?: StringFilter<"ClaimProcess"> | string
    additionalNote?: StringFilter<"ClaimProcess"> | string
    claimId?: StringFilter<"ClaimProcess"> | string
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
    documents?: DocumentListRelationFilter
  }

  export type ClaimProcessOrderByWithRelationInput = {
    id?: SortOrder
    startTreatment?: SortOrderInput | SortOrder
    endTreatment?: SortOrderInput | SortOrder
    expeditionDate?: SortOrderInput | SortOrder
    reclaim?: SortOrderInput | SortOrder
    processDate?: SortOrderInput | SortOrder
    submissionNote?: SortOrder
    description?: SortOrder
    additionalNote?: SortOrder
    claimId?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type ClaimProcessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    claimId?: string
    AND?: ClaimProcessWhereInput | ClaimProcessWhereInput[]
    OR?: ClaimProcessWhereInput[]
    NOT?: ClaimProcessWhereInput | ClaimProcessWhereInput[]
    startTreatment?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    endTreatment?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    expeditionDate?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    reclaim?: StringNullableFilter<"ClaimProcess"> | string | null
    processDate?: DateTimeNullableFilter<"ClaimProcess"> | Date | string | null
    submissionNote?: StringFilter<"ClaimProcess"> | string
    description?: StringFilter<"ClaimProcess"> | string
    additionalNote?: StringFilter<"ClaimProcess"> | string
    claim?: XOR<ClaimNullableRelationFilter, ClaimWhereInput> | null
    documents?: DocumentListRelationFilter
  }, "id" | "claimId">

  export type ClaimProcessOrderByWithAggregationInput = {
    id?: SortOrder
    startTreatment?: SortOrderInput | SortOrder
    endTreatment?: SortOrderInput | SortOrder
    expeditionDate?: SortOrderInput | SortOrder
    reclaim?: SortOrderInput | SortOrder
    processDate?: SortOrderInput | SortOrder
    submissionNote?: SortOrder
    description?: SortOrder
    additionalNote?: SortOrder
    claimId?: SortOrder
    _count?: ClaimProcessCountOrderByAggregateInput
    _avg?: ClaimProcessAvgOrderByAggregateInput
    _max?: ClaimProcessMaxOrderByAggregateInput
    _min?: ClaimProcessMinOrderByAggregateInput
    _sum?: ClaimProcessSumOrderByAggregateInput
  }

  export type ClaimProcessScalarWhereWithAggregatesInput = {
    AND?: ClaimProcessScalarWhereWithAggregatesInput | ClaimProcessScalarWhereWithAggregatesInput[]
    OR?: ClaimProcessScalarWhereWithAggregatesInput[]
    NOT?: ClaimProcessScalarWhereWithAggregatesInput | ClaimProcessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClaimProcess"> | number
    startTreatment?: DateTimeNullableWithAggregatesFilter<"ClaimProcess"> | Date | string | null
    endTreatment?: DateTimeNullableWithAggregatesFilter<"ClaimProcess"> | Date | string | null
    expeditionDate?: DateTimeNullableWithAggregatesFilter<"ClaimProcess"> | Date | string | null
    reclaim?: StringNullableWithAggregatesFilter<"ClaimProcess"> | string | null
    processDate?: DateTimeNullableWithAggregatesFilter<"ClaimProcess"> | Date | string | null
    submissionNote?: StringWithAggregatesFilter<"ClaimProcess"> | string
    description?: StringWithAggregatesFilter<"ClaimProcess"> | string
    additionalNote?: StringWithAggregatesFilter<"ClaimProcess"> | string
    claimId?: StringWithAggregatesFilter<"ClaimProcess"> | string
  }

  export type ClaimStatusWhereInput = {
    AND?: ClaimStatusWhereInput | ClaimStatusWhereInput[]
    OR?: ClaimStatusWhereInput[]
    NOT?: ClaimStatusWhereInput | ClaimStatusWhereInput[]
    id?: IntFilter<"ClaimStatus"> | number
    description?: StringNullableFilter<"ClaimStatus"> | string | null
    rejectionReason?: StringNullableFilter<"ClaimStatus"> | string | null
    createdAt?: DateTimeFilter<"ClaimStatus"> | Date | string
    status?: EnumClaimStatusTypeFilter<"ClaimStatus"> | $Enums.ClaimStatusType
    createById?: StringFilter<"ClaimStatus"> | string
    claimId?: StringFilter<"ClaimStatus"> | string
    rejectionLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    guaranteeLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    transactionLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    bookKeepingOrderId?: StringNullableFilter<"ClaimStatus"> | string | null
    createBy?: XOR<UserRelationFilter, UserWhereInput>
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    rejectionLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    guaranteeLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    transactionLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    bookKeepingOrder?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    claimFinancial?: XOR<ClaimFinancialNullableRelationFilter, ClaimFinancialWhereInput> | null
  }

  export type ClaimStatusOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    createById?: SortOrder
    claimId?: SortOrder
    rejectionLetterId?: SortOrderInput | SortOrder
    guaranteeLetterId?: SortOrderInput | SortOrder
    transactionLetterId?: SortOrderInput | SortOrder
    bookKeepingOrderId?: SortOrderInput | SortOrder
    createBy?: UserOrderByWithRelationInput
    claim?: ClaimOrderByWithRelationInput
    rejectionLetter?: DocumentOrderByWithRelationInput
    guaranteeLetter?: DocumentOrderByWithRelationInput
    transactionLetter?: DocumentOrderByWithRelationInput
    bookKeepingOrder?: DocumentOrderByWithRelationInput
    claimFinancial?: ClaimFinancialOrderByWithRelationInput
  }

  export type ClaimStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rejectionLetterId?: string
    guaranteeLetterId?: string
    transactionLetterId?: string
    bookKeepingOrderId?: string
    AND?: ClaimStatusWhereInput | ClaimStatusWhereInput[]
    OR?: ClaimStatusWhereInput[]
    NOT?: ClaimStatusWhereInput | ClaimStatusWhereInput[]
    description?: StringNullableFilter<"ClaimStatus"> | string | null
    rejectionReason?: StringNullableFilter<"ClaimStatus"> | string | null
    createdAt?: DateTimeFilter<"ClaimStatus"> | Date | string
    status?: EnumClaimStatusTypeFilter<"ClaimStatus"> | $Enums.ClaimStatusType
    createById?: StringFilter<"ClaimStatus"> | string
    claimId?: StringFilter<"ClaimStatus"> | string
    createBy?: XOR<UserRelationFilter, UserWhereInput>
    claim?: XOR<ClaimRelationFilter, ClaimWhereInput>
    rejectionLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    guaranteeLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    transactionLetter?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    bookKeepingOrder?: XOR<DocumentNullableRelationFilter, DocumentWhereInput> | null
    claimFinancial?: XOR<ClaimFinancialNullableRelationFilter, ClaimFinancialWhereInput> | null
  }, "id" | "rejectionLetterId" | "guaranteeLetterId" | "transactionLetterId" | "bookKeepingOrderId">

  export type ClaimStatusOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    createById?: SortOrder
    claimId?: SortOrder
    rejectionLetterId?: SortOrderInput | SortOrder
    guaranteeLetterId?: SortOrderInput | SortOrder
    transactionLetterId?: SortOrderInput | SortOrder
    bookKeepingOrderId?: SortOrderInput | SortOrder
    _count?: ClaimStatusCountOrderByAggregateInput
    _avg?: ClaimStatusAvgOrderByAggregateInput
    _max?: ClaimStatusMaxOrderByAggregateInput
    _min?: ClaimStatusMinOrderByAggregateInput
    _sum?: ClaimStatusSumOrderByAggregateInput
  }

  export type ClaimStatusScalarWhereWithAggregatesInput = {
    AND?: ClaimStatusScalarWhereWithAggregatesInput | ClaimStatusScalarWhereWithAggregatesInput[]
    OR?: ClaimStatusScalarWhereWithAggregatesInput[]
    NOT?: ClaimStatusScalarWhereWithAggregatesInput | ClaimStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClaimStatus"> | number
    description?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClaimStatus"> | Date | string
    status?: EnumClaimStatusTypeWithAggregatesFilter<"ClaimStatus"> | $Enums.ClaimStatusType
    createById?: StringWithAggregatesFilter<"ClaimStatus"> | string
    claimId?: StringWithAggregatesFilter<"ClaimStatus"> | string
    rejectionLetterId?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
    guaranteeLetterId?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
    transactionLetterId?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
    bookKeepingOrderId?: StringNullableWithAggregatesFilter<"ClaimStatus"> | string | null
  }

  export type DiseaseWhereInput = {
    AND?: DiseaseWhereInput | DiseaseWhereInput[]
    OR?: DiseaseWhereInput[]
    NOT?: DiseaseWhereInput | DiseaseWhereInput[]
    id?: IntFilter<"Disease"> | number
    code?: StringFilter<"Disease"> | string
    name?: StringFilter<"Disease"> | string
    createdAt?: DateTimeFilter<"Disease"> | Date | string
    updatedAt?: DateTimeFilter<"Disease"> | Date | string
    claims?: ClaimListRelationFilter
  }

  export type DiseaseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
  }

  export type DiseaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiseaseWhereInput | DiseaseWhereInput[]
    OR?: DiseaseWhereInput[]
    NOT?: DiseaseWhereInput | DiseaseWhereInput[]
    code?: StringFilter<"Disease"> | string
    name?: StringFilter<"Disease"> | string
    createdAt?: DateTimeFilter<"Disease"> | Date | string
    updatedAt?: DateTimeFilter<"Disease"> | Date | string
    claims?: ClaimListRelationFilter
  }, "id">

  export type DiseaseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiseaseCountOrderByAggregateInput
    _avg?: DiseaseAvgOrderByAggregateInput
    _max?: DiseaseMaxOrderByAggregateInput
    _min?: DiseaseMinOrderByAggregateInput
    _sum?: DiseaseSumOrderByAggregateInput
  }

  export type DiseaseScalarWhereWithAggregatesInput = {
    AND?: DiseaseScalarWhereWithAggregatesInput | DiseaseScalarWhereWithAggregatesInput[]
    OR?: DiseaseScalarWhereWithAggregatesInput[]
    NOT?: DiseaseScalarWhereWithAggregatesInput | DiseaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Disease"> | number
    code?: StringWithAggregatesFilter<"Disease"> | string
    name?: StringWithAggregatesFilter<"Disease"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Disease"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Disease"> | Date | string
  }

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: IntFilter<"Clinic"> | number
    code?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    claims?: ClaimListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claims?: ClaimOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    code?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    claims?: ClaimListRelationFilter
  }, "id">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _avg?: ClinicAvgOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
    _sum?: ClinicSumOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Clinic"> | number
    code?: StringWithAggregatesFilter<"Clinic"> | string
    name?: StringWithAggregatesFilter<"Clinic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    currentBalance?: FloatFilter<"Account"> | number
    currentBalanceLastUpdate?: DateTimeNullableFilter<"Account"> | Date | string | null
    participantId?: StringFilter<"Account"> | string
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    transactions?: TransactionListRelationFilter
    programParticipation?: ProgramParticipationListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    currentBalance?: SortOrder
    currentBalanceLastUpdate?: SortOrderInput | SortOrder
    participantId?: SortOrder
    participant?: ParticipantOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    programParticipation?: ProgramParticipationOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    currentBalance?: FloatFilter<"Account"> | number
    currentBalanceLastUpdate?: DateTimeNullableFilter<"Account"> | Date | string | null
    participantId?: StringFilter<"Account"> | string
    participant?: XOR<ParticipantRelationFilter, ParticipantWhereInput>
    transactions?: TransactionListRelationFilter
    programParticipation?: ProgramParticipationListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    currentBalance?: SortOrder
    currentBalanceLastUpdate?: SortOrderInput | SortOrder
    participantId?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    currentBalance?: FloatWithAggregatesFilter<"Account"> | number
    currentBalanceLastUpdate?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    participantId?: StringWithAggregatesFilter<"Account"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    amount?: FloatFilter<"Transaction"> | number
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: IntFilter<"Transaction"> | number
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    amount?: FloatFilter<"Transaction"> | number
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: IntFilter<"Transaction"> | number
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    accountId?: IntWithAggregatesFilter<"Transaction"> | number
  }

  export type UserCreateInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    order: number
    higherLevelThan?: RoleCreateNestedOneWithoutLowerLevelThanInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    higherLevelThanId?: number | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleUncheckedCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThan?: RoleUpdateOneWithoutLowerLevelThanNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThanId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUncheckedUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    higherLevelThanId?: number | null
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThanId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePermissionCreateInput = {
    permission: $Enums.Permission
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: number
    permission: $Enums.Permission
  }

  export type RolePermissionUpdateInput = {
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type RolePermissionCreateManyInput = {
    roleId: number
    permission: $Enums.Permission
  }

  export type RolePermissionUpdateManyMutationInput = {
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type ParticipantCreateInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUpdateInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantCreateManyInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
  }

  export type ParticipantUpdateManyMutationInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
  }

  export type ParticipantUncheckedUpdateManyInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactInfoCreateInput = {
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutContactInfosInput
    address: AddressCreateNestedOneWithoutContactInfoInput
  }

  export type ContactInfoUncheckedCreateInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId: string
    addressId: number
  }

  export type ContactInfoUpdateInput = {
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutContactInfosNestedInput
    address?: AddressUpdateOneRequiredWithoutContactInfoNestedInput
  }

  export type ContactInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactInfoCreateManyInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId: string
    addressId: number
  }

  export type ContactInfoUpdateManyMutationInput = {
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
  }

  export type AddressCreateInput = {
    address: string
    postalCode: string
    city: CityCreateNestedOneWithoutAddressInput
    ContactInfo?: ContactInfoCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    address: string
    cityId: number
    postalCode: string
    ContactInfo?: ContactInfoUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressNestedInput
    ContactInfo?: ContactInfoUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    postalCode?: StringFieldUpdateOperationsInput | string
    ContactInfo?: ContactInfoUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    address: string
    cityId: number
    postalCode: string
  }

  export type AddressUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    accountNumber: number
    accountName: string
    participant: ParticipantCreateNestedOneWithoutBankAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: number
    accountNumber: number
    accountName: string
    participantId: string
  }

  export type BankAccountUpdateInput = {
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutBankAccountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type BankAccountCreateManyInput = {
    id?: number
    accountNumber: number
    accountName: string
    participantId: string
  }

  export type BankAccountUpdateManyMutationInput = {
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentCreateInput = {
    employmentPosition: $Enums.Position
    participant: ParticipantCreateNestedOneWithoutEmploymentsInput
    branch: BranchCreateNestedOneWithoutEmploymentInput
    group?: GroupCreateNestedOneWithoutEmploymentInput
    region?: RegionCreateNestedOneWithoutEmploymentInput
  }

  export type EmploymentUncheckedCreateInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    groupId: number
    regionId: number
  }

  export type EmploymentUpdateInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participant?: ParticipantUpdateOneRequiredWithoutEmploymentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutEmploymentNestedInput
    group?: GroupUpdateOneWithoutEmploymentNestedInput
    region?: RegionUpdateOneWithoutEmploymentNestedInput
  }

  export type EmploymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentCreateManyInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    groupId: number
    regionId: number
  }

  export type EmploymentUpdateManyMutationInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
  }

  export type EmploymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type BranchCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentCreateNestedManyWithoutBranchInput
    claimFinancial?: ClaimFinancialCreateNestedManyWithoutBranchPayeeInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentUncheckedCreateNestedManyWithoutBranchInput
    claimFinancial?: ClaimFinancialUncheckedCreateNestedManyWithoutBranchPayeeInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUpdateManyWithoutBranchNestedInput
    claimFinancial?: ClaimFinancialUpdateManyWithoutBranchPayeeNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUncheckedUpdateManyWithoutBranchNestedInput
    claimFinancial?: ClaimFinancialUncheckedUpdateManyWithoutBranchPayeeNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAnnouncementCreatedInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAnnouncementCreatedNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AnnouncementCreateManyInput = {
    id?: number
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
    userId: string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramParticipationCreateInput = {
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutProgramParticipationsInput
    funding: AccountCreateNestedOneWithoutProgramParticipationInput
    Program?: ProgramCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    fundingId: number
    programId?: number | null
  }

  export type ProgramParticipationUpdateInput = {
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutProgramParticipationsNestedInput
    funding?: AccountUpdateOneRequiredWithoutProgramParticipationNestedInput
    Program?: ProgramUpdateOneWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    fundingId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramParticipationCreateManyInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    fundingId: number
    programId?: number | null
  }

  export type ProgramParticipationUpdateManyMutationInput = {
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramParticipationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    fundingId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramCreateInput = {
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    programParticipations?: ProgramParticipationCreateNestedManyWithoutProgramInput
    claimType?: ClaimTypeCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutProgramInput
    claimType?: ClaimTypeUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    programParticipations?: ProgramParticipationUpdateManyWithoutProgramNestedInput
    claimType?: ClaimTypeUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutProgramNestedInput
    claimType?: ClaimTypeUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: number
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
  }

  export type ProgramUpdateManyMutationInput = {
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
  }

  export type ClaimCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput
    claimProcess?: ClaimProcessCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
    rejectionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput
    claimProcess?: ClaimProcessUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagCreateInput = {
    name: string
    color: $Enums.Color
    createdAt?: Date | string
    updatedAt?: Date | string
    Claims?: ClaimCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    color: $Enums.Color
    createdAt?: Date | string
    updatedAt?: Date | string
    Claims?: ClaimUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claims?: ClaimUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Claims?: ClaimUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    color: $Enums.Color
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimTypeCreateInput = {
    jenis: string
    jenisRI: string
    plan: string
    claimId: number
    program: ProgramCreateNestedOneWithoutClaimTypeInput
    claims?: ClaimCreateNestedOneWithoutClaimTypesInput
  }

  export type ClaimTypeUncheckedCreateInput = {
    id?: number
    jenis: string
    jenisRI: string
    plan: string
    programId: number
    claimId: number
    claims?: ClaimUncheckedCreateNestedOneWithoutClaimTypesInput
  }

  export type ClaimTypeUpdateInput = {
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
    program?: ProgramUpdateOneRequiredWithoutClaimTypeNestedInput
    claims?: ClaimUpdateOneWithoutClaimTypesNestedInput
  }

  export type ClaimTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    claimId?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUncheckedUpdateOneWithoutClaimTypesNestedInput
  }

  export type ClaimTypeCreateManyInput = {
    id?: number
    jenis: string
    jenisRI: string
    plan: string
    programId: number
    claimId: number
  }

  export type ClaimTypeUpdateManyMutationInput = {
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    claimId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimFinancialCreateInput = {
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchPayee: BranchCreateNestedOneWithoutClaimFinancialInput
    claim?: ClaimCreateNestedOneWithoutClaimFinancialsInput
    claimStatus: ClaimStatusCreateNestedOneWithoutClaimFinancialInput
  }

  export type ClaimFinancialUncheckedCreateInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchId: number
    claimStatusId: number
    claim?: ClaimUncheckedCreateNestedOneWithoutClaimFinancialsInput
  }

  export type ClaimFinancialUpdateInput = {
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchPayee?: BranchUpdateOneRequiredWithoutClaimFinancialNestedInput
    claim?: ClaimUpdateOneWithoutClaimFinancialsNestedInput
    claimStatus?: ClaimStatusUpdateOneRequiredWithoutClaimFinancialNestedInput
  }

  export type ClaimFinancialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    claimStatusId?: IntFieldUpdateOperationsInput | number
    claim?: ClaimUncheckedUpdateOneWithoutClaimFinancialsNestedInput
  }

  export type ClaimFinancialCreateManyInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchId: number
    claimStatusId: number
  }

  export type ClaimFinancialUpdateManyMutationInput = {
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimFinancialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    claimStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimProcessCreateInput = {
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    claim?: ClaimCreateNestedOneWithoutClaimProcessesInput
    documents?: DocumentCreateNestedManyWithoutClaimProcessInput
  }

  export type ClaimProcessUncheckedCreateInput = {
    id?: number
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    claim?: ClaimUncheckedCreateNestedOneWithoutClaimProcessesInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClaimProcessInput
  }

  export type ClaimProcessUpdateInput = {
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneWithoutClaimProcessesNestedInput
    documents?: DocumentUpdateManyWithoutClaimProcessNestedInput
  }

  export type ClaimProcessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUncheckedUpdateOneWithoutClaimProcessesNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClaimProcessNestedInput
  }

  export type ClaimProcessCreateManyInput = {
    id?: number
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
  }

  export type ClaimProcessUpdateManyMutationInput = {
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimProcessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimStatusCreateInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusCreateManyInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
  }

  export type ClaimStatusUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
  }

  export type ClaimStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiseaseCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimCreateNestedManyWithoutDiseaseInput
  }

  export type DiseaseUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutDiseaseInput
  }

  export type DiseaseUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUpdateManyWithoutDiseaseNestedInput
  }

  export type DiseaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutDiseaseNestedInput
  }

  export type DiseaseCreateManyInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimCreateNestedManyWithoutClinicsInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutClinicsInput
  }

  export type ClinicUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUpdateManyWithoutClinicsNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutClinicsNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutBalancesInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    programParticipation?: ProgramParticipationCreateNestedManyWithoutFundingInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participantId: string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    programParticipation?: ProgramParticipationUncheckedCreateNestedManyWithoutFundingInput
  }

  export type AccountUpdateInput = {
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutBalancesNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    programParticipation?: ProgramParticipationUpdateManyWithoutFundingNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    programParticipation?: ProgramParticipationUncheckedUpdateManyWithoutFundingNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participantId: string
  }

  export type AccountUpdateManyMutationInput = {
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
    accountId: number
  }

  export type TransactionUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyInput = {
    id?: number
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
    accountId: number
  }

  export type TransactionUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ParticipantNullableRelationFilter = {
    is?: ParticipantWhereInput | null
    isNot?: ParticipantWhereInput | null
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type ClaimStatusListRelationFilter = {
    every?: ClaimStatusWhereInput
    some?: ClaimStatusWhereInput
    none?: ClaimStatusWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    profilePictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    roleId?: SortOrder
    participantId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    profilePictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    profilePictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    roleId?: SortOrder
    participantId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    roleId?: SortOrder
    participantId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RoleNullableRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    higherLevelThanId?: SortOrder
  }

  export type EnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type RolePermissionRoleIdPermissionCompoundUniqueInput = {
    roleId: number
    permission: $Enums.Permission
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permission?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permission?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permission?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type EnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusFilter<$PrismaModel> | $Enums.ParticipantStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BankAccountNullableRelationFilter = {
    is?: BankAccountWhereInput | null
    isNot?: BankAccountWhereInput | null
  }

  export type EmploymentListRelationFilter = {
    every?: EmploymentWhereInput
    some?: EmploymentWhereInput
    none?: EmploymentWhereInput
  }

  export type ContactInfoListRelationFilter = {
    every?: ContactInfoWhereInput
    some?: ContactInfoWhereInput
    none?: ContactInfoWhereInput
  }

  export type ProgramParticipationListRelationFilter = {
    every?: ProgramParticipationWhereInput
    some?: ProgramParticipationWhereInput
    none?: ProgramParticipationWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type ParticipantListRelationFilter = {
    every?: ParticipantWhereInput
    some?: ParticipantWhereInput
    none?: ParticipantWhereInput
  }

  export type EmploymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipantCountOrderByAggregateInput = {
    gender?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    relationId?: SortOrder
    bankAccountId?: SortOrder
  }

  export type ParticipantAvgOrderByAggregateInput = {
    bankAccountId?: SortOrder
  }

  export type ParticipantMaxOrderByAggregateInput = {
    gender?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    relationId?: SortOrder
    bankAccountId?: SortOrder
  }

  export type ParticipantMinOrderByAggregateInput = {
    gender?: SortOrder
    birthDate?: SortOrder
    isActive?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    relationId?: SortOrder
    bankAccountId?: SortOrder
  }

  export type ParticipantSumOrderByAggregateInput = {
    bankAccountId?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumParticipantStatusFilter<$PrismaModel>
  }

  export type ParticipantRelationFilter = {
    is?: ParticipantWhereInput
    isNot?: ParticipantWhereInput
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type ContactInfoCountOrderByAggregateInput = {
    id?: SortOrder
    telp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    participantId?: SortOrder
    addressId?: SortOrder
  }

  export type ContactInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type ContactInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    telp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    participantId?: SortOrder
    addressId?: SortOrder
  }

  export type ContactInfoMinOrderByAggregateInput = {
    id?: SortOrder
    telp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    participantId?: SortOrder
    addressId?: SortOrder
  }

  export type ContactInfoSumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type CityRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    postalCode?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    cityId?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    participantId?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    participantId?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    participantId?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type GroupNullableRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type RegionNullableRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type EmploymentCountOrderByAggregateInput = {
    id?: SortOrder
    employmentPosition?: SortOrder
    participantId?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
  }

  export type EmploymentAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
  }

  export type EmploymentMaxOrderByAggregateInput = {
    id?: SortOrder
    employmentPosition?: SortOrder
    participantId?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
  }

  export type EmploymentMinOrderByAggregateInput = {
    id?: SortOrder
    employmentPosition?: SortOrder
    participantId?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
  }

  export type EmploymentSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    groupId?: SortOrder
    regionId?: SortOrder
  }

  export type EnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type ClaimFinancialListRelationFilter = {
    every?: ClaimFinancialWhereInput
    some?: ClaimFinancialWhereInput
    none?: ClaimFinancialWhereInput
  }

  export type ClaimFinancialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AnnouncementAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AnnouncementSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    isCleared?: SortOrder
    deepLink?: SortOrder
    fcmToken?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    isCleared?: SortOrder
    deepLink?: SortOrder
    fcmToken?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    isCleared?: SortOrder
    deepLink?: SortOrder
    fcmToken?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type ProgramNullableRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type ProgramParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    bpjsNumber?: SortOrder
    nonActiveReason?: SortOrder
    effectiveDate?: SortOrder
    nonActiveDate?: SortOrder
    participantId?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrder
  }

  export type ProgramParticipationAvgOrderByAggregateInput = {
    id?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrder
  }

  export type ProgramParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    bpjsNumber?: SortOrder
    nonActiveReason?: SortOrder
    effectiveDate?: SortOrder
    nonActiveDate?: SortOrder
    participantId?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrder
  }

  export type ProgramParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    bpjsNumber?: SortOrder
    nonActiveReason?: SortOrder
    effectiveDate?: SortOrder
    nonActiveDate?: SortOrder
    participantId?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrder
  }

  export type ProgramParticipationSumOrderByAggregateInput = {
    id?: SortOrder
    fundingId?: SortOrder
    programId?: SortOrder
  }

  export type EnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type EnumClassFilter<$PrismaModel = never> = {
    equals?: $Enums.Class | EnumClassFieldRefInput<$PrismaModel>
    in?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    notIn?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    not?: NestedEnumClassFilter<$PrismaModel> | $Enums.Class
  }

  export type ClaimTypeListRelationFilter = {
    every?: ClaimTypeWhereInput
    some?: ClaimTypeWhereInput
    none?: ClaimTypeWhereInput
  }

  export type ClaimTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    allowanceCeiling?: SortOrder
    class?: SortOrder
    maxAllowance?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    allowanceCeiling?: SortOrder
    maxAllowance?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    allowanceCeiling?: SortOrder
    class?: SortOrder
    maxAllowance?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    plan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    allowanceCeiling?: SortOrder
    class?: SortOrder
    maxAllowance?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    allowanceCeiling?: SortOrder
    maxAllowance?: SortOrder
  }

  export type EnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type EnumClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Class | EnumClassFieldRefInput<$PrismaModel>
    in?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    notIn?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    not?: NestedEnumClassWithAggregatesFilter<$PrismaModel> | $Enums.Class
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassFilter<$PrismaModel>
    _max?: NestedEnumClassFilter<$PrismaModel>
  }

  export type EnumClaimChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimChannel | EnumClaimChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimChannelFilter<$PrismaModel> | $Enums.ClaimChannel
  }

  export type EnumAdmedicaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmedicaStatus | EnumAdmedicaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmedicaStatusFilter<$PrismaModel> | $Enums.AdmedicaStatus
  }

  export type ClaimFinancialRelationFilter = {
    is?: ClaimFinancialWhereInput
    isNot?: ClaimFinancialWhereInput
  }

  export type ClaimProcessRelationFilter = {
    is?: ClaimProcessWhereInput
    isNot?: ClaimProcessWhereInput
  }

  export type DiseaseNullableRelationFilter = {
    is?: DiseaseWhereInput | null
    isNot?: DiseaseWhereInput | null
  }

  export type ClinicRelationFilter = {
    is?: ClinicWhereInput
    isNot?: ClinicWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClaimTypeRelationFilter = {
    is?: ClaimTypeWhereInput
    isNot?: ClaimTypeWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    channel?: SortOrder
    admedicaStatus?: SortOrder
    company?: SortOrder
    participantId?: SortOrder
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrder
    clinicId?: SortOrder
    inputedById?: SortOrder
    claimTypeId?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrder
    clinicId?: SortOrder
    claimTypeId?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    channel?: SortOrder
    admedicaStatus?: SortOrder
    company?: SortOrder
    participantId?: SortOrder
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrder
    clinicId?: SortOrder
    inputedById?: SortOrder
    claimTypeId?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    channel?: SortOrder
    admedicaStatus?: SortOrder
    company?: SortOrder
    participantId?: SortOrder
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrder
    clinicId?: SortOrder
    inputedById?: SortOrder
    claimTypeId?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    claimFinancialId?: SortOrder
    claimProcessId?: SortOrder
    diseaseId?: SortOrder
    clinicId?: SortOrder
    claimTypeId?: SortOrder
  }

  export type EnumClaimChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimChannel | EnumClaimChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimChannelWithAggregatesFilter<$PrismaModel> | $Enums.ClaimChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimChannelFilter<$PrismaModel>
    _max?: NestedEnumClaimChannelFilter<$PrismaModel>
  }

  export type EnumAdmedicaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmedicaStatus | EnumAdmedicaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmedicaStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmedicaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmedicaStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmedicaStatusFilter<$PrismaModel>
  }

  export type EnumDocumentSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSource | EnumDocumentSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceFilter<$PrismaModel> | $Enums.DocumentSource
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type ClaimStatusNullableRelationFilter = {
    is?: ClaimStatusWhereInput | null
    isNot?: ClaimStatusWhereInput | null
  }

  export type ClaimProcessNullableRelationFilter = {
    is?: ClaimProcessWhereInput | null
    isNot?: ClaimProcessWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    printCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    type?: SortOrder
    claimProcessId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
    printCount?: SortOrder
    claimProcessId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    printCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    type?: SortOrder
    claimProcessId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    path?: SortOrder
    size?: SortOrder
    printCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
    type?: SortOrder
    claimProcessId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
    printCount?: SortOrder
    claimProcessId?: SortOrder
  }

  export type EnumDocumentSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSource | EnumDocumentSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceWithAggregatesFilter<$PrismaModel> | $Enums.DocumentSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentSourceFilter<$PrismaModel>
    _max?: NestedEnumDocumentSourceFilter<$PrismaModel>
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumColorFilter<$PrismaModel = never> = {
    equals?: $Enums.Color | EnumColorFieldRefInput<$PrismaModel>
    in?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    not?: NestedEnumColorFilter<$PrismaModel> | $Enums.Color
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Color | EnumColorFieldRefInput<$PrismaModel>
    in?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    not?: NestedEnumColorWithAggregatesFilter<$PrismaModel> | $Enums.Color
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColorFilter<$PrismaModel>
    _max?: NestedEnumColorFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type ClaimNullableRelationFilter = {
    is?: ClaimWhereInput | null
    isNot?: ClaimWhereInput | null
  }

  export type ClaimTypeCountOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    jenisRI?: SortOrder
    plan?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    jenisRI?: SortOrder
    plan?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimTypeMinOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    jenisRI?: SortOrder
    plan?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimTypeSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    claimId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ClaimStatusRelationFilter = {
    is?: ClaimStatusWhereInput
    isNot?: ClaimStatusWhereInput
  }

  export type ClaimFinancialCountOrderByAggregateInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrder
    rejectedAmount?: SortOrder
    transactionProcessDate?: SortOrder
    transferDate?: SortOrder
    claimId?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
  }

  export type ClaimFinancialAvgOrderByAggregateInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrder
    rejectedAmount?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
  }

  export type ClaimFinancialMaxOrderByAggregateInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrder
    rejectedAmount?: SortOrder
    transactionProcessDate?: SortOrder
    transferDate?: SortOrder
    claimId?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
  }

  export type ClaimFinancialMinOrderByAggregateInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrder
    rejectedAmount?: SortOrder
    transactionProcessDate?: SortOrder
    transferDate?: SortOrder
    claimId?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
  }

  export type ClaimFinancialSumOrderByAggregateInput = {
    id?: SortOrder
    requestedAmount?: SortOrder
    paidAmount?: SortOrder
    rejectedAmount?: SortOrder
    branchId?: SortOrder
    claimStatusId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimProcessCountOrderByAggregateInput = {
    id?: SortOrder
    startTreatment?: SortOrder
    endTreatment?: SortOrder
    expeditionDate?: SortOrder
    reclaim?: SortOrder
    processDate?: SortOrder
    submissionNote?: SortOrder
    description?: SortOrder
    additionalNote?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimProcessAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClaimProcessMaxOrderByAggregateInput = {
    id?: SortOrder
    startTreatment?: SortOrder
    endTreatment?: SortOrder
    expeditionDate?: SortOrder
    reclaim?: SortOrder
    processDate?: SortOrder
    submissionNote?: SortOrder
    description?: SortOrder
    additionalNote?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimProcessMinOrderByAggregateInput = {
    id?: SortOrder
    startTreatment?: SortOrder
    endTreatment?: SortOrder
    expeditionDate?: SortOrder
    reclaim?: SortOrder
    processDate?: SortOrder
    submissionNote?: SortOrder
    description?: SortOrder
    additionalNote?: SortOrder
    claimId?: SortOrder
  }

  export type ClaimProcessSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumClaimStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatusType | EnumClaimStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusTypeFilter<$PrismaModel> | $Enums.ClaimStatusType
  }

  export type ClaimRelationFilter = {
    is?: ClaimWhereInput
    isNot?: ClaimWhereInput
  }

  export type DocumentNullableRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type ClaimFinancialNullableRelationFilter = {
    is?: ClaimFinancialWhereInput | null
    isNot?: ClaimFinancialWhereInput | null
  }

  export type ClaimStatusCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    createById?: SortOrder
    claimId?: SortOrder
    rejectionLetterId?: SortOrder
    guaranteeLetterId?: SortOrder
    transactionLetterId?: SortOrder
    bookKeepingOrderId?: SortOrder
  }

  export type ClaimStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClaimStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    createById?: SortOrder
    claimId?: SortOrder
    rejectionLetterId?: SortOrder
    guaranteeLetterId?: SortOrder
    transactionLetterId?: SortOrder
    bookKeepingOrderId?: SortOrder
  }

  export type ClaimStatusMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    createById?: SortOrder
    claimId?: SortOrder
    rejectionLetterId?: SortOrder
    guaranteeLetterId?: SortOrder
    transactionLetterId?: SortOrder
    bookKeepingOrderId?: SortOrder
  }

  export type ClaimStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumClaimStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatusType | EnumClaimStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusTypeFilter<$PrismaModel>
  }

  export type DiseaseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiseaseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiseaseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    currentBalance?: SortOrder
    currentBalanceLastUpdate?: SortOrder
    participantId?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    currentBalance?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    currentBalance?: SortOrder
    currentBalanceLastUpdate?: SortOrder
    participantId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    currentBalance?: SortOrder
    currentBalanceLastUpdate?: SortOrder
    participantId?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    currentBalance?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    accountId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    accountId?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutUserInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ClaimCreateNestedManyWithoutInputedByInput = {
    create?: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput> | ClaimCreateWithoutInputedByInput[] | ClaimUncheckedCreateWithoutInputedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInputedByInput | ClaimCreateOrConnectWithoutInputedByInput[]
    createMany?: ClaimCreateManyInputedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimStatusCreateNestedManyWithoutCreateByInput = {
    create?: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput> | ClaimStatusCreateWithoutCreateByInput[] | ClaimStatusUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutCreateByInput | ClaimStatusCreateOrConnectWithoutCreateByInput[]
    createMany?: ClaimStatusCreateManyCreateByInputEnvelope
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParticipantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedManyWithoutInputedByInput = {
    create?: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput> | ClaimCreateWithoutInputedByInput[] | ClaimUncheckedCreateWithoutInputedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInputedByInput | ClaimCreateOrConnectWithoutInputedByInput[]
    createMany?: ClaimCreateManyInputedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput = {
    create?: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput> | ClaimStatusCreateWithoutCreateByInput[] | ClaimStatusUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutCreateByInput | ClaimStatusCreateOrConnectWithoutCreateByInput[]
    createMany?: ClaimStatusCreateManyCreateByInputEnvelope
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ParticipantUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    upsert?: ParticipantUpsertWithoutUserInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutUserInput, ParticipantUpdateWithoutUserInput>, ParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ClaimUpdateManyWithoutInputedByNestedInput = {
    create?: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput> | ClaimCreateWithoutInputedByInput[] | ClaimUncheckedCreateWithoutInputedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInputedByInput | ClaimCreateOrConnectWithoutInputedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInputedByInput | ClaimUpsertWithWhereUniqueWithoutInputedByInput[]
    createMany?: ClaimCreateManyInputedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInputedByInput | ClaimUpdateWithWhereUniqueWithoutInputedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInputedByInput | ClaimUpdateManyWithWhereWithoutInputedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimStatusUpdateManyWithoutCreateByNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput> | ClaimStatusCreateWithoutCreateByInput[] | ClaimStatusUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutCreateByInput | ClaimStatusCreateOrConnectWithoutCreateByInput[]
    upsert?: ClaimStatusUpsertWithWhereUniqueWithoutCreateByInput | ClaimStatusUpsertWithWhereUniqueWithoutCreateByInput[]
    createMany?: ClaimStatusCreateManyCreateByInputEnvelope
    set?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    disconnect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    delete?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    update?: ClaimStatusUpdateWithWhereUniqueWithoutCreateByInput | ClaimStatusUpdateWithWhereUniqueWithoutCreateByInput[]
    updateMany?: ClaimStatusUpdateManyWithWhereWithoutCreateByInput | ClaimStatusUpdateManyWithWhereWithoutCreateByInput[]
    deleteMany?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParticipantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutUserInput
    upsert?: ParticipantUpsertWithoutUserInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutUserInput, ParticipantUpdateWithoutUserInput>, ParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ClaimUncheckedUpdateManyWithoutInputedByNestedInput = {
    create?: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput> | ClaimCreateWithoutInputedByInput[] | ClaimUncheckedCreateWithoutInputedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutInputedByInput | ClaimCreateOrConnectWithoutInputedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutInputedByInput | ClaimUpsertWithWhereUniqueWithoutInputedByInput[]
    createMany?: ClaimCreateManyInputedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutInputedByInput | ClaimUpdateWithWhereUniqueWithoutInputedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutInputedByInput | ClaimUpdateManyWithWhereWithoutInputedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput> | ClaimStatusCreateWithoutCreateByInput[] | ClaimStatusUncheckedCreateWithoutCreateByInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutCreateByInput | ClaimStatusCreateOrConnectWithoutCreateByInput[]
    upsert?: ClaimStatusUpsertWithWhereUniqueWithoutCreateByInput | ClaimStatusUpsertWithWhereUniqueWithoutCreateByInput[]
    createMany?: ClaimStatusCreateManyCreateByInputEnvelope
    set?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    disconnect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    delete?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    update?: ClaimStatusUpdateWithWhereUniqueWithoutCreateByInput | ClaimStatusUpdateWithWhereUniqueWithoutCreateByInput[]
    updateMany?: ClaimStatusUpdateManyWithWhereWithoutCreateByInput | ClaimStatusUpdateManyWithWhereWithoutCreateByInput[]
    deleteMany?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput> | AnnouncementCreateWithoutCreatedByInput[] | AnnouncementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCreatedByInput | AnnouncementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput | AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AnnouncementCreateManyCreatedByInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput | AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCreatedByInput | AnnouncementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutLowerLevelThanInput = {
    create?: XOR<RoleCreateWithoutLowerLevelThanInput, RoleUncheckedCreateWithoutLowerLevelThanInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLowerLevelThanInput
    connect?: RoleWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutHigherLevelThanInput = {
    create?: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput> | RoleCreateWithoutHigherLevelThanInput[] | RoleUncheckedCreateWithoutHigherLevelThanInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutHigherLevelThanInput | RoleCreateOrConnectWithoutHigherLevelThanInput[]
    createMany?: RoleCreateManyHigherLevelThanInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutHigherLevelThanInput = {
    create?: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput> | RoleCreateWithoutHigherLevelThanInput[] | RoleUncheckedCreateWithoutHigherLevelThanInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutHigherLevelThanInput | RoleCreateOrConnectWithoutHigherLevelThanInput[]
    createMany?: RoleCreateManyHigherLevelThanInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUpdateOneWithoutLowerLevelThanNestedInput = {
    create?: XOR<RoleCreateWithoutLowerLevelThanInput, RoleUncheckedCreateWithoutLowerLevelThanInput>
    connectOrCreate?: RoleCreateOrConnectWithoutLowerLevelThanInput
    upsert?: RoleUpsertWithoutLowerLevelThanInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutLowerLevelThanInput, RoleUpdateWithoutLowerLevelThanInput>, RoleUncheckedUpdateWithoutLowerLevelThanInput>
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutHigherLevelThanNestedInput = {
    create?: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput> | RoleCreateWithoutHigherLevelThanInput[] | RoleUncheckedCreateWithoutHigherLevelThanInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutHigherLevelThanInput | RoleCreateOrConnectWithoutHigherLevelThanInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutHigherLevelThanInput | RoleUpsertWithWhereUniqueWithoutHigherLevelThanInput[]
    createMany?: RoleCreateManyHigherLevelThanInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutHigherLevelThanInput | RoleUpdateWithWhereUniqueWithoutHigherLevelThanInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutHigherLevelThanInput | RoleUpdateManyWithWhereWithoutHigherLevelThanInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutHigherLevelThanNestedInput = {
    create?: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput> | RoleCreateWithoutHigherLevelThanInput[] | RoleUncheckedCreateWithoutHigherLevelThanInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutHigherLevelThanInput | RoleCreateOrConnectWithoutHigherLevelThanInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutHigherLevelThanInput | RoleUpsertWithWhereUniqueWithoutHigherLevelThanInput[]
    createMany?: RoleCreateManyHigherLevelThanInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutHigherLevelThanInput | RoleUpdateWithWhereUniqueWithoutHigherLevelThanInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutHigherLevelThanInput | RoleUpdateManyWithWhereWithoutHigherLevelThanInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type EnumPermissionFieldUpdateOperationsInput = {
    set?: $Enums.Permission
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UserCreateNestedOneWithoutParticipantInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutParticipantInput = {
    create?: XOR<ParticipantCreateWithoutParticipantInput, ParticipantUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutParticipantInput
    connect?: ParticipantWhereUniqueInput
  }

  export type BankAccountCreateNestedOneWithoutParticipantInput = {
    create?: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutParticipantInput
    connect?: BankAccountWhereUniqueInput
  }

  export type ClaimCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput> | ClaimCreateWithoutParticipantInput[] | ClaimUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutParticipantInput | ClaimCreateOrConnectWithoutParticipantInput[]
    createMany?: ClaimCreateManyParticipantInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EmploymentCreateNestedManyWithoutParticipantInput = {
    create?: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput> | EmploymentCreateWithoutParticipantInput[] | EmploymentUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutParticipantInput | EmploymentCreateOrConnectWithoutParticipantInput[]
    createMany?: EmploymentCreateManyParticipantInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type ContactInfoCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput> | ContactInfoCreateWithoutParticipantInput[] | ContactInfoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutParticipantInput | ContactInfoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContactInfoCreateManyParticipantInputEnvelope
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
  }

  export type ProgramParticipationCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput> | ProgramParticipationCreateWithoutParticipantInput[] | ProgramParticipationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutParticipantInput | ProgramParticipationCreateOrConnectWithoutParticipantInput[]
    createMany?: ProgramParticipationCreateManyParticipantInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutParticipantInput = {
    create?: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput> | AccountCreateWithoutParticipantInput[] | AccountUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParticipantInput | AccountCreateOrConnectWithoutParticipantInput[]
    createMany?: AccountCreateManyParticipantInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ParticipantCreateNestedManyWithoutRelationInput = {
    create?: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput> | ParticipantCreateWithoutRelationInput[] | ParticipantUncheckedCreateWithoutRelationInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutRelationInput | ParticipantCreateOrConnectWithoutRelationInput[]
    createMany?: ParticipantCreateManyRelationInputEnvelope
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
  }

  export type BankAccountUncheckedCreateNestedOneWithoutParticipantInput = {
    create?: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutParticipantInput
    connect?: BankAccountWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput> | ClaimCreateWithoutParticipantInput[] | ClaimUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutParticipantInput | ClaimCreateOrConnectWithoutParticipantInput[]
    createMany?: ClaimCreateManyParticipantInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EmploymentUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput> | EmploymentCreateWithoutParticipantInput[] | EmploymentUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutParticipantInput | EmploymentCreateOrConnectWithoutParticipantInput[]
    createMany?: EmploymentCreateManyParticipantInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type ContactInfoUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput> | ContactInfoCreateWithoutParticipantInput[] | ContactInfoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutParticipantInput | ContactInfoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContactInfoCreateManyParticipantInputEnvelope
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
  }

  export type ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput> | ProgramParticipationCreateWithoutParticipantInput[] | ProgramParticipationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutParticipantInput | ProgramParticipationCreateOrConnectWithoutParticipantInput[]
    createMany?: ProgramParticipationCreateManyParticipantInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput> | AccountCreateWithoutParticipantInput[] | AccountUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParticipantInput | AccountCreateOrConnectWithoutParticipantInput[]
    createMany?: AccountCreateManyParticipantInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type ParticipantUncheckedCreateNestedManyWithoutRelationInput = {
    create?: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput> | ParticipantCreateWithoutRelationInput[] | ParticipantUncheckedCreateWithoutRelationInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutRelationInput | ParticipantCreateOrConnectWithoutRelationInput[]
    createMany?: ParticipantCreateManyRelationInputEnvelope
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumParticipantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantStatus
  }

  export type UserUpdateOneRequiredWithoutParticipantNestedInput = {
    create?: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipantInput
    upsert?: UserUpsertWithoutParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipantInput, UserUpdateWithoutParticipantInput>, UserUncheckedUpdateWithoutParticipantInput>
  }

  export type ParticipantUpdateOneWithoutParticipantNestedInput = {
    create?: XOR<ParticipantCreateWithoutParticipantInput, ParticipantUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutParticipantInput
    upsert?: ParticipantUpsertWithoutParticipantInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutParticipantInput, ParticipantUpdateWithoutParticipantInput>, ParticipantUncheckedUpdateWithoutParticipantInput>
  }

  export type BankAccountUpdateOneWithoutParticipantNestedInput = {
    create?: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutParticipantInput
    upsert?: BankAccountUpsertWithoutParticipantInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutParticipantInput, BankAccountUpdateWithoutParticipantInput>, BankAccountUncheckedUpdateWithoutParticipantInput>
  }

  export type ClaimUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput> | ClaimCreateWithoutParticipantInput[] | ClaimUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutParticipantInput | ClaimCreateOrConnectWithoutParticipantInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutParticipantInput | ClaimUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ClaimCreateManyParticipantInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutParticipantInput | ClaimUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutParticipantInput | ClaimUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EmploymentUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput> | EmploymentCreateWithoutParticipantInput[] | EmploymentUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutParticipantInput | EmploymentCreateOrConnectWithoutParticipantInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutParticipantInput | EmploymentUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: EmploymentCreateManyParticipantInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutParticipantInput | EmploymentUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutParticipantInput | EmploymentUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type ContactInfoUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput> | ContactInfoCreateWithoutParticipantInput[] | ContactInfoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutParticipantInput | ContactInfoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContactInfoUpsertWithWhereUniqueWithoutParticipantInput | ContactInfoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContactInfoCreateManyParticipantInputEnvelope
    set?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    disconnect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    delete?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    update?: ContactInfoUpdateWithWhereUniqueWithoutParticipantInput | ContactInfoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContactInfoUpdateManyWithWhereWithoutParticipantInput | ContactInfoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
  }

  export type ProgramParticipationUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput> | ProgramParticipationCreateWithoutParticipantInput[] | ProgramParticipationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutParticipantInput | ProgramParticipationCreateOrConnectWithoutParticipantInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutParticipantInput | ProgramParticipationUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ProgramParticipationCreateManyParticipantInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutParticipantInput | ProgramParticipationUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutParticipantInput | ProgramParticipationUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput> | AccountCreateWithoutParticipantInput[] | AccountUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParticipantInput | AccountCreateOrConnectWithoutParticipantInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParticipantInput | AccountUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: AccountCreateManyParticipantInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParticipantInput | AccountUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParticipantInput | AccountUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ParticipantUpdateManyWithoutRelationNestedInput = {
    create?: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput> | ParticipantCreateWithoutRelationInput[] | ParticipantUncheckedCreateWithoutRelationInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutRelationInput | ParticipantCreateOrConnectWithoutRelationInput[]
    upsert?: ParticipantUpsertWithWhereUniqueWithoutRelationInput | ParticipantUpsertWithWhereUniqueWithoutRelationInput[]
    createMany?: ParticipantCreateManyRelationInputEnvelope
    set?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    disconnect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    delete?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    update?: ParticipantUpdateWithWhereUniqueWithoutRelationInput | ParticipantUpdateWithWhereUniqueWithoutRelationInput[]
    updateMany?: ParticipantUpdateManyWithWhereWithoutRelationInput | ParticipantUpdateManyWithWhereWithoutRelationInput[]
    deleteMany?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
  }

  export type BankAccountUncheckedUpdateOneWithoutParticipantNestedInput = {
    create?: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutParticipantInput
    upsert?: BankAccountUpsertWithoutParticipantInput
    disconnect?: BankAccountWhereInput | boolean
    delete?: BankAccountWhereInput | boolean
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutParticipantInput, BankAccountUpdateWithoutParticipantInput>, BankAccountUncheckedUpdateWithoutParticipantInput>
  }

  export type ClaimUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput> | ClaimCreateWithoutParticipantInput[] | ClaimUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutParticipantInput | ClaimCreateOrConnectWithoutParticipantInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutParticipantInput | ClaimUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ClaimCreateManyParticipantInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutParticipantInput | ClaimUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutParticipantInput | ClaimUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EmploymentUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput> | EmploymentCreateWithoutParticipantInput[] | EmploymentUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutParticipantInput | EmploymentCreateOrConnectWithoutParticipantInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutParticipantInput | EmploymentUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: EmploymentCreateManyParticipantInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutParticipantInput | EmploymentUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutParticipantInput | EmploymentUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput> | ContactInfoCreateWithoutParticipantInput[] | ContactInfoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutParticipantInput | ContactInfoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContactInfoUpsertWithWhereUniqueWithoutParticipantInput | ContactInfoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContactInfoCreateManyParticipantInputEnvelope
    set?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    disconnect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    delete?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    update?: ContactInfoUpdateWithWhereUniqueWithoutParticipantInput | ContactInfoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContactInfoUpdateManyWithWhereWithoutParticipantInput | ContactInfoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput> | ProgramParticipationCreateWithoutParticipantInput[] | ProgramParticipationUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutParticipantInput | ProgramParticipationCreateOrConnectWithoutParticipantInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutParticipantInput | ProgramParticipationUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ProgramParticipationCreateManyParticipantInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutParticipantInput | ProgramParticipationUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutParticipantInput | ProgramParticipationUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput> | AccountCreateWithoutParticipantInput[] | AccountUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParticipantInput | AccountCreateOrConnectWithoutParticipantInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParticipantInput | AccountUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: AccountCreateManyParticipantInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParticipantInput | AccountUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParticipantInput | AccountUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type ParticipantUncheckedUpdateManyWithoutRelationNestedInput = {
    create?: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput> | ParticipantCreateWithoutRelationInput[] | ParticipantUncheckedCreateWithoutRelationInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutRelationInput | ParticipantCreateOrConnectWithoutRelationInput[]
    upsert?: ParticipantUpsertWithWhereUniqueWithoutRelationInput | ParticipantUpsertWithWhereUniqueWithoutRelationInput[]
    createMany?: ParticipantCreateManyRelationInputEnvelope
    set?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    disconnect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    delete?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    update?: ParticipantUpdateWithWhereUniqueWithoutRelationInput | ParticipantUpdateWithWhereUniqueWithoutRelationInput[]
    updateMany?: ParticipantUpdateManyWithWhereWithoutRelationInput | ParticipantUpdateManyWithWhereWithoutRelationInput[]
    deleteMany?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
  }

  export type ParticipantCreateNestedOneWithoutContactInfosInput = {
    create?: XOR<ParticipantCreateWithoutContactInfosInput, ParticipantUncheckedCreateWithoutContactInfosInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutContactInfosInput
    connect?: ParticipantWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutContactInfoInput = {
    create?: XOR<AddressCreateWithoutContactInfoInput, AddressUncheckedCreateWithoutContactInfoInput>
    connectOrCreate?: AddressCreateOrConnectWithoutContactInfoInput
    connect?: AddressWhereUniqueInput
  }

  export type ParticipantUpdateOneRequiredWithoutContactInfosNestedInput = {
    create?: XOR<ParticipantCreateWithoutContactInfosInput, ParticipantUncheckedCreateWithoutContactInfosInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutContactInfosInput
    upsert?: ParticipantUpsertWithoutContactInfosInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutContactInfosInput, ParticipantUpdateWithoutContactInfosInput>, ParticipantUncheckedUpdateWithoutContactInfosInput>
  }

  export type AddressUpdateOneRequiredWithoutContactInfoNestedInput = {
    create?: XOR<AddressCreateWithoutContactInfoInput, AddressUncheckedCreateWithoutContactInfoInput>
    connectOrCreate?: AddressCreateOrConnectWithoutContactInfoInput
    upsert?: AddressUpsertWithoutContactInfoInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutContactInfoInput, AddressUpdateWithoutContactInfoInput>, AddressUncheckedUpdateWithoutContactInfoInput>
  }

  export type CityCreateNestedOneWithoutAddressInput = {
    create?: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressInput
    connect?: CityWhereUniqueInput
  }

  export type ContactInfoCreateNestedManyWithoutAddressInput = {
    create?: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput> | ContactInfoCreateWithoutAddressInput[] | ContactInfoUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutAddressInput | ContactInfoCreateOrConnectWithoutAddressInput[]
    createMany?: ContactInfoCreateManyAddressInputEnvelope
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
  }

  export type ContactInfoUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput> | ContactInfoCreateWithoutAddressInput[] | ContactInfoUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutAddressInput | ContactInfoCreateOrConnectWithoutAddressInput[]
    createMany?: ContactInfoCreateManyAddressInputEnvelope
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
  }

  export type CityUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutAddressInput
    upsert?: CityUpsertWithoutAddressInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutAddressInput, CityUpdateWithoutAddressInput>, CityUncheckedUpdateWithoutAddressInput>
  }

  export type ContactInfoUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput> | ContactInfoCreateWithoutAddressInput[] | ContactInfoUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutAddressInput | ContactInfoCreateOrConnectWithoutAddressInput[]
    upsert?: ContactInfoUpsertWithWhereUniqueWithoutAddressInput | ContactInfoUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ContactInfoCreateManyAddressInputEnvelope
    set?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    disconnect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    delete?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    update?: ContactInfoUpdateWithWhereUniqueWithoutAddressInput | ContactInfoUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ContactInfoUpdateManyWithWhereWithoutAddressInput | ContactInfoUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
  }

  export type ContactInfoUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput> | ContactInfoCreateWithoutAddressInput[] | ContactInfoUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ContactInfoCreateOrConnectWithoutAddressInput | ContactInfoCreateOrConnectWithoutAddressInput[]
    upsert?: ContactInfoUpsertWithWhereUniqueWithoutAddressInput | ContactInfoUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ContactInfoCreateManyAddressInputEnvelope
    set?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    disconnect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    delete?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    connect?: ContactInfoWhereUniqueInput | ContactInfoWhereUniqueInput[]
    update?: ContactInfoUpdateWithWhereUniqueWithoutAddressInput | ContactInfoUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ContactInfoUpdateManyWithWhereWithoutAddressInput | ContactInfoUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
  }

  export type AddressCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput> | AddressCreateWithoutCityInput[] | AddressUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCityInput | AddressCreateOrConnectWithoutCityInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCityInput | AddressUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AddressCreateManyCityInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCityInput | AddressUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCityInput | AddressUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ParticipantCreateNestedOneWithoutBankAccountInput = {
    create?: XOR<ParticipantCreateWithoutBankAccountInput, ParticipantUncheckedCreateWithoutBankAccountInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutBankAccountInput
    connect?: ParticipantWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParticipantUpdateOneRequiredWithoutBankAccountNestedInput = {
    create?: XOR<ParticipantCreateWithoutBankAccountInput, ParticipantUncheckedCreateWithoutBankAccountInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutBankAccountInput
    upsert?: ParticipantUpsertWithoutBankAccountInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutBankAccountInput, ParticipantUpdateWithoutBankAccountInput>, ParticipantUncheckedUpdateWithoutBankAccountInput>
  }

  export type ParticipantCreateNestedOneWithoutEmploymentsInput = {
    create?: XOR<ParticipantCreateWithoutEmploymentsInput, ParticipantUncheckedCreateWithoutEmploymentsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutEmploymentsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutEmploymentInput = {
    create?: XOR<BranchCreateWithoutEmploymentInput, BranchUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmploymentInput
    connect?: BranchWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutEmploymentInput = {
    create?: XOR<GroupCreateWithoutEmploymentInput, GroupUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: GroupCreateOrConnectWithoutEmploymentInput
    connect?: GroupWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutEmploymentInput = {
    create?: XOR<RegionCreateWithoutEmploymentInput, RegionUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: RegionCreateOrConnectWithoutEmploymentInput
    connect?: RegionWhereUniqueInput
  }

  export type EnumPositionFieldUpdateOperationsInput = {
    set?: $Enums.Position
  }

  export type ParticipantUpdateOneRequiredWithoutEmploymentsNestedInput = {
    create?: XOR<ParticipantCreateWithoutEmploymentsInput, ParticipantUncheckedCreateWithoutEmploymentsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutEmploymentsInput
    upsert?: ParticipantUpsertWithoutEmploymentsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutEmploymentsInput, ParticipantUpdateWithoutEmploymentsInput>, ParticipantUncheckedUpdateWithoutEmploymentsInput>
  }

  export type BranchUpdateOneRequiredWithoutEmploymentNestedInput = {
    create?: XOR<BranchCreateWithoutEmploymentInput, BranchUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmploymentInput
    upsert?: BranchUpsertWithoutEmploymentInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEmploymentInput, BranchUpdateWithoutEmploymentInput>, BranchUncheckedUpdateWithoutEmploymentInput>
  }

  export type GroupUpdateOneWithoutEmploymentNestedInput = {
    create?: XOR<GroupCreateWithoutEmploymentInput, GroupUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: GroupCreateOrConnectWithoutEmploymentInput
    upsert?: GroupUpsertWithoutEmploymentInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutEmploymentInput, GroupUpdateWithoutEmploymentInput>, GroupUncheckedUpdateWithoutEmploymentInput>
  }

  export type RegionUpdateOneWithoutEmploymentNestedInput = {
    create?: XOR<RegionCreateWithoutEmploymentInput, RegionUncheckedCreateWithoutEmploymentInput>
    connectOrCreate?: RegionCreateOrConnectWithoutEmploymentInput
    upsert?: RegionUpsertWithoutEmploymentInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutEmploymentInput, RegionUpdateWithoutEmploymentInput>, RegionUncheckedUpdateWithoutEmploymentInput>
  }

  export type EmploymentCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput> | EmploymentCreateWithoutBranchInput[] | EmploymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutBranchInput | EmploymentCreateOrConnectWithoutBranchInput[]
    createMany?: EmploymentCreateManyBranchInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type ClaimFinancialCreateNestedManyWithoutBranchPayeeInput = {
    create?: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput> | ClaimFinancialCreateWithoutBranchPayeeInput[] | ClaimFinancialUncheckedCreateWithoutBranchPayeeInput[]
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutBranchPayeeInput | ClaimFinancialCreateOrConnectWithoutBranchPayeeInput[]
    createMany?: ClaimFinancialCreateManyBranchPayeeInputEnvelope
    connect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
  }

  export type EmploymentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput> | EmploymentCreateWithoutBranchInput[] | EmploymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutBranchInput | EmploymentCreateOrConnectWithoutBranchInput[]
    createMany?: EmploymentCreateManyBranchInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type ClaimFinancialUncheckedCreateNestedManyWithoutBranchPayeeInput = {
    create?: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput> | ClaimFinancialCreateWithoutBranchPayeeInput[] | ClaimFinancialUncheckedCreateWithoutBranchPayeeInput[]
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutBranchPayeeInput | ClaimFinancialCreateOrConnectWithoutBranchPayeeInput[]
    createMany?: ClaimFinancialCreateManyBranchPayeeInputEnvelope
    connect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
  }

  export type EmploymentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput> | EmploymentCreateWithoutBranchInput[] | EmploymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutBranchInput | EmploymentCreateOrConnectWithoutBranchInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutBranchInput | EmploymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmploymentCreateManyBranchInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutBranchInput | EmploymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutBranchInput | EmploymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type ClaimFinancialUpdateManyWithoutBranchPayeeNestedInput = {
    create?: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput> | ClaimFinancialCreateWithoutBranchPayeeInput[] | ClaimFinancialUncheckedCreateWithoutBranchPayeeInput[]
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutBranchPayeeInput | ClaimFinancialCreateOrConnectWithoutBranchPayeeInput[]
    upsert?: ClaimFinancialUpsertWithWhereUniqueWithoutBranchPayeeInput | ClaimFinancialUpsertWithWhereUniqueWithoutBranchPayeeInput[]
    createMany?: ClaimFinancialCreateManyBranchPayeeInputEnvelope
    set?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    disconnect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    delete?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    connect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    update?: ClaimFinancialUpdateWithWhereUniqueWithoutBranchPayeeInput | ClaimFinancialUpdateWithWhereUniqueWithoutBranchPayeeInput[]
    updateMany?: ClaimFinancialUpdateManyWithWhereWithoutBranchPayeeInput | ClaimFinancialUpdateManyWithWhereWithoutBranchPayeeInput[]
    deleteMany?: ClaimFinancialScalarWhereInput | ClaimFinancialScalarWhereInput[]
  }

  export type EmploymentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput> | EmploymentCreateWithoutBranchInput[] | EmploymentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutBranchInput | EmploymentCreateOrConnectWithoutBranchInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutBranchInput | EmploymentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmploymentCreateManyBranchInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutBranchInput | EmploymentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutBranchInput | EmploymentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type ClaimFinancialUncheckedUpdateManyWithoutBranchPayeeNestedInput = {
    create?: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput> | ClaimFinancialCreateWithoutBranchPayeeInput[] | ClaimFinancialUncheckedCreateWithoutBranchPayeeInput[]
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutBranchPayeeInput | ClaimFinancialCreateOrConnectWithoutBranchPayeeInput[]
    upsert?: ClaimFinancialUpsertWithWhereUniqueWithoutBranchPayeeInput | ClaimFinancialUpsertWithWhereUniqueWithoutBranchPayeeInput[]
    createMany?: ClaimFinancialCreateManyBranchPayeeInputEnvelope
    set?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    disconnect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    delete?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    connect?: ClaimFinancialWhereUniqueInput | ClaimFinancialWhereUniqueInput[]
    update?: ClaimFinancialUpdateWithWhereUniqueWithoutBranchPayeeInput | ClaimFinancialUpdateWithWhereUniqueWithoutBranchPayeeInput[]
    updateMany?: ClaimFinancialUpdateManyWithWhereWithoutBranchPayeeInput | ClaimFinancialUpdateManyWithWhereWithoutBranchPayeeInput[]
    deleteMany?: ClaimFinancialScalarWhereInput | ClaimFinancialScalarWhereInput[]
  }

  export type EmploymentCreateNestedManyWithoutGroupInput = {
    create?: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput> | EmploymentCreateWithoutGroupInput[] | EmploymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutGroupInput | EmploymentCreateOrConnectWithoutGroupInput[]
    createMany?: EmploymentCreateManyGroupInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type EmploymentUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput> | EmploymentCreateWithoutGroupInput[] | EmploymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutGroupInput | EmploymentCreateOrConnectWithoutGroupInput[]
    createMany?: EmploymentCreateManyGroupInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type EmploymentUpdateManyWithoutGroupNestedInput = {
    create?: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput> | EmploymentCreateWithoutGroupInput[] | EmploymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutGroupInput | EmploymentCreateOrConnectWithoutGroupInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutGroupInput | EmploymentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: EmploymentCreateManyGroupInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutGroupInput | EmploymentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutGroupInput | EmploymentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type EmploymentUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput> | EmploymentCreateWithoutGroupInput[] | EmploymentUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutGroupInput | EmploymentCreateOrConnectWithoutGroupInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutGroupInput | EmploymentUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: EmploymentCreateManyGroupInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutGroupInput | EmploymentUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutGroupInput | EmploymentUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type EmploymentCreateNestedManyWithoutRegionInput = {
    create?: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput> | EmploymentCreateWithoutRegionInput[] | EmploymentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutRegionInput | EmploymentCreateOrConnectWithoutRegionInput[]
    createMany?: EmploymentCreateManyRegionInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type EmploymentUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput> | EmploymentCreateWithoutRegionInput[] | EmploymentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutRegionInput | EmploymentCreateOrConnectWithoutRegionInput[]
    createMany?: EmploymentCreateManyRegionInputEnvelope
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
  }

  export type EmploymentUpdateManyWithoutRegionNestedInput = {
    create?: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput> | EmploymentCreateWithoutRegionInput[] | EmploymentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutRegionInput | EmploymentCreateOrConnectWithoutRegionInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutRegionInput | EmploymentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: EmploymentCreateManyRegionInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutRegionInput | EmploymentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutRegionInput | EmploymentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type EmploymentUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput> | EmploymentCreateWithoutRegionInput[] | EmploymentUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: EmploymentCreateOrConnectWithoutRegionInput | EmploymentCreateOrConnectWithoutRegionInput[]
    upsert?: EmploymentUpsertWithWhereUniqueWithoutRegionInput | EmploymentUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: EmploymentCreateManyRegionInputEnvelope
    set?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    disconnect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    delete?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    connect?: EmploymentWhereUniqueInput | EmploymentWhereUniqueInput[]
    update?: EmploymentUpdateWithWhereUniqueWithoutRegionInput | EmploymentUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: EmploymentUpdateManyWithWhereWithoutRegionInput | EmploymentUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAnnouncementCreatedInput = {
    create?: XOR<UserCreateWithoutAnnouncementCreatedInput, UserUncheckedCreateWithoutAnnouncementCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAnnouncementCreatedNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementCreatedInput, UserUncheckedCreateWithoutAnnouncementCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementCreatedInput
    upsert?: UserUpsertWithoutAnnouncementCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementCreatedInput, UserUpdateWithoutAnnouncementCreatedInput>, UserUncheckedUpdateWithoutAnnouncementCreatedInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type ParticipantCreateNestedOneWithoutProgramParticipationsInput = {
    create?: XOR<ParticipantCreateWithoutProgramParticipationsInput, ParticipantUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutProgramParticipationsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutProgramParticipationInput = {
    create?: XOR<AccountCreateWithoutProgramParticipationInput, AccountUncheckedCreateWithoutProgramParticipationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProgramParticipationInput
    connect?: AccountWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutProgramParticipationsInput = {
    create?: XOR<ProgramCreateWithoutProgramParticipationsInput, ProgramUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramParticipationsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ParticipantUpdateOneRequiredWithoutProgramParticipationsNestedInput = {
    create?: XOR<ParticipantCreateWithoutProgramParticipationsInput, ParticipantUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutProgramParticipationsInput
    upsert?: ParticipantUpsertWithoutProgramParticipationsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutProgramParticipationsInput, ParticipantUpdateWithoutProgramParticipationsInput>, ParticipantUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type AccountUpdateOneRequiredWithoutProgramParticipationNestedInput = {
    create?: XOR<AccountCreateWithoutProgramParticipationInput, AccountUncheckedCreateWithoutProgramParticipationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutProgramParticipationInput
    upsert?: AccountUpsertWithoutProgramParticipationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutProgramParticipationInput, AccountUpdateWithoutProgramParticipationInput>, AccountUncheckedUpdateWithoutProgramParticipationInput>
  }

  export type ProgramUpdateOneWithoutProgramParticipationsNestedInput = {
    create?: XOR<ProgramCreateWithoutProgramParticipationsInput, ProgramUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramParticipationsInput
    upsert?: ProgramUpsertWithoutProgramParticipationsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutProgramParticipationsInput, ProgramUpdateWithoutProgramParticipationsInput>, ProgramUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type ProgramParticipationCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput> | ProgramParticipationCreateWithoutProgramInput[] | ProgramParticipationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutProgramInput | ProgramParticipationCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramParticipationCreateManyProgramInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type ClaimTypeCreateNestedManyWithoutProgramInput = {
    create?: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput> | ClaimTypeCreateWithoutProgramInput[] | ClaimTypeUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutProgramInput | ClaimTypeCreateOrConnectWithoutProgramInput[]
    createMany?: ClaimTypeCreateManyProgramInputEnvelope
    connect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
  }

  export type ProgramParticipationUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput> | ProgramParticipationCreateWithoutProgramInput[] | ProgramParticipationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutProgramInput | ProgramParticipationCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramParticipationCreateManyProgramInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type ClaimTypeUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput> | ClaimTypeCreateWithoutProgramInput[] | ClaimTypeUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutProgramInput | ClaimTypeCreateOrConnectWithoutProgramInput[]
    createMany?: ClaimTypeCreateManyProgramInputEnvelope
    connect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
  }

  export type EnumApplicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationType
  }

  export type EnumClassFieldUpdateOperationsInput = {
    set?: $Enums.Class
  }

  export type ProgramParticipationUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput> | ProgramParticipationCreateWithoutProgramInput[] | ProgramParticipationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutProgramInput | ProgramParticipationCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutProgramInput | ProgramParticipationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramParticipationCreateManyProgramInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutProgramInput | ProgramParticipationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutProgramInput | ProgramParticipationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type ClaimTypeUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput> | ClaimTypeCreateWithoutProgramInput[] | ClaimTypeUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutProgramInput | ClaimTypeCreateOrConnectWithoutProgramInput[]
    upsert?: ClaimTypeUpsertWithWhereUniqueWithoutProgramInput | ClaimTypeUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ClaimTypeCreateManyProgramInputEnvelope
    set?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    disconnect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    delete?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    connect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    update?: ClaimTypeUpdateWithWhereUniqueWithoutProgramInput | ClaimTypeUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ClaimTypeUpdateManyWithWhereWithoutProgramInput | ClaimTypeUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ClaimTypeScalarWhereInput | ClaimTypeScalarWhereInput[]
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput> | ProgramParticipationCreateWithoutProgramInput[] | ProgramParticipationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutProgramInput | ProgramParticipationCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutProgramInput | ProgramParticipationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramParticipationCreateManyProgramInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutProgramInput | ProgramParticipationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutProgramInput | ProgramParticipationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type ClaimTypeUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput> | ClaimTypeCreateWithoutProgramInput[] | ClaimTypeUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutProgramInput | ClaimTypeCreateOrConnectWithoutProgramInput[]
    upsert?: ClaimTypeUpsertWithWhereUniqueWithoutProgramInput | ClaimTypeUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ClaimTypeCreateManyProgramInputEnvelope
    set?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    disconnect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    delete?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    connect?: ClaimTypeWhereUniqueInput | ClaimTypeWhereUniqueInput[]
    update?: ClaimTypeUpdateWithWhereUniqueWithoutProgramInput | ClaimTypeUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ClaimTypeUpdateManyWithWhereWithoutProgramInput | ClaimTypeUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ClaimTypeScalarWhereInput | ClaimTypeScalarWhereInput[]
  }

  export type ParticipantCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ParticipantCreateWithoutClaimsInput, ParticipantUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutClaimsInput
    connect?: ParticipantWhereUniqueInput
  }

  export type ClaimFinancialCreateNestedOneWithoutClaimInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimInput, ClaimFinancialUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimInput
    connect?: ClaimFinancialWhereUniqueInput
  }

  export type ClaimProcessCreateNestedOneWithoutClaimInput = {
    create?: XOR<ClaimProcessCreateWithoutClaimInput, ClaimProcessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimProcessCreateOrConnectWithoutClaimInput
    connect?: ClaimProcessWhereUniqueInput
  }

  export type DiseaseCreateNestedOneWithoutClaimsInput = {
    create?: XOR<DiseaseCreateWithoutClaimsInput, DiseaseUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: DiseaseCreateOrConnectWithoutClaimsInput
    connect?: DiseaseWhereUniqueInput
  }

  export type ClinicCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ClinicCreateWithoutClaimsInput, ClinicUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutClaimsInput
    connect?: ClinicWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClaimsInputInput = {
    create?: XOR<UserCreateWithoutClaimsInputInput, UserUncheckedCreateWithoutClaimsInputInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInputInput
    connect?: UserWhereUniqueInput
  }

  export type ClaimTypeCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ClaimTypeCreateWithoutClaimsInput, ClaimTypeUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutClaimsInput
    connect?: ClaimTypeWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutClaimsInput = {
    create?: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput> | TagCreateWithoutClaimsInput[] | TagUncheckedCreateWithoutClaimsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutClaimsInput | TagCreateOrConnectWithoutClaimsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ClaimStatusCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput> | ClaimStatusCreateWithoutClaimInput[] | ClaimStatusUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimInput | ClaimStatusCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimStatusCreateManyClaimInputEnvelope
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutClaimsInput = {
    create?: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput> | TagCreateWithoutClaimsInput[] | TagUncheckedCreateWithoutClaimsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutClaimsInput | TagCreateOrConnectWithoutClaimsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ClaimStatusUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput> | ClaimStatusCreateWithoutClaimInput[] | ClaimStatusUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimInput | ClaimStatusCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimStatusCreateManyClaimInputEnvelope
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
  }

  export type EnumClaimChannelFieldUpdateOperationsInput = {
    set?: $Enums.ClaimChannel
  }

  export type EnumAdmedicaStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdmedicaStatus
  }

  export type ParticipantUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<ParticipantCreateWithoutClaimsInput, ParticipantUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutClaimsInput
    upsert?: ParticipantUpsertWithoutClaimsInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutClaimsInput, ParticipantUpdateWithoutClaimsInput>, ParticipantUncheckedUpdateWithoutClaimsInput>
  }

  export type ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimInput, ClaimFinancialUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimInput
    upsert?: ClaimFinancialUpsertWithoutClaimInput
    connect?: ClaimFinancialWhereUniqueInput
    update?: XOR<XOR<ClaimFinancialUpdateToOneWithWhereWithoutClaimInput, ClaimFinancialUpdateWithoutClaimInput>, ClaimFinancialUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimProcessUpdateOneRequiredWithoutClaimNestedInput = {
    create?: XOR<ClaimProcessCreateWithoutClaimInput, ClaimProcessUncheckedCreateWithoutClaimInput>
    connectOrCreate?: ClaimProcessCreateOrConnectWithoutClaimInput
    upsert?: ClaimProcessUpsertWithoutClaimInput
    connect?: ClaimProcessWhereUniqueInput
    update?: XOR<XOR<ClaimProcessUpdateToOneWithWhereWithoutClaimInput, ClaimProcessUpdateWithoutClaimInput>, ClaimProcessUncheckedUpdateWithoutClaimInput>
  }

  export type DiseaseUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<DiseaseCreateWithoutClaimsInput, DiseaseUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: DiseaseCreateOrConnectWithoutClaimsInput
    upsert?: DiseaseUpsertWithoutClaimsInput
    disconnect?: DiseaseWhereInput | boolean
    delete?: DiseaseWhereInput | boolean
    connect?: DiseaseWhereUniqueInput
    update?: XOR<XOR<DiseaseUpdateToOneWithWhereWithoutClaimsInput, DiseaseUpdateWithoutClaimsInput>, DiseaseUncheckedUpdateWithoutClaimsInput>
  }

  export type ClinicUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<ClinicCreateWithoutClaimsInput, ClinicUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutClaimsInput
    upsert?: ClinicUpsertWithoutClaimsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutClaimsInput, ClinicUpdateWithoutClaimsInput>, ClinicUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateOneWithoutClaimsInputNestedInput = {
    create?: XOR<UserCreateWithoutClaimsInputInput, UserUncheckedCreateWithoutClaimsInputInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInputInput
    upsert?: UserUpsertWithoutClaimsInputInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsInputInput, UserUpdateWithoutClaimsInputInput>, UserUncheckedUpdateWithoutClaimsInputInput>
  }

  export type ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<ClaimTypeCreateWithoutClaimsInput, ClaimTypeUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ClaimTypeCreateOrConnectWithoutClaimsInput
    upsert?: ClaimTypeUpsertWithoutClaimsInput
    connect?: ClaimTypeWhereUniqueInput
    update?: XOR<XOR<ClaimTypeUpdateToOneWithWhereWithoutClaimsInput, ClaimTypeUpdateWithoutClaimsInput>, ClaimTypeUncheckedUpdateWithoutClaimsInput>
  }

  export type TagUpdateManyWithoutClaimsNestedInput = {
    create?: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput> | TagCreateWithoutClaimsInput[] | TagUncheckedCreateWithoutClaimsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutClaimsInput | TagCreateOrConnectWithoutClaimsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutClaimsInput | TagUpsertWithWhereUniqueWithoutClaimsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutClaimsInput | TagUpdateWithWhereUniqueWithoutClaimsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutClaimsInput | TagUpdateManyWithWhereWithoutClaimsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ClaimStatusUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput> | ClaimStatusCreateWithoutClaimInput[] | ClaimStatusUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimInput | ClaimStatusCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimStatusUpsertWithWhereUniqueWithoutClaimInput | ClaimStatusUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimStatusCreateManyClaimInputEnvelope
    set?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    disconnect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    delete?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    update?: ClaimStatusUpdateWithWhereUniqueWithoutClaimInput | ClaimStatusUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimStatusUpdateManyWithWhereWithoutClaimInput | ClaimStatusUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutClaimsNestedInput = {
    create?: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput> | TagCreateWithoutClaimsInput[] | TagUncheckedCreateWithoutClaimsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutClaimsInput | TagCreateOrConnectWithoutClaimsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutClaimsInput | TagUpsertWithWhereUniqueWithoutClaimsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutClaimsInput | TagUpdateWithWhereUniqueWithoutClaimsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutClaimsInput | TagUpdateManyWithWhereWithoutClaimsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput> | ClaimStatusCreateWithoutClaimInput[] | ClaimStatusUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimInput | ClaimStatusCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimStatusUpsertWithWhereUniqueWithoutClaimInput | ClaimStatusUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimStatusCreateManyClaimInputEnvelope
    set?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    disconnect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    delete?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    connect?: ClaimStatusWhereUniqueInput | ClaimStatusWhereUniqueInput[]
    update?: ClaimStatusUpdateWithWhereUniqueWithoutClaimInput | ClaimStatusUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimStatusUpdateManyWithWhereWithoutClaimInput | ClaimStatusUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
  }

  export type ClaimStatusCreateNestedOneWithoutRejectionLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutRejectionLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutGuaranteeLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusCreateNestedOneWithoutTransactionLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutTransactionLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput = {
    create?: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutBookKeepingOrderInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimProcessCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClaimProcessCreateWithoutDocumentsInput, ClaimProcessUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClaimProcessCreateOrConnectWithoutDocumentsInput
    connect?: ClaimProcessWhereUniqueInput
  }

  export type ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutRejectionLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutGuaranteeLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput = {
    create?: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutTransactionLetterInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput = {
    create?: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutBookKeepingOrderInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type EnumDocumentSourceFieldUpdateOperationsInput = {
    set?: $Enums.DocumentSource
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type ClaimStatusUpdateOneWithoutRejectionLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutRejectionLetterInput
    upsert?: ClaimStatusUpsertWithoutRejectionLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutRejectionLetterInput, ClaimStatusUpdateWithoutRejectionLetterInput>, ClaimStatusUncheckedUpdateWithoutRejectionLetterInput>
  }

  export type ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutGuaranteeLetterInput
    upsert?: ClaimStatusUpsertWithoutGuaranteeLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutGuaranteeLetterInput, ClaimStatusUpdateWithoutGuaranteeLetterInput>, ClaimStatusUncheckedUpdateWithoutGuaranteeLetterInput>
  }

  export type ClaimStatusUpdateOneWithoutTransactionLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutTransactionLetterInput
    upsert?: ClaimStatusUpsertWithoutTransactionLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutTransactionLetterInput, ClaimStatusUpdateWithoutTransactionLetterInput>, ClaimStatusUncheckedUpdateWithoutTransactionLetterInput>
  }

  export type ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutBookKeepingOrderInput
    upsert?: ClaimStatusUpsertWithoutBookKeepingOrderInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutBookKeepingOrderInput, ClaimStatusUpdateWithoutBookKeepingOrderInput>, ClaimStatusUncheckedUpdateWithoutBookKeepingOrderInput>
  }

  export type ClaimProcessUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClaimProcessCreateWithoutDocumentsInput, ClaimProcessUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClaimProcessCreateOrConnectWithoutDocumentsInput
    upsert?: ClaimProcessUpsertWithoutDocumentsInput
    disconnect?: ClaimProcessWhereInput | boolean
    delete?: ClaimProcessWhereInput | boolean
    connect?: ClaimProcessWhereUniqueInput
    update?: XOR<XOR<ClaimProcessUpdateToOneWithWhereWithoutDocumentsInput, ClaimProcessUpdateWithoutDocumentsInput>, ClaimProcessUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutRejectionLetterInput
    upsert?: ClaimStatusUpsertWithoutRejectionLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutRejectionLetterInput, ClaimStatusUpdateWithoutRejectionLetterInput>, ClaimStatusUncheckedUpdateWithoutRejectionLetterInput>
  }

  export type ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutGuaranteeLetterInput
    upsert?: ClaimStatusUpsertWithoutGuaranteeLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutGuaranteeLetterInput, ClaimStatusUpdateWithoutGuaranteeLetterInput>, ClaimStatusUncheckedUpdateWithoutGuaranteeLetterInput>
  }

  export type ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutTransactionLetterInput
    upsert?: ClaimStatusUpsertWithoutTransactionLetterInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutTransactionLetterInput, ClaimStatusUpdateWithoutTransactionLetterInput>, ClaimStatusUncheckedUpdateWithoutTransactionLetterInput>
  }

  export type ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutBookKeepingOrderInput
    upsert?: ClaimStatusUpsertWithoutBookKeepingOrderInput
    disconnect?: ClaimStatusWhereInput | boolean
    delete?: ClaimStatusWhereInput | boolean
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutBookKeepingOrderInput, ClaimStatusUpdateWithoutBookKeepingOrderInput>, ClaimStatusUncheckedUpdateWithoutBookKeepingOrderInput>
  }

  export type ClaimCreateNestedManyWithoutTagsInput = {
    create?: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput> | ClaimCreateWithoutTagsInput[] | ClaimUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutTagsInput | ClaimCreateOrConnectWithoutTagsInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput> | ClaimCreateWithoutTagsInput[] | ClaimUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutTagsInput | ClaimCreateOrConnectWithoutTagsInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EnumColorFieldUpdateOperationsInput = {
    set?: $Enums.Color
  }

  export type ClaimUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput> | ClaimCreateWithoutTagsInput[] | ClaimUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutTagsInput | ClaimCreateOrConnectWithoutTagsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutTagsInput | ClaimUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutTagsInput | ClaimUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutTagsInput | ClaimUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput> | ClaimCreateWithoutTagsInput[] | ClaimUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutTagsInput | ClaimCreateOrConnectWithoutTagsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutTagsInput | ClaimUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutTagsInput | ClaimUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutTagsInput | ClaimUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutClaimTypeInput = {
    create?: XOR<ProgramCreateWithoutClaimTypeInput, ProgramUncheckedCreateWithoutClaimTypeInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutClaimTypeInput
    connect?: ProgramWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutClaimTypesInput = {
    create?: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimTypesInput
    connect?: ClaimWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedOneWithoutClaimTypesInput = {
    create?: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimTypesInput
    connect?: ClaimWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutClaimTypeNestedInput = {
    create?: XOR<ProgramCreateWithoutClaimTypeInput, ProgramUncheckedCreateWithoutClaimTypeInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutClaimTypeInput
    upsert?: ProgramUpsertWithoutClaimTypeInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutClaimTypeInput, ProgramUpdateWithoutClaimTypeInput>, ProgramUncheckedUpdateWithoutClaimTypeInput>
  }

  export type ClaimUpdateOneWithoutClaimTypesNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimTypesInput
    upsert?: ClaimUpsertWithoutClaimTypesInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimTypesInput, ClaimUpdateWithoutClaimTypesInput>, ClaimUncheckedUpdateWithoutClaimTypesInput>
  }

  export type ClaimUncheckedUpdateOneWithoutClaimTypesNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimTypesInput
    upsert?: ClaimUpsertWithoutClaimTypesInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimTypesInput, ClaimUpdateWithoutClaimTypesInput>, ClaimUncheckedUpdateWithoutClaimTypesInput>
  }

  export type BranchCreateNestedOneWithoutClaimFinancialInput = {
    create?: XOR<BranchCreateWithoutClaimFinancialInput, BranchUncheckedCreateWithoutClaimFinancialInput>
    connectOrCreate?: BranchCreateOrConnectWithoutClaimFinancialInput
    connect?: BranchWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutClaimFinancialsInput = {
    create?: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimFinancialsInput
    connect?: ClaimWhereUniqueInput
  }

  export type ClaimStatusCreateNestedOneWithoutClaimFinancialInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimFinancialInput, ClaimStatusUncheckedCreateWithoutClaimFinancialInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimFinancialInput
    connect?: ClaimStatusWhereUniqueInput
  }

  export type ClaimUncheckedCreateNestedOneWithoutClaimFinancialsInput = {
    create?: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimFinancialsInput
    connect?: ClaimWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchUpdateOneRequiredWithoutClaimFinancialNestedInput = {
    create?: XOR<BranchCreateWithoutClaimFinancialInput, BranchUncheckedCreateWithoutClaimFinancialInput>
    connectOrCreate?: BranchCreateOrConnectWithoutClaimFinancialInput
    upsert?: BranchUpsertWithoutClaimFinancialInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutClaimFinancialInput, BranchUpdateWithoutClaimFinancialInput>, BranchUncheckedUpdateWithoutClaimFinancialInput>
  }

  export type ClaimUpdateOneWithoutClaimFinancialsNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimFinancialsInput
    upsert?: ClaimUpsertWithoutClaimFinancialsInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimFinancialsInput, ClaimUpdateWithoutClaimFinancialsInput>, ClaimUncheckedUpdateWithoutClaimFinancialsInput>
  }

  export type ClaimStatusUpdateOneRequiredWithoutClaimFinancialNestedInput = {
    create?: XOR<ClaimStatusCreateWithoutClaimFinancialInput, ClaimStatusUncheckedCreateWithoutClaimFinancialInput>
    connectOrCreate?: ClaimStatusCreateOrConnectWithoutClaimFinancialInput
    upsert?: ClaimStatusUpsertWithoutClaimFinancialInput
    connect?: ClaimStatusWhereUniqueInput
    update?: XOR<XOR<ClaimStatusUpdateToOneWithWhereWithoutClaimFinancialInput, ClaimStatusUpdateWithoutClaimFinancialInput>, ClaimStatusUncheckedUpdateWithoutClaimFinancialInput>
  }

  export type ClaimUncheckedUpdateOneWithoutClaimFinancialsNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimFinancialsInput
    upsert?: ClaimUpsertWithoutClaimFinancialsInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimFinancialsInput, ClaimUpdateWithoutClaimFinancialsInput>, ClaimUncheckedUpdateWithoutClaimFinancialsInput>
  }

  export type ClaimCreateNestedOneWithoutClaimProcessesInput = {
    create?: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimProcessesInput
    connect?: ClaimWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutClaimProcessInput = {
    create?: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput> | DocumentCreateWithoutClaimProcessInput[] | DocumentUncheckedCreateWithoutClaimProcessInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClaimProcessInput | DocumentCreateOrConnectWithoutClaimProcessInput[]
    createMany?: DocumentCreateManyClaimProcessInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedOneWithoutClaimProcessesInput = {
    create?: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimProcessesInput
    connect?: ClaimWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutClaimProcessInput = {
    create?: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput> | DocumentCreateWithoutClaimProcessInput[] | DocumentUncheckedCreateWithoutClaimProcessInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClaimProcessInput | DocumentCreateOrConnectWithoutClaimProcessInput[]
    createMany?: DocumentCreateManyClaimProcessInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClaimUpdateOneWithoutClaimProcessesNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimProcessesInput
    upsert?: ClaimUpsertWithoutClaimProcessesInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimProcessesInput, ClaimUpdateWithoutClaimProcessesInput>, ClaimUncheckedUpdateWithoutClaimProcessesInput>
  }

  export type DocumentUpdateManyWithoutClaimProcessNestedInput = {
    create?: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput> | DocumentCreateWithoutClaimProcessInput[] | DocumentUncheckedCreateWithoutClaimProcessInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClaimProcessInput | DocumentCreateOrConnectWithoutClaimProcessInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClaimProcessInput | DocumentUpsertWithWhereUniqueWithoutClaimProcessInput[]
    createMany?: DocumentCreateManyClaimProcessInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClaimProcessInput | DocumentUpdateWithWhereUniqueWithoutClaimProcessInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClaimProcessInput | DocumentUpdateManyWithWhereWithoutClaimProcessInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateOneWithoutClaimProcessesNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimProcessesInput
    upsert?: ClaimUpsertWithoutClaimProcessesInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimProcessesInput, ClaimUpdateWithoutClaimProcessesInput>, ClaimUncheckedUpdateWithoutClaimProcessesInput>
  }

  export type DocumentUncheckedUpdateManyWithoutClaimProcessNestedInput = {
    create?: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput> | DocumentCreateWithoutClaimProcessInput[] | DocumentUncheckedCreateWithoutClaimProcessInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClaimProcessInput | DocumentCreateOrConnectWithoutClaimProcessInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClaimProcessInput | DocumentUpsertWithWhereUniqueWithoutClaimProcessInput[]
    createMany?: DocumentCreateManyClaimProcessInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClaimProcessInput | DocumentUpdateWithWhereUniqueWithoutClaimProcessInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClaimProcessInput | DocumentUpdateManyWithWhereWithoutClaimProcessInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClaimActionsInput = {
    create?: XOR<UserCreateWithoutClaimActionsInput, UserUncheckedCreateWithoutClaimActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimActionsInput
    connect?: UserWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutClaimStatusesInput = {
    create?: XOR<ClaimCreateWithoutClaimStatusesInput, ClaimUncheckedCreateWithoutClaimStatusesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimStatusesInput
    connect?: ClaimWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutRejectionLetterOfInput = {
    create?: XOR<DocumentCreateWithoutRejectionLetterOfInput, DocumentUncheckedCreateWithoutRejectionLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutRejectionLetterOfInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutGuaranteeLetterOfInput = {
    create?: XOR<DocumentCreateWithoutGuaranteeLetterOfInput, DocumentUncheckedCreateWithoutGuaranteeLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutGuaranteeLetterOfInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutTransactionLetterOfInput = {
    create?: XOR<DocumentCreateWithoutTransactionLetterOfInput, DocumentUncheckedCreateWithoutTransactionLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutTransactionLetterOfInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutBookKeepingOrderOfInput = {
    create?: XOR<DocumentCreateWithoutBookKeepingOrderOfInput, DocumentUncheckedCreateWithoutBookKeepingOrderOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutBookKeepingOrderOfInput
    connect?: DocumentWhereUniqueInput
  }

  export type ClaimFinancialCreateNestedOneWithoutClaimStatusInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimStatusInput
    connect?: ClaimFinancialWhereUniqueInput
  }

  export type ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimStatusInput
    connect?: ClaimFinancialWhereUniqueInput
  }

  export type EnumClaimStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatusType
  }

  export type UserUpdateOneRequiredWithoutClaimActionsNestedInput = {
    create?: XOR<UserCreateWithoutClaimActionsInput, UserUncheckedCreateWithoutClaimActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimActionsInput
    upsert?: UserUpsertWithoutClaimActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimActionsInput, UserUpdateWithoutClaimActionsInput>, UserUncheckedUpdateWithoutClaimActionsInput>
  }

  export type ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput = {
    create?: XOR<ClaimCreateWithoutClaimStatusesInput, ClaimUncheckedCreateWithoutClaimStatusesInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutClaimStatusesInput
    upsert?: ClaimUpsertWithoutClaimStatusesInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutClaimStatusesInput, ClaimUpdateWithoutClaimStatusesInput>, ClaimUncheckedUpdateWithoutClaimStatusesInput>
  }

  export type DocumentUpdateOneWithoutRejectionLetterOfNestedInput = {
    create?: XOR<DocumentCreateWithoutRejectionLetterOfInput, DocumentUncheckedCreateWithoutRejectionLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutRejectionLetterOfInput
    upsert?: DocumentUpsertWithoutRejectionLetterOfInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutRejectionLetterOfInput, DocumentUpdateWithoutRejectionLetterOfInput>, DocumentUncheckedUpdateWithoutRejectionLetterOfInput>
  }

  export type DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput = {
    create?: XOR<DocumentCreateWithoutGuaranteeLetterOfInput, DocumentUncheckedCreateWithoutGuaranteeLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutGuaranteeLetterOfInput
    upsert?: DocumentUpsertWithoutGuaranteeLetterOfInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutGuaranteeLetterOfInput, DocumentUpdateWithoutGuaranteeLetterOfInput>, DocumentUncheckedUpdateWithoutGuaranteeLetterOfInput>
  }

  export type DocumentUpdateOneWithoutTransactionLetterOfNestedInput = {
    create?: XOR<DocumentCreateWithoutTransactionLetterOfInput, DocumentUncheckedCreateWithoutTransactionLetterOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutTransactionLetterOfInput
    upsert?: DocumentUpsertWithoutTransactionLetterOfInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutTransactionLetterOfInput, DocumentUpdateWithoutTransactionLetterOfInput>, DocumentUncheckedUpdateWithoutTransactionLetterOfInput>
  }

  export type DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput = {
    create?: XOR<DocumentCreateWithoutBookKeepingOrderOfInput, DocumentUncheckedCreateWithoutBookKeepingOrderOfInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutBookKeepingOrderOfInput
    upsert?: DocumentUpsertWithoutBookKeepingOrderOfInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutBookKeepingOrderOfInput, DocumentUpdateWithoutBookKeepingOrderOfInput>, DocumentUncheckedUpdateWithoutBookKeepingOrderOfInput>
  }

  export type ClaimFinancialUpdateOneWithoutClaimStatusNestedInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimStatusInput
    upsert?: ClaimFinancialUpsertWithoutClaimStatusInput
    disconnect?: ClaimFinancialWhereInput | boolean
    delete?: ClaimFinancialWhereInput | boolean
    connect?: ClaimFinancialWhereUniqueInput
    update?: XOR<XOR<ClaimFinancialUpdateToOneWithWhereWithoutClaimStatusInput, ClaimFinancialUpdateWithoutClaimStatusInput>, ClaimFinancialUncheckedUpdateWithoutClaimStatusInput>
  }

  export type ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput = {
    create?: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
    connectOrCreate?: ClaimFinancialCreateOrConnectWithoutClaimStatusInput
    upsert?: ClaimFinancialUpsertWithoutClaimStatusInput
    disconnect?: ClaimFinancialWhereInput | boolean
    delete?: ClaimFinancialWhereInput | boolean
    connect?: ClaimFinancialWhereUniqueInput
    update?: XOR<XOR<ClaimFinancialUpdateToOneWithWhereWithoutClaimStatusInput, ClaimFinancialUpdateWithoutClaimStatusInput>, ClaimFinancialUncheckedUpdateWithoutClaimStatusInput>
  }

  export type ClaimCreateNestedManyWithoutDiseaseInput = {
    create?: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput> | ClaimCreateWithoutDiseaseInput[] | ClaimUncheckedCreateWithoutDiseaseInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDiseaseInput | ClaimCreateOrConnectWithoutDiseaseInput[]
    createMany?: ClaimCreateManyDiseaseInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutDiseaseInput = {
    create?: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput> | ClaimCreateWithoutDiseaseInput[] | ClaimUncheckedCreateWithoutDiseaseInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDiseaseInput | ClaimCreateOrConnectWithoutDiseaseInput[]
    createMany?: ClaimCreateManyDiseaseInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUpdateManyWithoutDiseaseNestedInput = {
    create?: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput> | ClaimCreateWithoutDiseaseInput[] | ClaimUncheckedCreateWithoutDiseaseInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDiseaseInput | ClaimCreateOrConnectWithoutDiseaseInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutDiseaseInput | ClaimUpsertWithWhereUniqueWithoutDiseaseInput[]
    createMany?: ClaimCreateManyDiseaseInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutDiseaseInput | ClaimUpdateWithWhereUniqueWithoutDiseaseInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutDiseaseInput | ClaimUpdateManyWithWhereWithoutDiseaseInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutDiseaseNestedInput = {
    create?: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput> | ClaimCreateWithoutDiseaseInput[] | ClaimUncheckedCreateWithoutDiseaseInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDiseaseInput | ClaimCreateOrConnectWithoutDiseaseInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutDiseaseInput | ClaimUpsertWithWhereUniqueWithoutDiseaseInput[]
    createMany?: ClaimCreateManyDiseaseInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutDiseaseInput | ClaimUpdateWithWhereUniqueWithoutDiseaseInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutDiseaseInput | ClaimUpdateManyWithWhereWithoutDiseaseInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimCreateNestedManyWithoutClinicsInput = {
    create?: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput> | ClaimCreateWithoutClinicsInput[] | ClaimUncheckedCreateWithoutClinicsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClinicsInput | ClaimCreateOrConnectWithoutClinicsInput[]
    createMany?: ClaimCreateManyClinicsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutClinicsInput = {
    create?: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput> | ClaimCreateWithoutClinicsInput[] | ClaimUncheckedCreateWithoutClinicsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClinicsInput | ClaimCreateOrConnectWithoutClinicsInput[]
    createMany?: ClaimCreateManyClinicsInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUpdateManyWithoutClinicsNestedInput = {
    create?: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput> | ClaimCreateWithoutClinicsInput[] | ClaimUncheckedCreateWithoutClinicsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClinicsInput | ClaimCreateOrConnectWithoutClinicsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClinicsInput | ClaimUpsertWithWhereUniqueWithoutClinicsInput[]
    createMany?: ClaimCreateManyClinicsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClinicsInput | ClaimUpdateWithWhereUniqueWithoutClinicsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClinicsInput | ClaimUpdateManyWithWhereWithoutClinicsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutClinicsNestedInput = {
    create?: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput> | ClaimCreateWithoutClinicsInput[] | ClaimUncheckedCreateWithoutClinicsInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutClinicsInput | ClaimCreateOrConnectWithoutClinicsInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutClinicsInput | ClaimUpsertWithWhereUniqueWithoutClinicsInput[]
    createMany?: ClaimCreateManyClinicsInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutClinicsInput | ClaimUpdateWithWhereUniqueWithoutClinicsInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutClinicsInput | ClaimUpdateManyWithWhereWithoutClinicsInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ParticipantCreateNestedOneWithoutBalancesInput = {
    create?: XOR<ParticipantCreateWithoutBalancesInput, ParticipantUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutBalancesInput
    connect?: ParticipantWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProgramParticipationCreateNestedManyWithoutFundingInput = {
    create?: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput> | ProgramParticipationCreateWithoutFundingInput[] | ProgramParticipationUncheckedCreateWithoutFundingInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutFundingInput | ProgramParticipationCreateOrConnectWithoutFundingInput[]
    createMany?: ProgramParticipationCreateManyFundingInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProgramParticipationUncheckedCreateNestedManyWithoutFundingInput = {
    create?: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput> | ProgramParticipationCreateWithoutFundingInput[] | ProgramParticipationUncheckedCreateWithoutFundingInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutFundingInput | ProgramParticipationCreateOrConnectWithoutFundingInput[]
    createMany?: ProgramParticipationCreateManyFundingInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type ParticipantUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<ParticipantCreateWithoutBalancesInput, ParticipantUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutBalancesInput
    upsert?: ParticipantUpsertWithoutBalancesInput
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutBalancesInput, ParticipantUpdateWithoutBalancesInput>, ParticipantUncheckedUpdateWithoutBalancesInput>
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProgramParticipationUpdateManyWithoutFundingNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput> | ProgramParticipationCreateWithoutFundingInput[] | ProgramParticipationUncheckedCreateWithoutFundingInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutFundingInput | ProgramParticipationCreateOrConnectWithoutFundingInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutFundingInput | ProgramParticipationUpsertWithWhereUniqueWithoutFundingInput[]
    createMany?: ProgramParticipationCreateManyFundingInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutFundingInput | ProgramParticipationUpdateWithWhereUniqueWithoutFundingInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutFundingInput | ProgramParticipationUpdateManyWithWhereWithoutFundingInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutFundingNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput> | ProgramParticipationCreateWithoutFundingInput[] | ProgramParticipationUncheckedCreateWithoutFundingInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutFundingInput | ProgramParticipationCreateOrConnectWithoutFundingInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutFundingInput | ProgramParticipationUpsertWithWhereUniqueWithoutFundingInput[]
    createMany?: ProgramParticipationCreateManyFundingInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutFundingInput | ProgramParticipationUpdateWithWhereUniqueWithoutFundingInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutFundingInput | ProgramParticipationUpdateManyWithWhereWithoutFundingInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type AccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTransactionsInput
    upsert?: AccountUpsertWithoutTransactionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTransactionsInput, AccountUpdateWithoutTransactionsInput>, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type NestedEnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusFilter<$PrismaModel> | $Enums.ParticipantStatus
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumParticipantStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPositionFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionFilter<$PrismaModel> | $Enums.Position
  }

  export type NestedEnumPositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Position | EnumPositionFieldRefInput<$PrismaModel>
    in?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Position[] | ListEnumPositionFieldRefInput<$PrismaModel>
    not?: NestedEnumPositionWithAggregatesFilter<$PrismaModel> | $Enums.Position
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPositionFilter<$PrismaModel>
    _max?: NestedEnumPositionFilter<$PrismaModel>
  }

  export type NestedEnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type NestedEnumClassFilter<$PrismaModel = never> = {
    equals?: $Enums.Class | EnumClassFieldRefInput<$PrismaModel>
    in?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    notIn?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    not?: NestedEnumClassFilter<$PrismaModel> | $Enums.Class
  }

  export type NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumClassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Class | EnumClassFieldRefInput<$PrismaModel>
    in?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    notIn?: $Enums.Class[] | ListEnumClassFieldRefInput<$PrismaModel>
    not?: NestedEnumClassWithAggregatesFilter<$PrismaModel> | $Enums.Class
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassFilter<$PrismaModel>
    _max?: NestedEnumClassFilter<$PrismaModel>
  }

  export type NestedEnumClaimChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimChannel | EnumClaimChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimChannelFilter<$PrismaModel> | $Enums.ClaimChannel
  }

  export type NestedEnumAdmedicaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmedicaStatus | EnumAdmedicaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmedicaStatusFilter<$PrismaModel> | $Enums.AdmedicaStatus
  }

  export type NestedEnumClaimChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimChannel | EnumClaimChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimChannel[] | ListEnumClaimChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimChannelWithAggregatesFilter<$PrismaModel> | $Enums.ClaimChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimChannelFilter<$PrismaModel>
    _max?: NestedEnumClaimChannelFilter<$PrismaModel>
  }

  export type NestedEnumAdmedicaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmedicaStatus | EnumAdmedicaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmedicaStatus[] | ListEnumAdmedicaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmedicaStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmedicaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmedicaStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmedicaStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSource | EnumDocumentSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceFilter<$PrismaModel> | $Enums.DocumentSource
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentSource | EnumDocumentSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentSource[] | ListEnumDocumentSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentSourceWithAggregatesFilter<$PrismaModel> | $Enums.DocumentSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentSourceFilter<$PrismaModel>
    _max?: NestedEnumDocumentSourceFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumColorFilter<$PrismaModel = never> = {
    equals?: $Enums.Color | EnumColorFieldRefInput<$PrismaModel>
    in?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    not?: NestedEnumColorFilter<$PrismaModel> | $Enums.Color
  }

  export type NestedEnumColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Color | EnumColorFieldRefInput<$PrismaModel>
    in?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.Color[] | ListEnumColorFieldRefInput<$PrismaModel>
    not?: NestedEnumColorWithAggregatesFilter<$PrismaModel> | $Enums.Color
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColorFilter<$PrismaModel>
    _max?: NestedEnumColorFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatusType | EnumClaimStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusTypeFilter<$PrismaModel> | $Enums.ClaimStatusType
  }

  export type NestedEnumClaimStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatusType | EnumClaimStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatusType[] | ListEnumClaimStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    order: number
    higherLevelThan?: RoleCreateNestedOneWithoutLowerLevelThanInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    higherLevelThanId?: number | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleUncheckedCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ParticipantCreateWithoutUserInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutUserInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutUserInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
  }

  export type ClaimCreateWithoutInputedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutInputedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutInputedByInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput>
  }

  export type ClaimCreateManyInputedByInputEnvelope = {
    data: ClaimCreateManyInputedByInput | ClaimCreateManyInputedByInput[]
    skipDuplicates?: boolean
  }

  export type ClaimStatusCreateWithoutCreateByInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutCreateByInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutCreateByInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput>
  }

  export type ClaimStatusCreateManyCreateByInputEnvelope = {
    data: ClaimStatusCreateManyCreateByInput | ClaimStatusCreateManyCreateByInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutCreatedByInput = {
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementCreateManyCreatedByInputEnvelope = {
    data: AnnouncementCreateManyCreatedByInput | AnnouncementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThan?: RoleUpdateOneWithoutLowerLevelThanNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThanId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUncheckedUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type ParticipantUpsertWithoutUserInput = {
    update: XOR<ParticipantUpdateWithoutUserInput, ParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ParticipantCreateWithoutUserInput, ParticipantUncheckedCreateWithoutUserInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutUserInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutUserInput, ParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ParticipantUpdateWithoutUserInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutUserInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type ClaimUpsertWithWhereUniqueWithoutInputedByInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutInputedByInput, ClaimUncheckedUpdateWithoutInputedByInput>
    create: XOR<ClaimCreateWithoutInputedByInput, ClaimUncheckedCreateWithoutInputedByInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutInputedByInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutInputedByInput, ClaimUncheckedUpdateWithoutInputedByInput>
  }

  export type ClaimUpdateManyWithWhereWithoutInputedByInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutInputedByInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    channel?: EnumClaimChannelFilter<"Claim"> | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFilter<"Claim"> | $Enums.AdmedicaStatus
    company?: StringFilter<"Claim"> | string
    participantId?: StringFilter<"Claim"> | string
    claimFinancialId?: IntFilter<"Claim"> | number
    claimProcessId?: IntFilter<"Claim"> | number
    diseaseId?: IntNullableFilter<"Claim"> | number | null
    clinicId?: IntFilter<"Claim"> | number
    inputedById?: StringNullableFilter<"Claim"> | string | null
    claimTypeId?: IntFilter<"Claim"> | number
  }

  export type ClaimStatusUpsertWithWhereUniqueWithoutCreateByInput = {
    where: ClaimStatusWhereUniqueInput
    update: XOR<ClaimStatusUpdateWithoutCreateByInput, ClaimStatusUncheckedUpdateWithoutCreateByInput>
    create: XOR<ClaimStatusCreateWithoutCreateByInput, ClaimStatusUncheckedCreateWithoutCreateByInput>
  }

  export type ClaimStatusUpdateWithWhereUniqueWithoutCreateByInput = {
    where: ClaimStatusWhereUniqueInput
    data: XOR<ClaimStatusUpdateWithoutCreateByInput, ClaimStatusUncheckedUpdateWithoutCreateByInput>
  }

  export type ClaimStatusUpdateManyWithWhereWithoutCreateByInput = {
    where: ClaimStatusScalarWhereInput
    data: XOR<ClaimStatusUpdateManyMutationInput, ClaimStatusUncheckedUpdateManyWithoutCreateByInput>
  }

  export type ClaimStatusScalarWhereInput = {
    AND?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
    OR?: ClaimStatusScalarWhereInput[]
    NOT?: ClaimStatusScalarWhereInput | ClaimStatusScalarWhereInput[]
    id?: IntFilter<"ClaimStatus"> | number
    description?: StringNullableFilter<"ClaimStatus"> | string | null
    rejectionReason?: StringNullableFilter<"ClaimStatus"> | string | null
    createdAt?: DateTimeFilter<"ClaimStatus"> | Date | string
    status?: EnumClaimStatusTypeFilter<"ClaimStatus"> | $Enums.ClaimStatusType
    createById?: StringFilter<"ClaimStatus"> | string
    claimId?: StringFilter<"ClaimStatus"> | string
    rejectionLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    guaranteeLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    transactionLetterId?: StringNullableFilter<"ClaimStatus"> | string | null
    bookKeepingOrderId?: StringNullableFilter<"ClaimStatus"> | string | null
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AnnouncementCreateWithoutCreatedByInput, AnnouncementUncheckedCreateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutCreatedByInput, AnnouncementUncheckedUpdateWithoutCreatedByInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutCreatedByInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: IntFilter<"Announcement"> | number
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    imageUrl?: StringNullableFilter<"Announcement"> | string | null
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    createdById?: StringFilter<"Announcement"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    subtitle?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    isRead?: BoolFilter<"Notification"> | boolean
    isCleared?: BoolFilter<"Notification"> | boolean
    deepLink?: StringNullableFilter<"Notification"> | string | null
    fcmToken?: StringNullableFilter<"Notification"> | string | null
    userId?: StringFilter<"Notification"> | string
  }

  export type RoleCreateWithoutLowerLevelThanInput = {
    name: string
    description?: string | null
    order: number
    higherLevelThan?: RoleCreateNestedOneWithoutLowerLevelThanInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutLowerLevelThanInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    higherLevelThanId?: number | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutLowerLevelThanInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutLowerLevelThanInput, RoleUncheckedCreateWithoutLowerLevelThanInput>
  }

  export type RolePermissionCreateWithoutRoleInput = {
    permission: $Enums.Permission
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permission: $Enums.Permission
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutHigherLevelThanInput = {
    name: string
    description?: string | null
    order: number
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleUncheckedCreateWithoutHigherLevelThanInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleUncheckedCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleCreateOrConnectWithoutHigherLevelThanInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput>
  }

  export type RoleCreateManyHigherLevelThanInputEnvelope = {
    data: RoleCreateManyHigherLevelThanInput | RoleCreateManyHigherLevelThanInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutLowerLevelThanInput = {
    update: XOR<RoleUpdateWithoutLowerLevelThanInput, RoleUncheckedUpdateWithoutLowerLevelThanInput>
    create: XOR<RoleCreateWithoutLowerLevelThanInput, RoleUncheckedCreateWithoutLowerLevelThanInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutLowerLevelThanInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutLowerLevelThanInput, RoleUncheckedUpdateWithoutLowerLevelThanInput>
  }

  export type RoleUpdateWithoutLowerLevelThanInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThan?: RoleUpdateOneWithoutLowerLevelThanNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutLowerLevelThanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThanId?: NullableIntFieldUpdateOperationsInput | number | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permission?: EnumPermissionFilter<"RolePermission"> | $Enums.Permission
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringFilter<"User"> | string
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    roleId?: IntFilter<"User"> | number
    participantId?: IntNullableFilter<"User"> | number | null
  }

  export type RoleUpsertWithWhereUniqueWithoutHigherLevelThanInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutHigherLevelThanInput, RoleUncheckedUpdateWithoutHigherLevelThanInput>
    create: XOR<RoleCreateWithoutHigherLevelThanInput, RoleUncheckedCreateWithoutHigherLevelThanInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutHigherLevelThanInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutHigherLevelThanInput, RoleUncheckedUpdateWithoutHigherLevelThanInput>
  }

  export type RoleUpdateManyWithWhereWithoutHigherLevelThanInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutHigherLevelThanInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    order?: IntFilter<"Role"> | number
    higherLevelThanId?: IntNullableFilter<"Role"> | number | null
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    order: number
    higherLevelThan?: RoleCreateNestedOneWithoutLowerLevelThanInput
    users?: UserCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    name: string
    description?: string | null
    order: number
    higherLevelThanId?: number | null
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    lowerLevelThan?: RoleUncheckedCreateNestedManyWithoutHigherLevelThanInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThan?: RoleUpdateOneWithoutLowerLevelThanNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    higherLevelThanId?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUncheckedUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type UserCreateWithoutParticipantInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParticipantInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
  }

  export type ParticipantCreateWithoutParticipantInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutParticipantInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutParticipantInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutParticipantInput, ParticipantUncheckedCreateWithoutParticipantInput>
  }

  export type BankAccountCreateWithoutParticipantInput = {
    accountNumber: number
    accountName: string
  }

  export type BankAccountUncheckedCreateWithoutParticipantInput = {
    id?: number
    accountNumber: number
    accountName: string
  }

  export type BankAccountCreateOrConnectWithoutParticipantInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
  }

  export type ClaimCreateWithoutParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutParticipantInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput>
  }

  export type ClaimCreateManyParticipantInputEnvelope = {
    data: ClaimCreateManyParticipantInput | ClaimCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentCreateWithoutParticipantInput = {
    employmentPosition: $Enums.Position
    branch: BranchCreateNestedOneWithoutEmploymentInput
    group?: GroupCreateNestedOneWithoutEmploymentInput
    region?: RegionCreateNestedOneWithoutEmploymentInput
  }

  export type EmploymentUncheckedCreateWithoutParticipantInput = {
    id?: number
    employmentPosition: $Enums.Position
    branchId: number
    groupId: number
    regionId: number
  }

  export type EmploymentCreateOrConnectWithoutParticipantInput = {
    where: EmploymentWhereUniqueInput
    create: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput>
  }

  export type EmploymentCreateManyParticipantInputEnvelope = {
    data: EmploymentCreateManyParticipantInput | EmploymentCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type ContactInfoCreateWithoutParticipantInput = {
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    address: AddressCreateNestedOneWithoutContactInfoInput
  }

  export type ContactInfoUncheckedCreateWithoutParticipantInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addressId: number
  }

  export type ContactInfoCreateOrConnectWithoutParticipantInput = {
    where: ContactInfoWhereUniqueInput
    create: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput>
  }

  export type ContactInfoCreateManyParticipantInputEnvelope = {
    data: ContactInfoCreateManyParticipantInput | ContactInfoCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type ProgramParticipationCreateWithoutParticipantInput = {
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    funding: AccountCreateNestedOneWithoutProgramParticipationInput
    Program?: ProgramCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateWithoutParticipantInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    fundingId: number
    programId?: number | null
  }

  export type ProgramParticipationCreateOrConnectWithoutParticipantInput = {
    where: ProgramParticipationWhereUniqueInput
    create: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput>
  }

  export type ProgramParticipationCreateManyParticipantInputEnvelope = {
    data: ProgramParticipationCreateManyParticipantInput | ProgramParticipationCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutParticipantInput = {
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    programParticipation?: ProgramParticipationCreateNestedManyWithoutFundingInput
  }

  export type AccountUncheckedCreateWithoutParticipantInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    programParticipation?: ProgramParticipationUncheckedCreateNestedManyWithoutFundingInput
  }

  export type AccountCreateOrConnectWithoutParticipantInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput>
  }

  export type AccountCreateManyParticipantInputEnvelope = {
    data: AccountCreateManyParticipantInput | AccountCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantCreateWithoutRelationInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutRelationInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutRelationInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput>
  }

  export type ParticipantCreateManyRelationInputEnvelope = {
    data: ParticipantCreateManyRelationInput | ParticipantCreateManyRelationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParticipantInput = {
    update: XOR<UserUpdateWithoutParticipantInput, UserUncheckedUpdateWithoutParticipantInput>
    create: XOR<UserCreateWithoutParticipantInput, UserUncheckedCreateWithoutParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParticipantInput, UserUncheckedUpdateWithoutParticipantInput>
  }

  export type UserUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ParticipantUpsertWithoutParticipantInput = {
    update: XOR<ParticipantUpdateWithoutParticipantInput, ParticipantUncheckedUpdateWithoutParticipantInput>
    create: XOR<ParticipantCreateWithoutParticipantInput, ParticipantUncheckedCreateWithoutParticipantInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutParticipantInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutParticipantInput, ParticipantUncheckedUpdateWithoutParticipantInput>
  }

  export type ParticipantUpdateWithoutParticipantInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutParticipantInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type BankAccountUpsertWithoutParticipantInput = {
    update: XOR<BankAccountUpdateWithoutParticipantInput, BankAccountUncheckedUpdateWithoutParticipantInput>
    create: XOR<BankAccountCreateWithoutParticipantInput, BankAccountUncheckedCreateWithoutParticipantInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutParticipantInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutParticipantInput, BankAccountUncheckedUpdateWithoutParticipantInput>
  }

  export type BankAccountUpdateWithoutParticipantInput = {
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
  }

  export type BankAccountUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountNumber?: FloatFieldUpdateOperationsInput | number
    accountName?: StringFieldUpdateOperationsInput | string
  }

  export type ClaimUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutParticipantInput, ClaimUncheckedUpdateWithoutParticipantInput>
    create: XOR<ClaimCreateWithoutParticipantInput, ClaimUncheckedCreateWithoutParticipantInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutParticipantInput, ClaimUncheckedUpdateWithoutParticipantInput>
  }

  export type ClaimUpdateManyWithWhereWithoutParticipantInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutParticipantInput>
  }

  export type EmploymentUpsertWithWhereUniqueWithoutParticipantInput = {
    where: EmploymentWhereUniqueInput
    update: XOR<EmploymentUpdateWithoutParticipantInput, EmploymentUncheckedUpdateWithoutParticipantInput>
    create: XOR<EmploymentCreateWithoutParticipantInput, EmploymentUncheckedCreateWithoutParticipantInput>
  }

  export type EmploymentUpdateWithWhereUniqueWithoutParticipantInput = {
    where: EmploymentWhereUniqueInput
    data: XOR<EmploymentUpdateWithoutParticipantInput, EmploymentUncheckedUpdateWithoutParticipantInput>
  }

  export type EmploymentUpdateManyWithWhereWithoutParticipantInput = {
    where: EmploymentScalarWhereInput
    data: XOR<EmploymentUpdateManyMutationInput, EmploymentUncheckedUpdateManyWithoutParticipantInput>
  }

  export type EmploymentScalarWhereInput = {
    AND?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
    OR?: EmploymentScalarWhereInput[]
    NOT?: EmploymentScalarWhereInput | EmploymentScalarWhereInput[]
    id?: IntFilter<"Employment"> | number
    employmentPosition?: EnumPositionFilter<"Employment"> | $Enums.Position
    participantId?: StringFilter<"Employment"> | string
    branchId?: IntFilter<"Employment"> | number
    groupId?: IntFilter<"Employment"> | number
    regionId?: IntFilter<"Employment"> | number
  }

  export type ContactInfoUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContactInfoWhereUniqueInput
    update: XOR<ContactInfoUpdateWithoutParticipantInput, ContactInfoUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContactInfoCreateWithoutParticipantInput, ContactInfoUncheckedCreateWithoutParticipantInput>
  }

  export type ContactInfoUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContactInfoWhereUniqueInput
    data: XOR<ContactInfoUpdateWithoutParticipantInput, ContactInfoUncheckedUpdateWithoutParticipantInput>
  }

  export type ContactInfoUpdateManyWithWhereWithoutParticipantInput = {
    where: ContactInfoScalarWhereInput
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContactInfoScalarWhereInput = {
    AND?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
    OR?: ContactInfoScalarWhereInput[]
    NOT?: ContactInfoScalarWhereInput | ContactInfoScalarWhereInput[]
    id?: IntFilter<"ContactInfo"> | number
    telp?: StringFilter<"ContactInfo"> | string
    createdAt?: DateTimeFilter<"ContactInfo"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ContactInfo"> | Date | string | null
    participantId?: StringFilter<"ContactInfo"> | string
    addressId?: IntFilter<"ContactInfo"> | number
  }

  export type ProgramParticipationUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ProgramParticipationWhereUniqueInput
    update: XOR<ProgramParticipationUpdateWithoutParticipantInput, ProgramParticipationUncheckedUpdateWithoutParticipantInput>
    create: XOR<ProgramParticipationCreateWithoutParticipantInput, ProgramParticipationUncheckedCreateWithoutParticipantInput>
  }

  export type ProgramParticipationUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ProgramParticipationWhereUniqueInput
    data: XOR<ProgramParticipationUpdateWithoutParticipantInput, ProgramParticipationUncheckedUpdateWithoutParticipantInput>
  }

  export type ProgramParticipationUpdateManyWithWhereWithoutParticipantInput = {
    where: ProgramParticipationScalarWhereInput
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ProgramParticipationScalarWhereInput = {
    AND?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
    OR?: ProgramParticipationScalarWhereInput[]
    NOT?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
    id?: IntFilter<"ProgramParticipation"> | number
    bpjsNumber?: StringNullableFilter<"ProgramParticipation"> | string | null
    nonActiveReason?: StringNullableFilter<"ProgramParticipation"> | string | null
    effectiveDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    nonActiveDate?: DateTimeNullableFilter<"ProgramParticipation"> | Date | string | null
    participantId?: StringFilter<"ProgramParticipation"> | string
    fundingId?: IntFilter<"ProgramParticipation"> | number
    programId?: IntNullableFilter<"ProgramParticipation"> | number | null
  }

  export type AccountUpsertWithWhereUniqueWithoutParticipantInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParticipantInput, AccountUncheckedUpdateWithoutParticipantInput>
    create: XOR<AccountCreateWithoutParticipantInput, AccountUncheckedCreateWithoutParticipantInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParticipantInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParticipantInput, AccountUncheckedUpdateWithoutParticipantInput>
  }

  export type AccountUpdateManyWithWhereWithoutParticipantInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParticipantInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    currentBalance?: FloatFilter<"Account"> | number
    currentBalanceLastUpdate?: DateTimeNullableFilter<"Account"> | Date | string | null
    participantId?: StringFilter<"Account"> | string
  }

  export type ParticipantUpsertWithWhereUniqueWithoutRelationInput = {
    where: ParticipantWhereUniqueInput
    update: XOR<ParticipantUpdateWithoutRelationInput, ParticipantUncheckedUpdateWithoutRelationInput>
    create: XOR<ParticipantCreateWithoutRelationInput, ParticipantUncheckedCreateWithoutRelationInput>
  }

  export type ParticipantUpdateWithWhereUniqueWithoutRelationInput = {
    where: ParticipantWhereUniqueInput
    data: XOR<ParticipantUpdateWithoutRelationInput, ParticipantUncheckedUpdateWithoutRelationInput>
  }

  export type ParticipantUpdateManyWithWhereWithoutRelationInput = {
    where: ParticipantScalarWhereInput
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyWithoutRelationInput>
  }

  export type ParticipantScalarWhereInput = {
    AND?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
    OR?: ParticipantScalarWhereInput[]
    NOT?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
    gender?: EnumGenderFilter<"Participant"> | $Enums.Gender
    birthDate?: DateTimeFilter<"Participant"> | Date | string
    isActive?: BoolFilter<"Participant"> | boolean
    status?: EnumParticipantStatusFilter<"Participant"> | $Enums.ParticipantStatus
    userId?: StringFilter<"Participant"> | string
    relationId?: StringNullableFilter<"Participant"> | string | null
    bankAccountId?: IntFilter<"Participant"> | number
  }

  export type ParticipantCreateWithoutContactInfosInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutContactInfosInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutContactInfosInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutContactInfosInput, ParticipantUncheckedCreateWithoutContactInfosInput>
  }

  export type AddressCreateWithoutContactInfoInput = {
    address: string
    postalCode: string
    city: CityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutContactInfoInput = {
    id?: number
    address: string
    cityId: number
    postalCode: string
  }

  export type AddressCreateOrConnectWithoutContactInfoInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutContactInfoInput, AddressUncheckedCreateWithoutContactInfoInput>
  }

  export type ParticipantUpsertWithoutContactInfosInput = {
    update: XOR<ParticipantUpdateWithoutContactInfosInput, ParticipantUncheckedUpdateWithoutContactInfosInput>
    create: XOR<ParticipantCreateWithoutContactInfosInput, ParticipantUncheckedCreateWithoutContactInfosInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutContactInfosInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutContactInfosInput, ParticipantUncheckedUpdateWithoutContactInfosInput>
  }

  export type ParticipantUpdateWithoutContactInfosInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutContactInfosInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type AddressUpsertWithoutContactInfoInput = {
    update: XOR<AddressUpdateWithoutContactInfoInput, AddressUncheckedUpdateWithoutContactInfoInput>
    create: XOR<AddressCreateWithoutContactInfoInput, AddressUncheckedCreateWithoutContactInfoInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutContactInfoInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutContactInfoInput, AddressUncheckedUpdateWithoutContactInfoInput>
  }

  export type AddressUpdateWithoutContactInfoInput = {
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    city?: CityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutContactInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateWithoutAddressInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateOrConnectWithoutAddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
  }

  export type ContactInfoCreateWithoutAddressInput = {
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutContactInfosInput
  }

  export type ContactInfoUncheckedCreateWithoutAddressInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId: string
  }

  export type ContactInfoCreateOrConnectWithoutAddressInput = {
    where: ContactInfoWhereUniqueInput
    create: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput>
  }

  export type ContactInfoCreateManyAddressInputEnvelope = {
    data: ContactInfoCreateManyAddressInput | ContactInfoCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type CityUpsertWithoutAddressInput = {
    update: XOR<CityUpdateWithoutAddressInput, CityUncheckedUpdateWithoutAddressInput>
    create: XOR<CityCreateWithoutAddressInput, CityUncheckedCreateWithoutAddressInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutAddressInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutAddressInput, CityUncheckedUpdateWithoutAddressInput>
  }

  export type CityUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInfoUpsertWithWhereUniqueWithoutAddressInput = {
    where: ContactInfoWhereUniqueInput
    update: XOR<ContactInfoUpdateWithoutAddressInput, ContactInfoUncheckedUpdateWithoutAddressInput>
    create: XOR<ContactInfoCreateWithoutAddressInput, ContactInfoUncheckedCreateWithoutAddressInput>
  }

  export type ContactInfoUpdateWithWhereUniqueWithoutAddressInput = {
    where: ContactInfoWhereUniqueInput
    data: XOR<ContactInfoUpdateWithoutAddressInput, ContactInfoUncheckedUpdateWithoutAddressInput>
  }

  export type ContactInfoUpdateManyWithWhereWithoutAddressInput = {
    where: ContactInfoScalarWhereInput
    data: XOR<ContactInfoUpdateManyMutationInput, ContactInfoUncheckedUpdateManyWithoutAddressInput>
  }

  export type AddressCreateWithoutCityInput = {
    address: string
    postalCode: string
    ContactInfo?: ContactInfoCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCityInput = {
    id?: number
    address: string
    postalCode: string
    ContactInfo?: ContactInfoUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressCreateManyCityInputEnvelope = {
    data: AddressCreateManyCityInput | AddressCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
    create: XOR<AddressCreateWithoutCityInput, AddressUncheckedCreateWithoutCityInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCityInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCityInput, AddressUncheckedUpdateWithoutCityInput>
  }

  export type AddressUpdateManyWithWhereWithoutCityInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCityInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    address?: StringFilter<"Address"> | string
    cityId?: IntFilter<"Address"> | number
    postalCode?: StringFilter<"Address"> | string
  }

  export type ParticipantCreateWithoutBankAccountInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutBankAccountInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutBankAccountInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutBankAccountInput, ParticipantUncheckedCreateWithoutBankAccountInput>
  }

  export type ParticipantUpsertWithoutBankAccountInput = {
    update: XOR<ParticipantUpdateWithoutBankAccountInput, ParticipantUncheckedUpdateWithoutBankAccountInput>
    create: XOR<ParticipantCreateWithoutBankAccountInput, ParticipantUncheckedCreateWithoutBankAccountInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutBankAccountInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutBankAccountInput, ParticipantUncheckedUpdateWithoutBankAccountInput>
  }

  export type ParticipantUpdateWithoutBankAccountInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutBankAccountInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantCreateWithoutEmploymentsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutEmploymentsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutEmploymentsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutEmploymentsInput, ParticipantUncheckedCreateWithoutEmploymentsInput>
  }

  export type BranchCreateWithoutEmploymentInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claimFinancial?: ClaimFinancialCreateNestedManyWithoutBranchPayeeInput
  }

  export type BranchUncheckedCreateWithoutEmploymentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claimFinancial?: ClaimFinancialUncheckedCreateNestedManyWithoutBranchPayeeInput
  }

  export type BranchCreateOrConnectWithoutEmploymentInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEmploymentInput, BranchUncheckedCreateWithoutEmploymentInput>
  }

  export type GroupCreateWithoutEmploymentInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUncheckedCreateWithoutEmploymentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateOrConnectWithoutEmploymentInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutEmploymentInput, GroupUncheckedCreateWithoutEmploymentInput>
  }

  export type RegionCreateWithoutEmploymentInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionUncheckedCreateWithoutEmploymentInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegionCreateOrConnectWithoutEmploymentInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutEmploymentInput, RegionUncheckedCreateWithoutEmploymentInput>
  }

  export type ParticipantUpsertWithoutEmploymentsInput = {
    update: XOR<ParticipantUpdateWithoutEmploymentsInput, ParticipantUncheckedUpdateWithoutEmploymentsInput>
    create: XOR<ParticipantCreateWithoutEmploymentsInput, ParticipantUncheckedCreateWithoutEmploymentsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutEmploymentsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutEmploymentsInput, ParticipantUncheckedUpdateWithoutEmploymentsInput>
  }

  export type ParticipantUpdateWithoutEmploymentsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutEmploymentsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type BranchUpsertWithoutEmploymentInput = {
    update: XOR<BranchUpdateWithoutEmploymentInput, BranchUncheckedUpdateWithoutEmploymentInput>
    create: XOR<BranchCreateWithoutEmploymentInput, BranchUncheckedCreateWithoutEmploymentInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEmploymentInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEmploymentInput, BranchUncheckedUpdateWithoutEmploymentInput>
  }

  export type BranchUpdateWithoutEmploymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimFinancial?: ClaimFinancialUpdateManyWithoutBranchPayeeNestedInput
  }

  export type BranchUncheckedUpdateWithoutEmploymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimFinancial?: ClaimFinancialUncheckedUpdateManyWithoutBranchPayeeNestedInput
  }

  export type GroupUpsertWithoutEmploymentInput = {
    update: XOR<GroupUpdateWithoutEmploymentInput, GroupUncheckedUpdateWithoutEmploymentInput>
    create: XOR<GroupCreateWithoutEmploymentInput, GroupUncheckedCreateWithoutEmploymentInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutEmploymentInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutEmploymentInput, GroupUncheckedUpdateWithoutEmploymentInput>
  }

  export type GroupUpdateWithoutEmploymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateWithoutEmploymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpsertWithoutEmploymentInput = {
    update: XOR<RegionUpdateWithoutEmploymentInput, RegionUncheckedUpdateWithoutEmploymentInput>
    create: XOR<RegionCreateWithoutEmploymentInput, RegionUncheckedCreateWithoutEmploymentInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutEmploymentInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutEmploymentInput, RegionUncheckedUpdateWithoutEmploymentInput>
  }

  export type RegionUpdateWithoutEmploymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateWithoutEmploymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentCreateWithoutBranchInput = {
    employmentPosition: $Enums.Position
    participant: ParticipantCreateNestedOneWithoutEmploymentsInput
    group?: GroupCreateNestedOneWithoutEmploymentInput
    region?: RegionCreateNestedOneWithoutEmploymentInput
  }

  export type EmploymentUncheckedCreateWithoutBranchInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    groupId: number
    regionId: number
  }

  export type EmploymentCreateOrConnectWithoutBranchInput = {
    where: EmploymentWhereUniqueInput
    create: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput>
  }

  export type EmploymentCreateManyBranchInputEnvelope = {
    data: EmploymentCreateManyBranchInput | EmploymentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ClaimFinancialCreateWithoutBranchPayeeInput = {
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    claim?: ClaimCreateNestedOneWithoutClaimFinancialsInput
    claimStatus: ClaimStatusCreateNestedOneWithoutClaimFinancialInput
  }

  export type ClaimFinancialUncheckedCreateWithoutBranchPayeeInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    claimStatusId: number
    claim?: ClaimUncheckedCreateNestedOneWithoutClaimFinancialsInput
  }

  export type ClaimFinancialCreateOrConnectWithoutBranchPayeeInput = {
    where: ClaimFinancialWhereUniqueInput
    create: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput>
  }

  export type ClaimFinancialCreateManyBranchPayeeInputEnvelope = {
    data: ClaimFinancialCreateManyBranchPayeeInput | ClaimFinancialCreateManyBranchPayeeInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentUpsertWithWhereUniqueWithoutBranchInput = {
    where: EmploymentWhereUniqueInput
    update: XOR<EmploymentUpdateWithoutBranchInput, EmploymentUncheckedUpdateWithoutBranchInput>
    create: XOR<EmploymentCreateWithoutBranchInput, EmploymentUncheckedCreateWithoutBranchInput>
  }

  export type EmploymentUpdateWithWhereUniqueWithoutBranchInput = {
    where: EmploymentWhereUniqueInput
    data: XOR<EmploymentUpdateWithoutBranchInput, EmploymentUncheckedUpdateWithoutBranchInput>
  }

  export type EmploymentUpdateManyWithWhereWithoutBranchInput = {
    where: EmploymentScalarWhereInput
    data: XOR<EmploymentUpdateManyMutationInput, EmploymentUncheckedUpdateManyWithoutBranchInput>
  }

  export type ClaimFinancialUpsertWithWhereUniqueWithoutBranchPayeeInput = {
    where: ClaimFinancialWhereUniqueInput
    update: XOR<ClaimFinancialUpdateWithoutBranchPayeeInput, ClaimFinancialUncheckedUpdateWithoutBranchPayeeInput>
    create: XOR<ClaimFinancialCreateWithoutBranchPayeeInput, ClaimFinancialUncheckedCreateWithoutBranchPayeeInput>
  }

  export type ClaimFinancialUpdateWithWhereUniqueWithoutBranchPayeeInput = {
    where: ClaimFinancialWhereUniqueInput
    data: XOR<ClaimFinancialUpdateWithoutBranchPayeeInput, ClaimFinancialUncheckedUpdateWithoutBranchPayeeInput>
  }

  export type ClaimFinancialUpdateManyWithWhereWithoutBranchPayeeInput = {
    where: ClaimFinancialScalarWhereInput
    data: XOR<ClaimFinancialUpdateManyMutationInput, ClaimFinancialUncheckedUpdateManyWithoutBranchPayeeInput>
  }

  export type ClaimFinancialScalarWhereInput = {
    AND?: ClaimFinancialScalarWhereInput | ClaimFinancialScalarWhereInput[]
    OR?: ClaimFinancialScalarWhereInput[]
    NOT?: ClaimFinancialScalarWhereInput | ClaimFinancialScalarWhereInput[]
    id?: IntFilter<"ClaimFinancial"> | number
    requestedAmount?: FloatFilter<"ClaimFinancial"> | number
    paidAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    rejectedAmount?: FloatNullableFilter<"ClaimFinancial"> | number | null
    transactionProcessDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    transferDate?: DateTimeNullableFilter<"ClaimFinancial"> | Date | string | null
    claimId?: StringFilter<"ClaimFinancial"> | string
    branchId?: IntFilter<"ClaimFinancial"> | number
    claimStatusId?: IntFilter<"ClaimFinancial"> | number
  }

  export type EmploymentCreateWithoutGroupInput = {
    employmentPosition: $Enums.Position
    participant: ParticipantCreateNestedOneWithoutEmploymentsInput
    branch: BranchCreateNestedOneWithoutEmploymentInput
    region?: RegionCreateNestedOneWithoutEmploymentInput
  }

  export type EmploymentUncheckedCreateWithoutGroupInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    regionId: number
  }

  export type EmploymentCreateOrConnectWithoutGroupInput = {
    where: EmploymentWhereUniqueInput
    create: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput>
  }

  export type EmploymentCreateManyGroupInputEnvelope = {
    data: EmploymentCreateManyGroupInput | EmploymentCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentUpsertWithWhereUniqueWithoutGroupInput = {
    where: EmploymentWhereUniqueInput
    update: XOR<EmploymentUpdateWithoutGroupInput, EmploymentUncheckedUpdateWithoutGroupInput>
    create: XOR<EmploymentCreateWithoutGroupInput, EmploymentUncheckedCreateWithoutGroupInput>
  }

  export type EmploymentUpdateWithWhereUniqueWithoutGroupInput = {
    where: EmploymentWhereUniqueInput
    data: XOR<EmploymentUpdateWithoutGroupInput, EmploymentUncheckedUpdateWithoutGroupInput>
  }

  export type EmploymentUpdateManyWithWhereWithoutGroupInput = {
    where: EmploymentScalarWhereInput
    data: XOR<EmploymentUpdateManyMutationInput, EmploymentUncheckedUpdateManyWithoutGroupInput>
  }

  export type EmploymentCreateWithoutRegionInput = {
    employmentPosition: $Enums.Position
    participant: ParticipantCreateNestedOneWithoutEmploymentsInput
    branch: BranchCreateNestedOneWithoutEmploymentInput
    group?: GroupCreateNestedOneWithoutEmploymentInput
  }

  export type EmploymentUncheckedCreateWithoutRegionInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    groupId: number
  }

  export type EmploymentCreateOrConnectWithoutRegionInput = {
    where: EmploymentWhereUniqueInput
    create: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput>
  }

  export type EmploymentCreateManyRegionInputEnvelope = {
    data: EmploymentCreateManyRegionInput | EmploymentCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentUpsertWithWhereUniqueWithoutRegionInput = {
    where: EmploymentWhereUniqueInput
    update: XOR<EmploymentUpdateWithoutRegionInput, EmploymentUncheckedUpdateWithoutRegionInput>
    create: XOR<EmploymentCreateWithoutRegionInput, EmploymentUncheckedCreateWithoutRegionInput>
  }

  export type EmploymentUpdateWithWhereUniqueWithoutRegionInput = {
    where: EmploymentWhereUniqueInput
    data: XOR<EmploymentUpdateWithoutRegionInput, EmploymentUncheckedUpdateWithoutRegionInput>
  }

  export type EmploymentUpdateManyWithWhereWithoutRegionInput = {
    where: EmploymentScalarWhereInput
    data: XOR<EmploymentUpdateManyMutationInput, EmploymentUncheckedUpdateManyWithoutRegionInput>
  }

  export type UserCreateWithoutAnnouncementCreatedInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnouncementCreatedInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnouncementCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementCreatedInput, UserUncheckedCreateWithoutAnnouncementCreatedInput>
  }

  export type UserUpsertWithoutAnnouncementCreatedInput = {
    update: XOR<UserUpdateWithoutAnnouncementCreatedInput, UserUncheckedUpdateWithoutAnnouncementCreatedInput>
    create: XOR<UserCreateWithoutAnnouncementCreatedInput, UserUncheckedCreateWithoutAnnouncementCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementCreatedInput, UserUncheckedUpdateWithoutAnnouncementCreatedInput>
  }

  export type UserUpdateWithoutAnnouncementCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ParticipantCreateWithoutProgramParticipationsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutProgramParticipationsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutProgramParticipationsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutProgramParticipationsInput, ParticipantUncheckedCreateWithoutProgramParticipationsInput>
  }

  export type AccountCreateWithoutProgramParticipationInput = {
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutBalancesInput
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutProgramParticipationInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participantId: string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutProgramParticipationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutProgramParticipationInput, AccountUncheckedCreateWithoutProgramParticipationInput>
  }

  export type ProgramCreateWithoutProgramParticipationsInput = {
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    claimType?: ClaimTypeCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutProgramParticipationsInput = {
    id?: number
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    claimType?: ClaimTypeUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutProgramParticipationsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProgramParticipationsInput, ProgramUncheckedCreateWithoutProgramParticipationsInput>
  }

  export type ParticipantUpsertWithoutProgramParticipationsInput = {
    update: XOR<ParticipantUpdateWithoutProgramParticipationsInput, ParticipantUncheckedUpdateWithoutProgramParticipationsInput>
    create: XOR<ParticipantCreateWithoutProgramParticipationsInput, ParticipantUncheckedCreateWithoutProgramParticipationsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutProgramParticipationsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutProgramParticipationsInput, ParticipantUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type ParticipantUpdateWithoutProgramParticipationsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutProgramParticipationsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type AccountUpsertWithoutProgramParticipationInput = {
    update: XOR<AccountUpdateWithoutProgramParticipationInput, AccountUncheckedUpdateWithoutProgramParticipationInput>
    create: XOR<AccountCreateWithoutProgramParticipationInput, AccountUncheckedCreateWithoutProgramParticipationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutProgramParticipationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutProgramParticipationInput, AccountUncheckedUpdateWithoutProgramParticipationInput>
  }

  export type AccountUpdateWithoutProgramParticipationInput = {
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutBalancesNestedInput
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutProgramParticipationInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProgramUpsertWithoutProgramParticipationsInput = {
    update: XOR<ProgramUpdateWithoutProgramParticipationsInput, ProgramUncheckedUpdateWithoutProgramParticipationsInput>
    create: XOR<ProgramCreateWithoutProgramParticipationsInput, ProgramUncheckedCreateWithoutProgramParticipationsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutProgramParticipationsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutProgramParticipationsInput, ProgramUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type ProgramUpdateWithoutProgramParticipationsInput = {
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    claimType?: ClaimTypeUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutProgramParticipationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    claimType?: ClaimTypeUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramParticipationCreateWithoutProgramInput = {
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutProgramParticipationsInput
    funding: AccountCreateNestedOneWithoutProgramParticipationInput
  }

  export type ProgramParticipationUncheckedCreateWithoutProgramInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    fundingId: number
  }

  export type ProgramParticipationCreateOrConnectWithoutProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    create: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput>
  }

  export type ProgramParticipationCreateManyProgramInputEnvelope = {
    data: ProgramParticipationCreateManyProgramInput | ProgramParticipationCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ClaimTypeCreateWithoutProgramInput = {
    jenis: string
    jenisRI: string
    plan: string
    claimId: number
    claims?: ClaimCreateNestedOneWithoutClaimTypesInput
  }

  export type ClaimTypeUncheckedCreateWithoutProgramInput = {
    id?: number
    jenis: string
    jenisRI: string
    plan: string
    claimId: number
    claims?: ClaimUncheckedCreateNestedOneWithoutClaimTypesInput
  }

  export type ClaimTypeCreateOrConnectWithoutProgramInput = {
    where: ClaimTypeWhereUniqueInput
    create: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput>
  }

  export type ClaimTypeCreateManyProgramInputEnvelope = {
    data: ClaimTypeCreateManyProgramInput | ClaimTypeCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramParticipationUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    update: XOR<ProgramParticipationUpdateWithoutProgramInput, ProgramParticipationUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramParticipationCreateWithoutProgramInput, ProgramParticipationUncheckedCreateWithoutProgramInput>
  }

  export type ProgramParticipationUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    data: XOR<ProgramParticipationUpdateWithoutProgramInput, ProgramParticipationUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramParticipationUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramParticipationScalarWhereInput
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyWithoutProgramInput>
  }

  export type ClaimTypeUpsertWithWhereUniqueWithoutProgramInput = {
    where: ClaimTypeWhereUniqueInput
    update: XOR<ClaimTypeUpdateWithoutProgramInput, ClaimTypeUncheckedUpdateWithoutProgramInput>
    create: XOR<ClaimTypeCreateWithoutProgramInput, ClaimTypeUncheckedCreateWithoutProgramInput>
  }

  export type ClaimTypeUpdateWithWhereUniqueWithoutProgramInput = {
    where: ClaimTypeWhereUniqueInput
    data: XOR<ClaimTypeUpdateWithoutProgramInput, ClaimTypeUncheckedUpdateWithoutProgramInput>
  }

  export type ClaimTypeUpdateManyWithWhereWithoutProgramInput = {
    where: ClaimTypeScalarWhereInput
    data: XOR<ClaimTypeUpdateManyMutationInput, ClaimTypeUncheckedUpdateManyWithoutProgramInput>
  }

  export type ClaimTypeScalarWhereInput = {
    AND?: ClaimTypeScalarWhereInput | ClaimTypeScalarWhereInput[]
    OR?: ClaimTypeScalarWhereInput[]
    NOT?: ClaimTypeScalarWhereInput | ClaimTypeScalarWhereInput[]
    id?: IntFilter<"ClaimType"> | number
    jenis?: StringFilter<"ClaimType"> | string
    jenisRI?: StringFilter<"ClaimType"> | string
    plan?: StringFilter<"ClaimType"> | string
    programId?: IntFilter<"ClaimType"> | number
    claimId?: IntFilter<"ClaimType"> | number
  }

  export type ParticipantCreateWithoutClaimsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    balances?: AccountCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutClaimsInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    balances?: AccountUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutClaimsInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutClaimsInput, ParticipantUncheckedCreateWithoutClaimsInput>
  }

  export type ClaimFinancialCreateWithoutClaimInput = {
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchPayee: BranchCreateNestedOneWithoutClaimFinancialInput
    claimStatus: ClaimStatusCreateNestedOneWithoutClaimFinancialInput
  }

  export type ClaimFinancialUncheckedCreateWithoutClaimInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchId: number
    claimStatusId: number
  }

  export type ClaimFinancialCreateOrConnectWithoutClaimInput = {
    where: ClaimFinancialWhereUniqueInput
    create: XOR<ClaimFinancialCreateWithoutClaimInput, ClaimFinancialUncheckedCreateWithoutClaimInput>
  }

  export type ClaimProcessCreateWithoutClaimInput = {
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    documents?: DocumentCreateNestedManyWithoutClaimProcessInput
  }

  export type ClaimProcessUncheckedCreateWithoutClaimInput = {
    id?: number
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutClaimProcessInput
  }

  export type ClaimProcessCreateOrConnectWithoutClaimInput = {
    where: ClaimProcessWhereUniqueInput
    create: XOR<ClaimProcessCreateWithoutClaimInput, ClaimProcessUncheckedCreateWithoutClaimInput>
  }

  export type DiseaseCreateWithoutClaimsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseUncheckedCreateWithoutClaimsInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiseaseCreateOrConnectWithoutClaimsInput = {
    where: DiseaseWhereUniqueInput
    create: XOR<DiseaseCreateWithoutClaimsInput, DiseaseUncheckedCreateWithoutClaimsInput>
  }

  export type ClinicCreateWithoutClaimsInput = {
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicUncheckedCreateWithoutClaimsInput = {
    id?: number
    code: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicCreateOrConnectWithoutClaimsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutClaimsInput, ClinicUncheckedCreateWithoutClaimsInput>
  }

  export type UserCreateWithoutClaimsInputInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimActions?: ClaimStatusCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClaimsInputInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimActions?: ClaimStatusUncheckedCreateNestedManyWithoutCreateByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClaimsInputInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsInputInput, UserUncheckedCreateWithoutClaimsInputInput>
  }

  export type ClaimTypeCreateWithoutClaimsInput = {
    jenis: string
    jenisRI: string
    plan: string
    claimId: number
    program: ProgramCreateNestedOneWithoutClaimTypeInput
  }

  export type ClaimTypeUncheckedCreateWithoutClaimsInput = {
    id?: number
    jenis: string
    jenisRI: string
    plan: string
    programId: number
    claimId: number
  }

  export type ClaimTypeCreateOrConnectWithoutClaimsInput = {
    where: ClaimTypeWhereUniqueInput
    create: XOR<ClaimTypeCreateWithoutClaimsInput, ClaimTypeUncheckedCreateWithoutClaimsInput>
  }

  export type TagCreateWithoutClaimsInput = {
    name: string
    color: $Enums.Color
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutClaimsInput = {
    id?: number
    name: string
    color: $Enums.Color
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutClaimsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput>
  }

  export type ClaimStatusCreateWithoutClaimInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutClaimInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutClaimInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput>
  }

  export type ClaimStatusCreateManyClaimInputEnvelope = {
    data: ClaimStatusCreateManyClaimInput | ClaimStatusCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantUpsertWithoutClaimsInput = {
    update: XOR<ParticipantUpdateWithoutClaimsInput, ParticipantUncheckedUpdateWithoutClaimsInput>
    create: XOR<ParticipantCreateWithoutClaimsInput, ParticipantUncheckedCreateWithoutClaimsInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutClaimsInput, ParticipantUncheckedUpdateWithoutClaimsInput>
  }

  export type ParticipantUpdateWithoutClaimsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutClaimsInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type ClaimFinancialUpsertWithoutClaimInput = {
    update: XOR<ClaimFinancialUpdateWithoutClaimInput, ClaimFinancialUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimFinancialCreateWithoutClaimInput, ClaimFinancialUncheckedCreateWithoutClaimInput>
    where?: ClaimFinancialWhereInput
  }

  export type ClaimFinancialUpdateToOneWithWhereWithoutClaimInput = {
    where?: ClaimFinancialWhereInput
    data: XOR<ClaimFinancialUpdateWithoutClaimInput, ClaimFinancialUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimFinancialUpdateWithoutClaimInput = {
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchPayee?: BranchUpdateOneRequiredWithoutClaimFinancialNestedInput
    claimStatus?: ClaimStatusUpdateOneRequiredWithoutClaimFinancialNestedInput
  }

  export type ClaimFinancialUncheckedUpdateWithoutClaimInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    claimStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimProcessUpsertWithoutClaimInput = {
    update: XOR<ClaimProcessUpdateWithoutClaimInput, ClaimProcessUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimProcessCreateWithoutClaimInput, ClaimProcessUncheckedCreateWithoutClaimInput>
    where?: ClaimProcessWhereInput
  }

  export type ClaimProcessUpdateToOneWithWhereWithoutClaimInput = {
    where?: ClaimProcessWhereInput
    data: XOR<ClaimProcessUpdateWithoutClaimInput, ClaimProcessUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimProcessUpdateWithoutClaimInput = {
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUpdateManyWithoutClaimProcessNestedInput
  }

  export type ClaimProcessUncheckedUpdateWithoutClaimInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutClaimProcessNestedInput
  }

  export type DiseaseUpsertWithoutClaimsInput = {
    update: XOR<DiseaseUpdateWithoutClaimsInput, DiseaseUncheckedUpdateWithoutClaimsInput>
    create: XOR<DiseaseCreateWithoutClaimsInput, DiseaseUncheckedCreateWithoutClaimsInput>
    where?: DiseaseWhereInput
  }

  export type DiseaseUpdateToOneWithWhereWithoutClaimsInput = {
    where?: DiseaseWhereInput
    data: XOR<DiseaseUpdateWithoutClaimsInput, DiseaseUncheckedUpdateWithoutClaimsInput>
  }

  export type DiseaseUpdateWithoutClaimsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiseaseUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUpsertWithoutClaimsInput = {
    update: XOR<ClinicUpdateWithoutClaimsInput, ClinicUncheckedUpdateWithoutClaimsInput>
    create: XOR<ClinicCreateWithoutClaimsInput, ClinicUncheckedCreateWithoutClaimsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutClaimsInput, ClinicUncheckedUpdateWithoutClaimsInput>
  }

  export type ClinicUpdateWithoutClaimsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClaimsInputInput = {
    update: XOR<UserUpdateWithoutClaimsInputInput, UserUncheckedUpdateWithoutClaimsInputInput>
    create: XOR<UserCreateWithoutClaimsInputInput, UserUncheckedCreateWithoutClaimsInputInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsInputInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsInputInput, UserUncheckedUpdateWithoutClaimsInputInput>
  }

  export type UserUpdateWithoutClaimsInputInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimsInputInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClaimTypeUpsertWithoutClaimsInput = {
    update: XOR<ClaimTypeUpdateWithoutClaimsInput, ClaimTypeUncheckedUpdateWithoutClaimsInput>
    create: XOR<ClaimTypeCreateWithoutClaimsInput, ClaimTypeUncheckedCreateWithoutClaimsInput>
    where?: ClaimTypeWhereInput
  }

  export type ClaimTypeUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ClaimTypeWhereInput
    data: XOR<ClaimTypeUpdateWithoutClaimsInput, ClaimTypeUncheckedUpdateWithoutClaimsInput>
  }

  export type ClaimTypeUpdateWithoutClaimsInput = {
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
    program?: ProgramUpdateOneRequiredWithoutClaimTypeNestedInput
  }

  export type ClaimTypeUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    claimId?: IntFieldUpdateOperationsInput | number
  }

  export type TagUpsertWithWhereUniqueWithoutClaimsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutClaimsInput, TagUncheckedUpdateWithoutClaimsInput>
    create: XOR<TagCreateWithoutClaimsInput, TagUncheckedCreateWithoutClaimsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutClaimsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutClaimsInput, TagUncheckedUpdateWithoutClaimsInput>
  }

  export type TagUpdateManyWithWhereWithoutClaimsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutClaimsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    color?: EnumColorFilter<"Tag"> | $Enums.Color
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type ClaimStatusUpsertWithWhereUniqueWithoutClaimInput = {
    where: ClaimStatusWhereUniqueInput
    update: XOR<ClaimStatusUpdateWithoutClaimInput, ClaimStatusUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimStatusCreateWithoutClaimInput, ClaimStatusUncheckedCreateWithoutClaimInput>
  }

  export type ClaimStatusUpdateWithWhereUniqueWithoutClaimInput = {
    where: ClaimStatusWhereUniqueInput
    data: XOR<ClaimStatusUpdateWithoutClaimInput, ClaimStatusUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimStatusUpdateManyWithWhereWithoutClaimInput = {
    where: ClaimStatusScalarWhereInput
    data: XOR<ClaimStatusUpdateManyMutationInput, ClaimStatusUncheckedUpdateManyWithoutClaimInput>
  }

  export type ClaimStatusCreateWithoutRejectionLetterInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutRejectionLetterInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutRejectionLetterInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
  }

  export type ClaimStatusCreateWithoutGuaranteeLetterInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutGuaranteeLetterInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
  }

  export type ClaimStatusCreateWithoutTransactionLetterInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutTransactionLetterInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    bookKeepingOrderId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutTransactionLetterInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
  }

  export type ClaimStatusCreateWithoutBookKeepingOrderInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    claimFinancial?: ClaimFinancialCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    claimFinancial?: ClaimFinancialUncheckedCreateNestedOneWithoutClaimStatusInput
  }

  export type ClaimStatusCreateOrConnectWithoutBookKeepingOrderInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
  }

  export type ClaimProcessCreateWithoutDocumentsInput = {
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    claim?: ClaimCreateNestedOneWithoutClaimProcessesInput
  }

  export type ClaimProcessUncheckedCreateWithoutDocumentsInput = {
    id?: number
    startTreatment?: Date | string | null
    endTreatment?: Date | string | null
    expeditionDate?: Date | string | null
    reclaim?: string | null
    processDate?: Date | string | null
    submissionNote: string
    description: string
    additionalNote: string
    claimId: string
    claim?: ClaimUncheckedCreateNestedOneWithoutClaimProcessesInput
  }

  export type ClaimProcessCreateOrConnectWithoutDocumentsInput = {
    where: ClaimProcessWhereUniqueInput
    create: XOR<ClaimProcessCreateWithoutDocumentsInput, ClaimProcessUncheckedCreateWithoutDocumentsInput>
  }

  export type ClaimStatusUpsertWithoutRejectionLetterInput = {
    update: XOR<ClaimStatusUpdateWithoutRejectionLetterInput, ClaimStatusUncheckedUpdateWithoutRejectionLetterInput>
    create: XOR<ClaimStatusCreateWithoutRejectionLetterInput, ClaimStatusUncheckedCreateWithoutRejectionLetterInput>
    where?: ClaimStatusWhereInput
  }

  export type ClaimStatusUpdateToOneWithWhereWithoutRejectionLetterInput = {
    where?: ClaimStatusWhereInput
    data: XOR<ClaimStatusUpdateWithoutRejectionLetterInput, ClaimStatusUncheckedUpdateWithoutRejectionLetterInput>
  }

  export type ClaimStatusUpdateWithoutRejectionLetterInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutRejectionLetterInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUpsertWithoutGuaranteeLetterInput = {
    update: XOR<ClaimStatusUpdateWithoutGuaranteeLetterInput, ClaimStatusUncheckedUpdateWithoutGuaranteeLetterInput>
    create: XOR<ClaimStatusCreateWithoutGuaranteeLetterInput, ClaimStatusUncheckedCreateWithoutGuaranteeLetterInput>
    where?: ClaimStatusWhereInput
  }

  export type ClaimStatusUpdateToOneWithWhereWithoutGuaranteeLetterInput = {
    where?: ClaimStatusWhereInput
    data: XOR<ClaimStatusUpdateWithoutGuaranteeLetterInput, ClaimStatusUncheckedUpdateWithoutGuaranteeLetterInput>
  }

  export type ClaimStatusUpdateWithoutGuaranteeLetterInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutGuaranteeLetterInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUpsertWithoutTransactionLetterInput = {
    update: XOR<ClaimStatusUpdateWithoutTransactionLetterInput, ClaimStatusUncheckedUpdateWithoutTransactionLetterInput>
    create: XOR<ClaimStatusCreateWithoutTransactionLetterInput, ClaimStatusUncheckedCreateWithoutTransactionLetterInput>
    where?: ClaimStatusWhereInput
  }

  export type ClaimStatusUpdateToOneWithWhereWithoutTransactionLetterInput = {
    where?: ClaimStatusWhereInput
    data: XOR<ClaimStatusUpdateWithoutTransactionLetterInput, ClaimStatusUncheckedUpdateWithoutTransactionLetterInput>
  }

  export type ClaimStatusUpdateWithoutTransactionLetterInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutTransactionLetterInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUpsertWithoutBookKeepingOrderInput = {
    update: XOR<ClaimStatusUpdateWithoutBookKeepingOrderInput, ClaimStatusUncheckedUpdateWithoutBookKeepingOrderInput>
    create: XOR<ClaimStatusCreateWithoutBookKeepingOrderInput, ClaimStatusUncheckedCreateWithoutBookKeepingOrderInput>
    where?: ClaimStatusWhereInput
  }

  export type ClaimStatusUpdateToOneWithWhereWithoutBookKeepingOrderInput = {
    where?: ClaimStatusWhereInput
    data: XOR<ClaimStatusUpdateWithoutBookKeepingOrderInput, ClaimStatusUncheckedUpdateWithoutBookKeepingOrderInput>
  }

  export type ClaimStatusUpdateWithoutBookKeepingOrderInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutBookKeepingOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimProcessUpsertWithoutDocumentsInput = {
    update: XOR<ClaimProcessUpdateWithoutDocumentsInput, ClaimProcessUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClaimProcessCreateWithoutDocumentsInput, ClaimProcessUncheckedCreateWithoutDocumentsInput>
    where?: ClaimProcessWhereInput
  }

  export type ClaimProcessUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClaimProcessWhereInput
    data: XOR<ClaimProcessUpdateWithoutDocumentsInput, ClaimProcessUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClaimProcessUpdateWithoutDocumentsInput = {
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneWithoutClaimProcessesNestedInput
  }

  export type ClaimProcessUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTreatment?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expeditionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reclaim?: NullableStringFieldUpdateOperationsInput | string | null
    processDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionNote?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    additionalNote?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUncheckedUpdateOneWithoutClaimProcessesNestedInput
  }

  export type ClaimCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutTagsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutTagsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutTagsInput, ClaimUncheckedUpdateWithoutTagsInput>
    create: XOR<ClaimCreateWithoutTagsInput, ClaimUncheckedCreateWithoutTagsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutTagsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutTagsInput, ClaimUncheckedUpdateWithoutTagsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutTagsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutTagsInput>
  }

  export type ProgramCreateWithoutClaimTypeInput = {
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    programParticipations?: ProgramParticipationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutClaimTypeInput = {
    id?: number
    plan: $Enums.ApplicationType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    allowanceCeiling: number
    class: $Enums.Class
    maxAllowance: number
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutClaimTypeInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutClaimTypeInput, ProgramUncheckedCreateWithoutClaimTypeInput>
  }

  export type ClaimCreateWithoutClaimTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClaimTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClaimTypesInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
  }

  export type ProgramUpsertWithoutClaimTypeInput = {
    update: XOR<ProgramUpdateWithoutClaimTypeInput, ProgramUncheckedUpdateWithoutClaimTypeInput>
    create: XOR<ProgramCreateWithoutClaimTypeInput, ProgramUncheckedCreateWithoutClaimTypeInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutClaimTypeInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutClaimTypeInput, ProgramUncheckedUpdateWithoutClaimTypeInput>
  }

  export type ProgramUpdateWithoutClaimTypeInput = {
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    programParticipations?: ProgramParticipationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutClaimTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowanceCeiling?: FloatFieldUpdateOperationsInput | number
    class?: EnumClassFieldUpdateOperationsInput | $Enums.Class
    maxAllowance?: FloatFieldUpdateOperationsInput | number
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ClaimUpsertWithoutClaimTypesInput = {
    update: XOR<ClaimUpdateWithoutClaimTypesInput, ClaimUncheckedUpdateWithoutClaimTypesInput>
    create: XOR<ClaimCreateWithoutClaimTypesInput, ClaimUncheckedCreateWithoutClaimTypesInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutClaimTypesInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutClaimTypesInput, ClaimUncheckedUpdateWithoutClaimTypesInput>
  }

  export type ClaimUpdateWithoutClaimTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type BranchCreateWithoutClaimFinancialInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutClaimFinancialInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employment?: EmploymentUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutClaimFinancialInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutClaimFinancialInput, BranchUncheckedCreateWithoutClaimFinancialInput>
  }

  export type ClaimCreateWithoutClaimFinancialsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClaimFinancialsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClaimFinancialsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
  }

  export type ClaimStatusCreateWithoutClaimFinancialInput = {
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createBy: UserCreateNestedOneWithoutClaimActionsInput
    claim: ClaimCreateNestedOneWithoutClaimStatusesInput
    rejectionLetter?: DocumentCreateNestedOneWithoutRejectionLetterOfInput
    guaranteeLetter?: DocumentCreateNestedOneWithoutGuaranteeLetterOfInput
    transactionLetter?: DocumentCreateNestedOneWithoutTransactionLetterOfInput
    bookKeepingOrder?: DocumentCreateNestedOneWithoutBookKeepingOrderOfInput
  }

  export type ClaimStatusUncheckedCreateWithoutClaimFinancialInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
  }

  export type ClaimStatusCreateOrConnectWithoutClaimFinancialInput = {
    where: ClaimStatusWhereUniqueInput
    create: XOR<ClaimStatusCreateWithoutClaimFinancialInput, ClaimStatusUncheckedCreateWithoutClaimFinancialInput>
  }

  export type BranchUpsertWithoutClaimFinancialInput = {
    update: XOR<BranchUpdateWithoutClaimFinancialInput, BranchUncheckedUpdateWithoutClaimFinancialInput>
    create: XOR<BranchCreateWithoutClaimFinancialInput, BranchUncheckedCreateWithoutClaimFinancialInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutClaimFinancialInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutClaimFinancialInput, BranchUncheckedUpdateWithoutClaimFinancialInput>
  }

  export type BranchUpdateWithoutClaimFinancialInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutClaimFinancialInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employment?: EmploymentUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ClaimUpsertWithoutClaimFinancialsInput = {
    update: XOR<ClaimUpdateWithoutClaimFinancialsInput, ClaimUncheckedUpdateWithoutClaimFinancialsInput>
    create: XOR<ClaimCreateWithoutClaimFinancialsInput, ClaimUncheckedCreateWithoutClaimFinancialsInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutClaimFinancialsInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutClaimFinancialsInput, ClaimUncheckedUpdateWithoutClaimFinancialsInput>
  }

  export type ClaimUpdateWithoutClaimFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimFinancialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimStatusUpsertWithoutClaimFinancialInput = {
    update: XOR<ClaimStatusUpdateWithoutClaimFinancialInput, ClaimStatusUncheckedUpdateWithoutClaimFinancialInput>
    create: XOR<ClaimStatusCreateWithoutClaimFinancialInput, ClaimStatusUncheckedCreateWithoutClaimFinancialInput>
    where?: ClaimStatusWhereInput
  }

  export type ClaimStatusUpdateToOneWithWhereWithoutClaimFinancialInput = {
    where?: ClaimStatusWhereInput
    data: XOR<ClaimStatusUpdateWithoutClaimFinancialInput, ClaimStatusUncheckedUpdateWithoutClaimFinancialInput>
  }

  export type ClaimStatusUpdateWithoutClaimFinancialInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutClaimFinancialInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimCreateWithoutClaimProcessesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClaimProcessesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClaimProcessesInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
  }

  export type DocumentCreateWithoutClaimProcessInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentUncheckedCreateWithoutClaimProcessInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentCreateOrConnectWithoutClaimProcessInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput>
  }

  export type DocumentCreateManyClaimProcessInputEnvelope = {
    data: DocumentCreateManyClaimProcessInput | DocumentCreateManyClaimProcessInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithoutClaimProcessesInput = {
    update: XOR<ClaimUpdateWithoutClaimProcessesInput, ClaimUncheckedUpdateWithoutClaimProcessesInput>
    create: XOR<ClaimCreateWithoutClaimProcessesInput, ClaimUncheckedCreateWithoutClaimProcessesInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutClaimProcessesInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutClaimProcessesInput, ClaimUncheckedUpdateWithoutClaimProcessesInput>
  }

  export type ClaimUpdateWithoutClaimProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimProcessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutClaimProcessInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClaimProcessInput, DocumentUncheckedUpdateWithoutClaimProcessInput>
    create: XOR<DocumentCreateWithoutClaimProcessInput, DocumentUncheckedCreateWithoutClaimProcessInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClaimProcessInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClaimProcessInput, DocumentUncheckedUpdateWithoutClaimProcessInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClaimProcessInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClaimProcessInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    name?: StringFilter<"Document"> | string
    path?: StringFilter<"Document"> | string
    size?: IntFilter<"Document"> | number
    printCount?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    source?: EnumDocumentSourceFilter<"Document"> | $Enums.DocumentSource
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    claimProcessId?: IntNullableFilter<"Document"> | number | null
  }

  export type UserCreateWithoutClaimActionsInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
    role: RoleCreateNestedOneWithoutUsersInput
    participant?: ParticipantCreateNestedOneWithoutUserInput
    claimsInput?: ClaimCreateNestedManyWithoutInputedByInput
    announcementCreated?: AnnouncementCreateNestedManyWithoutCreatedByInput
    notification?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClaimActionsInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roleId: number
    participantId?: number | null
    participant?: ParticipantUncheckedCreateNestedOneWithoutUserInput
    claimsInput?: ClaimUncheckedCreateNestedManyWithoutInputedByInput
    announcementCreated?: AnnouncementUncheckedCreateNestedManyWithoutCreatedByInput
    notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClaimActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimActionsInput, UserUncheckedCreateWithoutClaimActionsInput>
  }

  export type ClaimCreateWithoutClaimStatusesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
  }

  export type ClaimUncheckedCreateWithoutClaimStatusesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
  }

  export type ClaimCreateOrConnectWithoutClaimStatusesInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClaimStatusesInput, ClaimUncheckedCreateWithoutClaimStatusesInput>
  }

  export type DocumentCreateWithoutRejectionLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    guaranteeLetterOf?: ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput
    claimProcess?: ClaimProcessCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutRejectionLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
    guaranteeLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentCreateOrConnectWithoutRejectionLetterOfInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRejectionLetterOfInput, DocumentUncheckedCreateWithoutRejectionLetterOfInput>
  }

  export type DocumentCreateWithoutGuaranteeLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusCreateNestedOneWithoutRejectionLetterInput
    transactionLetterOf?: ClaimStatusCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput
    claimProcess?: ClaimProcessCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutGuaranteeLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
    rejectionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput
    transactionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput
    bookKeepingOrderOf?: ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentCreateOrConnectWithoutGuaranteeLetterOfInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutGuaranteeLetterOfInput, DocumentUncheckedCreateWithoutGuaranteeLetterOfInput>
  }

  export type DocumentCreateWithoutTransactionLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput
    bookKeepingOrderOf?: ClaimStatusCreateNestedOneWithoutBookKeepingOrderInput
    claimProcess?: ClaimProcessCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutTransactionLetterOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
    rejectionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput
    bookKeepingOrderOf?: ClaimStatusUncheckedCreateNestedOneWithoutBookKeepingOrderInput
  }

  export type DocumentCreateOrConnectWithoutTransactionLetterOfInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutTransactionLetterOfInput, DocumentUncheckedCreateWithoutTransactionLetterOfInput>
  }

  export type DocumentCreateWithoutBookKeepingOrderOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusCreateNestedOneWithoutTransactionLetterInput
    claimProcess?: ClaimProcessCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutBookKeepingOrderOfInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
    claimProcessId?: number | null
    rejectionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutRejectionLetterInput
    guaranteeLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutGuaranteeLetterInput
    transactionLetterOf?: ClaimStatusUncheckedCreateNestedOneWithoutTransactionLetterInput
  }

  export type DocumentCreateOrConnectWithoutBookKeepingOrderOfInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutBookKeepingOrderOfInput, DocumentUncheckedCreateWithoutBookKeepingOrderOfInput>
  }

  export type ClaimFinancialCreateWithoutClaimStatusInput = {
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchPayee: BranchCreateNestedOneWithoutClaimFinancialInput
    claim?: ClaimCreateNestedOneWithoutClaimFinancialsInput
  }

  export type ClaimFinancialUncheckedCreateWithoutClaimStatusInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    branchId: number
    claim?: ClaimUncheckedCreateNestedOneWithoutClaimFinancialsInput
  }

  export type ClaimFinancialCreateOrConnectWithoutClaimStatusInput = {
    where: ClaimFinancialWhereUniqueInput
    create: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
  }

  export type UserUpsertWithoutClaimActionsInput = {
    update: XOR<UserUpdateWithoutClaimActionsInput, UserUncheckedUpdateWithoutClaimActionsInput>
    create: XOR<UserCreateWithoutClaimActionsInput, UserUncheckedCreateWithoutClaimActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimActionsInput, UserUncheckedUpdateWithoutClaimActionsInput>
  }

  export type UserUpdateWithoutClaimActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClaimUpsertWithoutClaimStatusesInput = {
    update: XOR<ClaimUpdateWithoutClaimStatusesInput, ClaimUncheckedUpdateWithoutClaimStatusesInput>
    create: XOR<ClaimCreateWithoutClaimStatusesInput, ClaimUncheckedCreateWithoutClaimStatusesInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutClaimStatusesInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutClaimStatusesInput, ClaimUncheckedUpdateWithoutClaimStatusesInput>
  }

  export type ClaimUpdateWithoutClaimStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClaimStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
  }

  export type DocumentUpsertWithoutRejectionLetterOfInput = {
    update: XOR<DocumentUpdateWithoutRejectionLetterOfInput, DocumentUncheckedUpdateWithoutRejectionLetterOfInput>
    create: XOR<DocumentCreateWithoutRejectionLetterOfInput, DocumentUncheckedCreateWithoutRejectionLetterOfInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutRejectionLetterOfInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutRejectionLetterOfInput, DocumentUncheckedUpdateWithoutRejectionLetterOfInput>
  }

  export type DocumentUpdateWithoutRejectionLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    guaranteeLetterOf?: ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput
    claimProcess?: ClaimProcessUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRejectionLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
    guaranteeLetterOf?: ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentUpsertWithoutGuaranteeLetterOfInput = {
    update: XOR<DocumentUpdateWithoutGuaranteeLetterOfInput, DocumentUncheckedUpdateWithoutGuaranteeLetterOfInput>
    create: XOR<DocumentCreateWithoutGuaranteeLetterOfInput, DocumentUncheckedCreateWithoutGuaranteeLetterOfInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutGuaranteeLetterOfInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutGuaranteeLetterOfInput, DocumentUncheckedUpdateWithoutGuaranteeLetterOfInput>
  }

  export type DocumentUpdateWithoutGuaranteeLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUpdateOneWithoutRejectionLetterNestedInput
    transactionLetterOf?: ClaimStatusUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput
    claimProcess?: ClaimProcessUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutGuaranteeLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput
    transactionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentUpsertWithoutTransactionLetterOfInput = {
    update: XOR<DocumentUpdateWithoutTransactionLetterOfInput, DocumentUncheckedUpdateWithoutTransactionLetterOfInput>
    create: XOR<DocumentCreateWithoutTransactionLetterOfInput, DocumentUncheckedCreateWithoutTransactionLetterOfInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutTransactionLetterOfInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutTransactionLetterOfInput, DocumentUncheckedUpdateWithoutTransactionLetterOfInput>
  }

  export type DocumentUpdateWithoutTransactionLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput
    claimProcess?: ClaimProcessUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutTransactionLetterOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentUpsertWithoutBookKeepingOrderOfInput = {
    update: XOR<DocumentUpdateWithoutBookKeepingOrderOfInput, DocumentUncheckedUpdateWithoutBookKeepingOrderOfInput>
    create: XOR<DocumentCreateWithoutBookKeepingOrderOfInput, DocumentUncheckedCreateWithoutBookKeepingOrderOfInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutBookKeepingOrderOfInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutBookKeepingOrderOfInput, DocumentUncheckedUpdateWithoutBookKeepingOrderOfInput>
  }

  export type DocumentUpdateWithoutBookKeepingOrderOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUpdateOneWithoutTransactionLetterNestedInput
    claimProcess?: ClaimProcessUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutBookKeepingOrderOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    claimProcessId?: NullableIntFieldUpdateOperationsInput | number | null
    rejectionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput
  }

  export type ClaimFinancialUpsertWithoutClaimStatusInput = {
    update: XOR<ClaimFinancialUpdateWithoutClaimStatusInput, ClaimFinancialUncheckedUpdateWithoutClaimStatusInput>
    create: XOR<ClaimFinancialCreateWithoutClaimStatusInput, ClaimFinancialUncheckedCreateWithoutClaimStatusInput>
    where?: ClaimFinancialWhereInput
  }

  export type ClaimFinancialUpdateToOneWithWhereWithoutClaimStatusInput = {
    where?: ClaimFinancialWhereInput
    data: XOR<ClaimFinancialUpdateWithoutClaimStatusInput, ClaimFinancialUncheckedUpdateWithoutClaimStatusInput>
  }

  export type ClaimFinancialUpdateWithoutClaimStatusInput = {
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchPayee?: BranchUpdateOneRequiredWithoutClaimFinancialNestedInput
    claim?: ClaimUpdateOneWithoutClaimFinancialsNestedInput
  }

  export type ClaimFinancialUncheckedUpdateWithoutClaimStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    claim?: ClaimUncheckedUpdateOneWithoutClaimFinancialsNestedInput
  }

  export type ClaimCreateWithoutDiseaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    clinics: ClinicCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutDiseaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutDiseaseInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput>
  }

  export type ClaimCreateManyDiseaseInputEnvelope = {
    data: ClaimCreateManyDiseaseInput | ClaimCreateManyDiseaseInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithWhereUniqueWithoutDiseaseInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutDiseaseInput, ClaimUncheckedUpdateWithoutDiseaseInput>
    create: XOR<ClaimCreateWithoutDiseaseInput, ClaimUncheckedCreateWithoutDiseaseInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutDiseaseInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutDiseaseInput, ClaimUncheckedUpdateWithoutDiseaseInput>
  }

  export type ClaimUpdateManyWithWhereWithoutDiseaseInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutDiseaseInput>
  }

  export type ClaimCreateWithoutClinicsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participant: ParticipantCreateNestedOneWithoutClaimsInput
    claimFinancials: ClaimFinancialCreateNestedOneWithoutClaimInput
    claimProcesses: ClaimProcessCreateNestedOneWithoutClaimInput
    disease?: DiseaseCreateNestedOneWithoutClaimsInput
    inputedBy?: UserCreateNestedOneWithoutClaimsInputInput
    claimTypes: ClaimTypeCreateNestedOneWithoutClaimsInput
    tags?: TagCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutClinicsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    inputedById?: string | null
    claimTypeId: number
    tags?: TagUncheckedCreateNestedManyWithoutClaimsInput
    claimStatuses?: ClaimStatusUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutClinicsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput>
  }

  export type ClaimCreateManyClinicsInputEnvelope = {
    data: ClaimCreateManyClinicsInput | ClaimCreateManyClinicsInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithWhereUniqueWithoutClinicsInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutClinicsInput, ClaimUncheckedUpdateWithoutClinicsInput>
    create: XOR<ClaimCreateWithoutClinicsInput, ClaimUncheckedCreateWithoutClinicsInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutClinicsInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutClinicsInput, ClaimUncheckedUpdateWithoutClinicsInput>
  }

  export type ClaimUpdateManyWithWhereWithoutClinicsInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutClinicsInput>
  }

  export type ParticipantCreateWithoutBalancesInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    bankAccountId: number
    user: UserCreateNestedOneWithoutParticipantInput
    relation?: ParticipantCreateNestedOneWithoutParticipantInput
    bankAccount?: BankAccountCreateNestedOneWithoutParticipantInput
    claims?: ClaimCreateNestedManyWithoutParticipantInput
    employments?: EmploymentCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantCreateNestedManyWithoutRelationInput
  }

  export type ParticipantUncheckedCreateWithoutBalancesInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    relationId?: string | null
    bankAccountId: number
    bankAccount?: BankAccountUncheckedCreateNestedOneWithoutParticipantInput
    claims?: ClaimUncheckedCreateNestedManyWithoutParticipantInput
    employments?: EmploymentUncheckedCreateNestedManyWithoutParticipantInput
    contactInfos?: ContactInfoUncheckedCreateNestedManyWithoutParticipantInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutParticipantInput
    Participant?: ParticipantUncheckedCreateNestedManyWithoutRelationInput
  }

  export type ParticipantCreateOrConnectWithoutBalancesInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutBalancesInput, ParticipantUncheckedCreateWithoutBalancesInput>
  }

  export type TransactionCreateWithoutAccountInput = {
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: number
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ProgramParticipationCreateWithoutFundingInput = {
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutProgramParticipationsInput
    Program?: ProgramCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateWithoutFundingInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    programId?: number | null
  }

  export type ProgramParticipationCreateOrConnectWithoutFundingInput = {
    where: ProgramParticipationWhereUniqueInput
    create: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput>
  }

  export type ProgramParticipationCreateManyFundingInputEnvelope = {
    data: ProgramParticipationCreateManyFundingInput | ProgramParticipationCreateManyFundingInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantUpsertWithoutBalancesInput = {
    update: XOR<ParticipantUpdateWithoutBalancesInput, ParticipantUncheckedUpdateWithoutBalancesInput>
    create: XOR<ParticipantCreateWithoutBalancesInput, ParticipantUncheckedCreateWithoutBalancesInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutBalancesInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutBalancesInput, ParticipantUncheckedUpdateWithoutBalancesInput>
  }

  export type ParticipantUpdateWithoutBalancesInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    relation?: ParticipantUpdateOneWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutBalancesInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    relationId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    amount?: FloatFilter<"Transaction"> | number
    transactionType?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    accountId?: IntFilter<"Transaction"> | number
  }

  export type ProgramParticipationUpsertWithWhereUniqueWithoutFundingInput = {
    where: ProgramParticipationWhereUniqueInput
    update: XOR<ProgramParticipationUpdateWithoutFundingInput, ProgramParticipationUncheckedUpdateWithoutFundingInput>
    create: XOR<ProgramParticipationCreateWithoutFundingInput, ProgramParticipationUncheckedCreateWithoutFundingInput>
  }

  export type ProgramParticipationUpdateWithWhereUniqueWithoutFundingInput = {
    where: ProgramParticipationWhereUniqueInput
    data: XOR<ProgramParticipationUpdateWithoutFundingInput, ProgramParticipationUncheckedUpdateWithoutFundingInput>
  }

  export type ProgramParticipationUpdateManyWithWhereWithoutFundingInput = {
    where: ProgramParticipationScalarWhereInput
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyWithoutFundingInput>
  }

  export type AccountCreateWithoutTransactionsInput = {
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participant: ParticipantCreateNestedOneWithoutBalancesInput
    programParticipation?: ProgramParticipationCreateNestedManyWithoutFundingInput
  }

  export type AccountUncheckedCreateWithoutTransactionsInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
    participantId: string
    programParticipation?: ProgramParticipationUncheckedCreateNestedManyWithoutFundingInput
  }

  export type AccountCreateOrConnectWithoutTransactionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
  }

  export type AccountUpsertWithoutTransactionsInput = {
    update: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AccountCreateWithoutTransactionsInput, AccountUncheckedCreateWithoutTransactionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTransactionsInput, AccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type AccountUpdateWithoutTransactionsInput = {
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutBalancesNestedInput
    programParticipation?: ProgramParticipationUpdateManyWithoutFundingNestedInput
  }

  export type AccountUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    programParticipation?: ProgramParticipationUncheckedUpdateManyWithoutFundingNestedInput
  }

  export type ClaimCreateManyInputedByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    claimTypeId: number
  }

  export type ClaimStatusCreateManyCreateByInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    claimId: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
  }

  export type AnnouncementCreateManyCreatedByInput = {
    id?: number
    title: string
    content: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    subtitle: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    isCleared?: boolean
    deepLink?: string | null
    fcmToken?: string | null
  }

  export type ClaimUpdateWithoutInputedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutInputedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutInputedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimStatusUpdateWithoutCreateByInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    claim?: ClaimUpdateOneRequiredWithoutClaimStatusesNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutCreateByInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateManyWithoutCreateByInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    claimId?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isCleared?: BoolFieldUpdateOperationsInput | boolean
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    permission: $Enums.Permission
  }

  export type UserCreateManyRoleInput = {
    id?: string
    fullName: string
    email: string
    emailVerifiedAt?: Date | string | null
    password: string
    profilePictureUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId?: number | null
  }

  export type RoleCreateManyHigherLevelThanInput = {
    id?: number
    name: string
    description?: string | null
    order: number
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    participant?: ParticipantUncheckedUpdateOneWithoutUserNestedInput
    claimsInput?: ClaimUncheckedUpdateManyWithoutInputedByNestedInput
    claimActions?: ClaimStatusUncheckedUpdateManyWithoutCreateByNestedInput
    announcementCreated?: AnnouncementUncheckedUpdateManyWithoutCreatedByNestedInput
    notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoleUpdateWithoutHigherLevelThanInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleUncheckedUpdateWithoutHigherLevelThanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    lowerLevelThan?: RoleUncheckedUpdateManyWithoutHigherLevelThanNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutHigherLevelThanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimCreateManyParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
  }

  export type EmploymentCreateManyParticipantInput = {
    id?: number
    employmentPosition: $Enums.Position
    branchId: number
    groupId: number
    regionId: number
  }

  export type ContactInfoCreateManyParticipantInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    addressId: number
  }

  export type ProgramParticipationCreateManyParticipantInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    fundingId: number
    programId?: number | null
  }

  export type AccountCreateManyParticipantInput = {
    id?: number
    currentBalance: number
    currentBalanceLastUpdate?: Date | string | null
  }

  export type ParticipantCreateManyRelationInput = {
    gender: $Enums.Gender
    birthDate: Date | string
    isActive: boolean
    status: $Enums.ParticipantStatus
    userId: string
    bankAccountId: number
  }

  export type ClaimUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentUpdateWithoutParticipantInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    branch?: BranchUpdateOneRequiredWithoutEmploymentNestedInput
    group?: GroupUpdateOneWithoutEmploymentNestedInput
    region?: RegionUpdateOneWithoutEmploymentNestedInput
  }

  export type EmploymentUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactInfoUpdateWithoutParticipantInput = {
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneRequiredWithoutContactInfoNestedInput
  }

  export type ContactInfoUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactInfoUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramParticipationUpdateWithoutParticipantInput = {
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    funding?: AccountUpdateOneRequiredWithoutProgramParticipationNestedInput
    Program?: ProgramUpdateOneWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fundingId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUpdateWithoutParticipantInput = {
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    programParticipation?: ProgramParticipationUpdateManyWithoutFundingNestedInput
  }

  export type AccountUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    programParticipation?: ProgramParticipationUncheckedUpdateManyWithoutFundingNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentBalance?: FloatFieldUpdateOperationsInput | number
    currentBalanceLastUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParticipantUpdateWithoutRelationInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    bankAccountId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutParticipantNestedInput
    bankAccount?: BankAccountUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutParticipantNestedInput
    balances?: AccountUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutRelationInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
    bankAccount?: BankAccountUncheckedUpdateOneWithoutParticipantNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutParticipantNestedInput
    employments?: EmploymentUncheckedUpdateManyWithoutParticipantNestedInput
    contactInfos?: ContactInfoUncheckedUpdateManyWithoutParticipantNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutParticipantNestedInput
    balances?: AccountUncheckedUpdateManyWithoutParticipantNestedInput
    Participant?: ParticipantUncheckedUpdateManyWithoutRelationNestedInput
  }

  export type ParticipantUncheckedUpdateManyWithoutRelationInput = {
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    bankAccountId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactInfoCreateManyAddressInput = {
    id?: number
    telp: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    participantId: string
  }

  export type ContactInfoUpdateWithoutAddressInput = {
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutContactInfosNestedInput
  }

  export type ContactInfoUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactInfoUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    telp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyCityInput = {
    id?: number
    address: string
    postalCode: string
  }

  export type AddressUpdateWithoutCityInput = {
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    ContactInfo?: ContactInfoUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    ContactInfo?: ContactInfoUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentCreateManyBranchInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    groupId: number
    regionId: number
  }

  export type ClaimFinancialCreateManyBranchPayeeInput = {
    id?: number
    requestedAmount: number
    paidAmount?: number | null
    rejectedAmount?: number | null
    transactionProcessDate?: Date | string | null
    transferDate?: Date | string | null
    claimId: string
    claimStatusId: number
  }

  export type EmploymentUpdateWithoutBranchInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participant?: ParticipantUpdateOneRequiredWithoutEmploymentsNestedInput
    group?: GroupUpdateOneWithoutEmploymentNestedInput
    region?: RegionUpdateOneWithoutEmploymentNestedInput
  }

  export type EmploymentUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimFinancialUpdateWithoutBranchPayeeInput = {
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    claim?: ClaimUpdateOneWithoutClaimFinancialsNestedInput
    claimStatus?: ClaimStatusUpdateOneRequiredWithoutClaimFinancialNestedInput
  }

  export type ClaimFinancialUncheckedUpdateWithoutBranchPayeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    claimStatusId?: IntFieldUpdateOperationsInput | number
    claim?: ClaimUncheckedUpdateOneWithoutClaimFinancialsNestedInput
  }

  export type ClaimFinancialUncheckedUpdateManyWithoutBranchPayeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestedAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    rejectedAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionProcessDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transferDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimId?: StringFieldUpdateOperationsInput | string
    claimStatusId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentCreateManyGroupInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    regionId: number
  }

  export type EmploymentUpdateWithoutGroupInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participant?: ParticipantUpdateOneRequiredWithoutEmploymentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutEmploymentNestedInput
    region?: RegionUpdateOneWithoutEmploymentNestedInput
  }

  export type EmploymentUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentCreateManyRegionInput = {
    id?: number
    employmentPosition: $Enums.Position
    participantId: string
    branchId: number
    groupId: number
  }

  export type EmploymentUpdateWithoutRegionInput = {
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participant?: ParticipantUpdateOneRequiredWithoutEmploymentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutEmploymentNestedInput
    group?: GroupUpdateOneWithoutEmploymentNestedInput
  }

  export type EmploymentUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employmentPosition?: EnumPositionFieldUpdateOperationsInput | $Enums.Position
    participantId?: StringFieldUpdateOperationsInput | string
    branchId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramParticipationCreateManyProgramInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    fundingId: number
  }

  export type ClaimTypeCreateManyProgramInput = {
    id?: number
    jenis: string
    jenisRI: string
    plan: string
    claimId: number
  }

  export type ProgramParticipationUpdateWithoutProgramInput = {
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutProgramParticipationsNestedInput
    funding?: AccountUpdateOneRequiredWithoutProgramParticipationNestedInput
  }

  export type ProgramParticipationUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    fundingId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    fundingId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimTypeUpdateWithoutProgramInput = {
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUpdateOneWithoutClaimTypesNestedInput
  }

  export type ClaimTypeUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
    claims?: ClaimUncheckedUpdateOneWithoutClaimTypesNestedInput
  }

  export type ClaimTypeUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: StringFieldUpdateOperationsInput | string
    jenisRI?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    claimId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimStatusCreateManyClaimInput = {
    id?: number
    description?: string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    status: $Enums.ClaimStatusType
    createById: string
    rejectionLetterId?: string | null
    guaranteeLetterId?: string | null
    transactionLetterId?: string | null
    bookKeepingOrderId?: string | null
  }

  export type TagUpdateWithoutClaimsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyWithoutClaimsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: EnumColorFieldUpdateOperationsInput | $Enums.Color
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimStatusUpdateWithoutClaimInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createBy?: UserUpdateOneRequiredWithoutClaimActionsNestedInput
    rejectionLetter?: DocumentUpdateOneWithoutRejectionLetterOfNestedInput
    guaranteeLetter?: DocumentUpdateOneWithoutGuaranteeLetterOfNestedInput
    transactionLetter?: DocumentUpdateOneWithoutTransactionLetterOfNestedInput
    bookKeepingOrder?: DocumentUpdateOneWithoutBookKeepingOrderOfNestedInput
    claimFinancial?: ClaimFinancialUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateWithoutClaimInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    claimFinancial?: ClaimFinancialUncheckedUpdateOneWithoutClaimStatusNestedInput
  }

  export type ClaimStatusUncheckedUpdateManyWithoutClaimInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumClaimStatusTypeFieldUpdateOperationsInput | $Enums.ClaimStatusType
    createById?: StringFieldUpdateOperationsInput | string
    rejectionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    guaranteeLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    bookKeepingOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentCreateManyClaimProcessInput = {
    id?: string
    name: string
    path: string
    size: number
    printCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    source: $Enums.DocumentSource
    type: $Enums.DocumentType
  }

  export type DocumentUpdateWithoutClaimProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClaimProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    rejectionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutRejectionLetterNestedInput
    guaranteeLetterOf?: ClaimStatusUncheckedUpdateOneWithoutGuaranteeLetterNestedInput
    transactionLetterOf?: ClaimStatusUncheckedUpdateOneWithoutTransactionLetterNestedInput
    bookKeepingOrderOf?: ClaimStatusUncheckedUpdateOneWithoutBookKeepingOrderNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutClaimProcessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    printCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumDocumentSourceFieldUpdateOperationsInput | $Enums.DocumentSource
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
  }

  export type ClaimCreateManyDiseaseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    clinicId: number
    inputedById?: string | null
    claimTypeId: number
  }

  export type ClaimUpdateWithoutDiseaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    clinics?: ClinicUpdateOneRequiredWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutDiseaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutDiseaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type ClaimCreateManyClinicsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: $Enums.ClaimChannel
    admedicaStatus: $Enums.AdmedicaStatus
    company: string
    participantId: string
    claimFinancialId: number
    claimProcessId: number
    diseaseId?: number | null
    inputedById?: string | null
    claimTypeId: number
  }

  export type ClaimUpdateWithoutClinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participant?: ParticipantUpdateOneRequiredWithoutClaimsNestedInput
    claimFinancials?: ClaimFinancialUpdateOneRequiredWithoutClaimNestedInput
    claimProcesses?: ClaimProcessUpdateOneRequiredWithoutClaimNestedInput
    disease?: DiseaseUpdateOneWithoutClaimsNestedInput
    inputedBy?: UserUpdateOneWithoutClaimsInputNestedInput
    claimTypes?: ClaimTypeUpdateOneRequiredWithoutClaimsNestedInput
    tags?: TagUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutClinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
    tags?: TagUncheckedUpdateManyWithoutClaimsNestedInput
    claimStatuses?: ClaimStatusUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutClinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: EnumClaimChannelFieldUpdateOperationsInput | $Enums.ClaimChannel
    admedicaStatus?: EnumAdmedicaStatusFieldUpdateOperationsInput | $Enums.AdmedicaStatus
    company?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    claimFinancialId?: IntFieldUpdateOperationsInput | number
    claimProcessId?: IntFieldUpdateOperationsInput | number
    diseaseId?: NullableIntFieldUpdateOperationsInput | number | null
    inputedById?: NullableStringFieldUpdateOperationsInput | string | null
    claimTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyAccountInput = {
    id?: number
    amount: number
    transactionType: $Enums.TransactionType
    description?: string | null
    createdAt?: Date | string
  }

  export type ProgramParticipationCreateManyFundingInput = {
    id?: number
    bpjsNumber?: string | null
    nonActiveReason?: string | null
    effectiveDate: Date | string
    nonActiveDate?: Date | string | null
    participantId: string
    programId?: number | null
  }

  export type TransactionUpdateWithoutAccountInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramParticipationUpdateWithoutFundingInput = {
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participant?: ParticipantUpdateOneRequiredWithoutProgramParticipationsNestedInput
    Program?: ProgramUpdateOneWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateWithoutFundingInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutFundingInput = {
    id?: IntFieldUpdateOperationsInput | number
    bpjsNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nonActiveReason?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    nonActiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participantId?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParticipantCountOutputTypeDefaultArgs instead
     */
    export type ParticipantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParticipantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCountOutputTypeDefaultArgs instead
     */
    export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionCountOutputTypeDefaultArgs instead
     */
    export type RegionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimCountOutputTypeDefaultArgs instead
     */
    export type ClaimCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagCountOutputTypeDefaultArgs instead
     */
    export type TagCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimProcessCountOutputTypeDefaultArgs instead
     */
    export type ClaimProcessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimProcessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiseaseCountOutputTypeDefaultArgs instead
     */
    export type DiseaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiseaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicCountOutputTypeDefaultArgs instead
     */
    export type ClinicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParticipantDefaultArgs instead
     */
    export type ParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactInfoDefaultArgs instead
     */
    export type ContactInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BankAccountDefaultArgs instead
     */
    export type BankAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BankAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmploymentDefaultArgs instead
     */
    export type EmploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmploymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionDefaultArgs instead
     */
    export type RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnouncementDefaultArgs instead
     */
    export type AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnouncementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramParticipationDefaultArgs instead
     */
    export type ProgramParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramParticipationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimDefaultArgs instead
     */
    export type ClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimTypeDefaultArgs instead
     */
    export type ClaimTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimFinancialDefaultArgs instead
     */
    export type ClaimFinancialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimFinancialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimProcessDefaultArgs instead
     */
    export type ClaimProcessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimProcessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClaimStatusDefaultArgs instead
     */
    export type ClaimStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClaimStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiseaseDefaultArgs instead
     */
    export type DiseaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiseaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicDefaultArgs instead
     */
    export type ClinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}